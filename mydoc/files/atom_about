http://zhidao.baidu.com/question/154918260.html
原子意味着不可分割，所谓原子操作就是对变量的读写不能被打断的操作。
举个简单点儿的例子：
1. 假如在一个i386体系架构上；
2. 如果有一个进程要将一个int型的变量改成0x12345678；
3. 另一个进程也希望把这同一个变量改成0x87654321。
4. 如果这个变量的地址没有4字节对齐，那么cpu要改写它的值的话需要两次总线操作。
那么（假设下面的场景，即下列事件先后发生）：
1. 第一个进程刚把高字节写入（x=0x1234xxxx）内存（xxxx表示不确定）；
2. 第二进程就抢占了第一个进程的运行，把第一个进程改了一半的变量改成0x87654321。（当然他也需要两次总线操作，但我们假设他的优先级比第一个进程高）
3. 第二个进程结束运行后，第一个进程又得到了调度，它并不知道自己对变量的操作被另一个进程打断过，所以他会继续更改变量的低字节。
所以，最后这个变量的值就是0x87655678，显然这是两个进程都不想要得到的结果。通过上面的分析你应该知道问题的关键就在于对存储空间的访问被打断了造成的。所以在内核中定义了一系列的原子操作来保证对变量的操作是“原子”的。这种互斥不是高级语言能实现的，必须用汇编，而且依赖于体系架构。对i386来说就是在读写变量的时候先把总线锁住，你可以仔细看看ATOMIC_INIT这个宏的定义。
