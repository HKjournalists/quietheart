++++++APUE读书笔记-14高级输入输出-03记录锁（2）++++++



3、记录锁（2）
================================================
	锁的继承和释放:
	有三个规则用来管理锁的继承和释放：
	a,锁是和进程与文件相关的。这有两个含义。第一个含义很明显，就是当进程终止的时候，它所持有的所有的锁都会被释放；第二个含义就不是那么明显了，意思是当一个文件描述符被关闭的时候，进程持有的所有那个文件描述符所引用的文件上面的锁将都会被释放。具体点说：
	fd1 = open(pathname, ...);
	read_lock(fd1, ...);
	fd2 = dup(fd1);
	close(fd2);
	当我们调用close(fd2)的时候，在fd1上面获取的锁也会被释放(因为fd1引用同一个文件)。我们使用dup替代open的时候，也会发生同样的事情如下：
	fd1 = open(pathname, ...);
	read_lock(fd1, ...);
	fd2 = open(pathname, ...)
	close(fd2);
	这里在fd2上面打开的文件和fd1是同样的文件。
	b,子进程不会通过fork继承锁。这个意思是说，当父进程获取锁之后调用fork，那么子进程对于父进程所获取的那个锁来说是另外一个进程。子进程需要调用fcntl函数向继承自父亲的文件描述符申请自己的锁。这个是很重要的，因为锁存在的意义就是阻止多个进程同时向同样的文件中写入数据，如果子进程通过fork从父进程那里继承了锁，那么父子进程就都可以同时向同样的文件中写入数据了。
	c,锁通过exec函数调用，被新的进程继承。但是需要注意的是，如果文件描述符号的close-on-exec标记被设置了，那么当这个文件描述是符号在exec中被关闭的时候，这个文件上面相应的所有的锁都会被释放。

	FreeBSD上面的实现
	这里给出了一个FreeBSD上面实现时的数据结构，可以帮助我们理解前面规则1中说的“锁是和进程与文件相关的”意思。
	代码如下：
	fd1 = open(pathname, ...);
	write_lock(fd1, 0, SEEK_SET, 1);
	if ((pid = fork()) > 0) {
		fd2 = dup(fd1);
		fd3 = open(pathname, ...);
	} else if (pid == 0) {
		read_lock(fd1, 1, SEEK_SET, 1);
	}
	pause();
	由这个代码，会在内存中生成两个进程的进程表，文件表，以及文件索引表，其图示关系这里就不给出了，具体参见参考资料。这里给出一些相对关键的描述：
	我们可以知道，运行完前面的代码之后，无论是父还是子进程，其文件描述符号fd1,fd2,fd3无论是如何打开的，最终都指向了同一个索引节点（因为它们本身就代表的同一个文件）就是i-node结构。我们看到在这个i-node结构中有一个lockf结构的成员链表，链表中的每一个lockf结构变量都描述了一个特定进程的锁区域，其中lockf结构中有一个成员变量指明这个锁对应的进程的进程ID。从这个例子中，我们可以知道，目前i-node结构中得lockf结构链表中有两个成员，一个表示子进程的锁，一个表示父进程的锁。
	在父进程中，关闭fd1,fd2,fd3中的任何一个，都会导致父进程的锁被释放。释放的时候，内核会遍历i-node中的锁链表，找到调用进程对应的锁并且释放。内核无法知道也不关心父进程是通过这三个文件描述符号中的哪一个来获取到锁的。

	例子
	在前面我们看到过守护进程使用文件锁来确保同一时刻只有一个守护进程的实例在运行。这里，给出了前面守护进程给文件加上写锁所使用的那个lockfile函数的实现。
	我们可以使用如下宏定义将lockfile定义为write_lock的一个宏（write_lock前面已经给出过定义）：
	#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)
	代码如下：
	#include <unistd.h>
	#include <fcntl.h>
	int lockfile(int fd)
	{
		struct flock fl;
		fl.l_type = F_WRLCK;
		fl.l_start = 0;
		fl.l_whence = SEEK_SET;
		fl.l_len = 0;
		return(fcntl(fd, F_SETLK, &fl));
	}

	关于文件结尾的加锁解锁
	向相对文件结尾的位置加锁或者解锁的时候需要注意一些事情。大多数的实现会根据文件当前的位置和长度，将值为SEEK_CUR或SEEK_END的l_whence转换成文件的绝对位移。然而我们需要经常相对于文件的当前位置和长度指定一个锁(一个“整体”的操作)，因为我们不能使用lseek来获得文件的当前位移(这是因为我们不持有文件的锁,这样其他的进程就有机会在lseek和lock之间改变文件的长度)。
	考虑如下的步骤：
	writew_lock(fd, 0, SEEK_END, 0);
	write(fd, buf, 1);
	un_lock(fd, 0, SEEK_END);
	write(fd, buf, 1);
	这个代码序列，可能不会做到你所期望的事情。它从当前的文件结尾获取到了一个可以扩展的写锁，这个锁将会覆盖将来我们追加到文件中的任何数据（但是这个锁当前没有锁住文件的任何内容，特别注意没有锁最后一个字节）。假设我们做第一个写操作的时候正在文件的结尾，那样将会使文件扩展一个字节并且那个扩展的字节将会被锁住。接下来的unlock操作会使将来追加到文件中的数据不再被锁住了，但是它并没有去掉当前新增的文件的最后一个字符的锁（因为文件最后一个字符的位置是SEEK_END-1）。当第二个写操作发生的时候，文件的结尾又被扩展了一个字节，但是这个字节就不是被锁的了。通过这一系列的操作，最后文件中有一个被锁住的字节（就是第一次写的那个字符被锁住了），参考资料中用图示的方式对其进行了描述，这里就省略了。
	当文件的一个部分被锁住的时候，内核会将指定的偏移转换成文件的绝对偏移位置。除了使用SEEK_SET可以指定文件的绝对偏移之外，fcntl还允许我们指定相对于文件某个位置的偏移：SEEK_CUR指定相对当前位置的偏移，SEEK_END指定相对文件结尾的偏移。内核需要记住相应的锁，但是这个锁本身和文件的当前位置以及文件结尾没有关系（尽管这个锁是有范围的），因为当前的位置以及文件的结尾是不断变化的，但是不能因为这些属性发生了变化就改变已经存在的锁的状态（也就是说这个覆盖了一定范围的锁是固定的，不会随着文件的长度当前文件的指针得变化而变化和移动）。
	这里，如果我们想要将第一次写入的字节的锁移除，那么我们可以指定length为-1。用负数的长度值代表指定位置的前面。

	建议锁和强制锁
	假设有一个包含访问数据库函数的库。如果库中的所有函数以一种一直的方式处理记录锁，那么我们就说任何使用这些函数访问数据库的进程集合都是协作的进程。如果只使用这些函数来访问数据库，那么可以让这些数据库访问函数使用强制锁。但是强制锁不能组织其他具有写权限的进程向数据库写数据。这些进程因为没有使用那个库中的函数来访问数据库，所以它们就是非协作进程。
	强制锁导致内核对进程所访问的文件的每一次打开和读写进行检查和验证，看它们是否符合锁的规则。有时候，强制锁也被称作强制模式(enforcement-mode)的锁。
	我们在前面的资料中可以知道，Linux2.4.22和Solaris9提供了强制记录锁，但是FreeBSD5.2.1和MacOS X 10.3并没有提供。强制锁并不是Single UNIX Specification的一部分。在Linux上，如果你想要使用强制锁，需要通过使用mount命令的"-o mand"选项在文件系统的级别上将它激活。
	对于一个特定的文件的强制锁，我们是通过打开set-group-ID位并且关闭group-execute位来将其激活的。可以这样做的原因是，本来关闭group-execute位的同时打开set-group-ID是没有意义的(我们可以查阅前面的章节来确认这一点)，所以 SVR3的设计者们选择了这个方式来指定对一个特定文件的锁不是建议锁(advisory locking)而是强制锁(mandatory locking)。
	当一个进程尝试读写一个文件，而其他进程持有这个文件的读或者是写的强制锁的时候，运行的结果取决于进程的读写类型，其他进程持有的锁类型，以及操作文件是否阻塞。
	文中用一个表描述了这个规则，这里就不重复了，具体参见参考资料，大致描述一下这个表格：
	表格的大致意思就是:和前面的读写锁规则类似，读是可以共享操作的，写却是互斥的，如果出现了不能读或者写的情况，那么根据所操作的文件的特性要么阻塞，要么返回EAGAIN错误。
	除了上述表格描述的读写函数的行为，其它进程持有强制锁，对文件的open操作也会有所影响。一般来说，即使其他进程持有文件的强制锁，open函数也会成功地返回，而接下来的读写操作就会依照上述表格的规则进行。但是调用open时候指定了O_TRUNC 或者 O_CREAT，那么无论是否指定了O_NONBLOCK，open都会立即返回EAGAIN错误。
	只有Solaris将O_CREAT视为一种错误的情况,Linux允许open的O_CREAT标记在文件持有强制锁的时候也可以被指定。对于O_TRUNC生成open的错误是有意义的，因为如果文件具有读或者写锁的时候，无法对文件进行truncate。但是为open的O_CREAT生成错误就没有太大的意义了，因为这个标记的意思是当文件不存在的时候创建一个文件，而只有文件的存在的时候，其它进程才会持有这个文件的记录锁。
	open调用对锁冲突进行如此的处理，会导致一些意外的结果。在本章的一个练习中，有一个测试程序，它运行的时候打开一个可以具有强制锁模式的文件，然后申请了整个文件的读锁，然后进入了睡眠。在睡眠期间，一些典型的UNIX系统应用程序行为的如下：
	a)ed编辑器可以编辑这个文件，并且结果会写入到磁盘中去！这个时候强制锁记录的检查没有一点效果，使用系统调用trace可以看到，ed编辑器是把新的内容写到了一个临时的文件中，然后将原始的文件删除，再将临时的文件重新命名为原始的文件。由于强制锁对unlink函数没有效果，所以发生了这样的情况。
	在Solaris中，进程的trace系统调用通过truss命令获得。FreeBSD和Mac OS X使用ktrace和kdump命令。Linux使用strace命令来跟踪进程发起的系统调用。
	b)vi编辑器无法编辑文件。它可以读取文件中的内容，但是当它尝试向文件写入新的内容的时候，会返回EAGAIN错误。如果我们尝试向文件中追加新的数据，那么写操作会被阻塞。vi所表现出来的行为就是我们所期望的行为。
	c)使用Korn shell的>和>>操作符号来覆盖或者向文件追加内容会导致"cannot create"错误。
	d)使用Bourne shell的时候，>操作符号会返回错误，但是>>符号会阻塞，直到强制锁被移除，然后继续执行。（导致两种shell的>>追加操作符号不同的原因是：Korn shell使用O_CREAT和O_APPEND来打开文件，而我们前面说过使用O_CREAT会产生错误；Bourne Shell在文件已经存在的时候，不指定O_CREAT，所以打开操作是成功的，但是后来的写操作却发生了阻塞）
	根据你所使用的系统的不同，结果也会不同。ed编辑器的处理却绕过了这些不同。另外，注意一个居心叵测的用户可能会利用Mandatory来达到他邪恶的目的。

	例子：
	参考资料中给出了一段程序用来检测一个系统是否支持强制锁。
	这个程序创建了一个文件并且打开这个文件的强制锁特性。程序然后分成两个进程：父进程和子进程。父进程获取整个文件的写锁。子进程首先设置它自己的文件描述符号为非阻塞状态，然后尝试获取文件的读锁，这样期望会获得一个错误，让我们看到系统是返回EACCES或者EAGAIN。然后，子进程回到文件的开始，尝试从文件中读取数据。如果强制锁是支持的，那么读的操作将会返回EACCES或者EAGAIN（因为文件描述符号是非阻塞的），否则读操作会返回它所读取的数据。（通过上面的这个描述，我们可以知道，如果锁是非强制的，那么我们需要自己通过对锁的申请来控制数据的访问，而如果锁是强制的话读写的系统调用里面就进行了自动的检测我们其实就不用显式加锁了^_^）。
	程序的描述大致如上，源代码就不给出了，具体参见参考资料：
	在Solaris 9上面运行程序，那么会返回如下输出：
	$ ./a.out temp.lock
	read_lock of already-locked region returns 11
	read failed (mandatory locking works): Resource temporarily unavailable
	通过"man 2 intro"我们可以知道，errno为11表示EAGAIN错误。
	在FreeBSD 5.2.1上面运行这个程序，我们得到如下输出：
	$ ./a.out temp.lock
	read_lock of already-locked region returns 35
	read OK (no mandatory locking), buf = ab
	这里，errno 为35表示EAGAIN。强制锁是不被支持的。

	又一个例子：
	再回到我们开始的问题：如果两人同时编辑同一文件会怎样？一般的UNIX系统的文本编辑器不会使用记录锁，所以结果取决于最后写文件的进程。
	有些版本的vi编辑器使用建议锁和记录锁。尽管我们使用了这些版本的vi编辑器，也无法阻止其它没有建议锁和记录锁的编辑器运行并修改这个文件。
	如果系统提供了强制记录锁，我们可以修改我们的编辑器以支持它（这需要我们有编辑器的源代码）。如果没有编辑器的源代码，我们可以做如下的尝试：写一个我们自己的程序做为vi的前端。这个程序立即执行fork饭后父进程只是等待子进程的结束。子进程打开命令行指定的文件，使能强制锁，获取整个文件的写锁，然后对vi程序执行excute。当vi运行的时候，文件就是写状态的了，所以其它的用户无法修改它。当vi结束的时候，父进程等待到了子进程并返回，然后我们的前端程序就结束了。
	事实上，我们可以写一个这样的小的程序前端，但是它不能工作。问题是，大多数的编辑器读取它的输入文件，然后就将文件关闭了。这样，当文件描述符号被关闭的时候，这个文件上面的锁就被释放了。也就是说，编辑器在读取到文件内容之后，就关闭了它所打开的文件，导致锁被释放。我们没有办法在前端程序中阻止这个事情的发生。
	我们将在后面的章节中，在一个数据库程序库中使用记录锁，提供多进程并发访问的功能。我们也给出了它的执行时间，并看到记录锁对一个进程到底有什么影响。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch14lev1sec3.html



