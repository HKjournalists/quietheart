++++++APUE读书笔记-16网络通信-08非阻塞和异步I/O++++++



8、非阻塞和异步I/O
================================================
	一般来说recv函数将会在数据没有立即到达的时候阻塞。类似地，send函数将会在套接字用于发送的输出队列没有足够空间的时候阻塞。这个行为会在套接字处于非阻塞的模式的时候有所改变。这个时候，这些函数将会失败，并且设置errno为EWOULDBLOCK或者EAGAIN。当发生这个情况的时候，我们可以使用poll或者select函数来对我们能够发送或者接收数据时候进行处理。
	Single UNIX Specification的实时扩展包含对通用的异步I/O机制的支持。套接字机制有它自己的处理异步I/O的方法，但是这个并没有在Single UNIX Specification中被标准化。有些文章将经典的基于套接字的异步I/O机制称为"基于信号的I/O"，以和实时扩展的异步I/O机制进行区别。
	使用基于套接字的异步I/O，我们可以设置在我们能够读取数据或者套接字的写队列中有空间的时候被发送SIGIO信号。激活异步I/O是一个两步的过程：
	a.建立套接字属主，这样信号可以被发送到合适的进程。
	b.通知套接字，我们想要它在I/O操作没有阻塞的时候给我们发送信号。
	我们可以以三种方式完成第一个步骤：
	a. 使用fcntl函数的F_SETOWN命令。
	b. 使用ioctl函数的FIOSETOWN命令。
	c. 使用ioctl函数的SIOCSPGRP命令。
	我们有两个选择可以完成第二个步骤：
	1.使用fcntl函数的F_SETFL命令并且激活文件的O_ASYNC标记。
	2.使用ioctl函数的FIOASYNC命令。
	对于上面的那些命令，有一些但是它们并不是通用的。具体这些套接字异步I/O管理命令在那个系统上支持，请参考参考资料中的一个表格，这里面就不列举出来了。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch16lev1sec8.html



