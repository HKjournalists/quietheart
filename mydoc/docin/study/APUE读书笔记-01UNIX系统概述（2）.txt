++++++APUE读书笔记-01UNIX系统概述（2）++++++



4、输入输出
================================================
（1）文件描述符号
	文字描述符是一个小的非负整数，内核用以标识一个特定进程正在访问(读或者写)的文件。当内核打开一个或创建一个文件时，它就返回一个文件描述符。然后当读、写文件时，就可使用它。
	例如在我们代码上，如下方式体现：
	int fd = open("/usr/test", ...);
	read(fd,...);
	这里,表示使用系统调用open来打开"/usr/test"路径表示的文件，然后通过返回的文件描述符号fd，使用系统调用read读取其中的内容。(...表示系统调用"open"和"read"其他的参数 ,这里不讨论) 。

（2）标准输入、标准输出和标准错误
	一般，每当运行一个新程序时，所有的shell都为其打开三个文件描述符：标准输入、标准输出以及标准错误。三个文件描述符号会被设置为引用（也就是被定向）某种文件（例如文本文件，或者设备文件）。一个直观的理解就是，一般来说，标准输入表示我们的键盘，我们键盘敲入字符就是标准输入中的字符了；标准输出就是我们看到的屏幕，程序的输出通过屏幕显示出来，这个屏幕显示出来的就是标准输出的内容；标准错误和标准输出差不多，就是当程序出错的时候，产生的错误输出也通过屏幕显示出来，这个时候显示的内容属于标准错误的内容。以上说的是默认的情况，大多数shell都提供一种方法，使任何一个或所有这三个描述符都能重新定向到某一个文件。
	(a)例如对于输出重定向：
	ls > file.list
	如果直接执行ls命令，将会在当前标准输出上显示当前目录下所有的文件，而这里其标准输出重新定向到名为file.list的文件上。这个时候，我们就看不到程序ls的输出在屏幕上显示了，而是直接输出到了file.list文件里。标准输出的文件描述符号默认为1。
	对于标准错误输出：
	ls 2> file.list
	表示，将ls出错时候的标准错误显示到file.list里面。标准错误输出的文件描述符号默认为2。
	再者：
	ls 2>&1
	表示，将ls的标准错误重定向到标准输出上。
	而：
	ls &>file.list
	表示，将ls的标准输出和标准错误都定向到文件file.list上。
	以上，是对输出的重定向，如果">"后面的文件当前存在，那么就会被清空，否则新建一个文件。如果想要追加内容到已有文件而不是清空，那么就用">>"代替">"。
	(b)再给出一个标准输入重定向的例子：
	xxx <fileinput
	表示，将xxx的标准输入重新定向到文件中。这里xxx表示某个程序，它需要从用户键盘输入读取数据，而这样做之后，就直接将fileinput的内容作为用户键盘输入了。标准输入的文件描述符号默认为0。

（3）带缓存和不带缓存的输入输出
	这一部分内容后面会提到。大体上，用一个读写的例子来描述，就是：我们使用系统调用"read"，"write"等对文件描述符号的文件进行读写的时候，文件内容不经过缓存（当然这里的缓存指的是缓冲，并不是没有缓存了，这里不经过缓存的意思是说：告诉系统调用操作多少，那么它就会尽量操作这些数据然后返回，即使数据小于缓存大小，也返回而不是缓存下来；若传入的数据量大于缓存容量那么就分多次操作，因为超过了缓存大小所以不得不分多次操作了），直接从磁盘上被读取；而如果我们使用标准输入输出方式进行操作（一般是通过库函数），那么操作的方式是通过一个指向某数据结构的指针，来操作文件，这时候读写的内容会先经过缓存，而这个数据结构（例如FILE类型）中就包含了文件描述符号，以及一些其他例如缓存等内容。具体我们可以看系统调用函数read以及fread函数之间的区别。在标准输入输出方式进行操作的时候，使用"stdin","stdout","stderr"表示标准输入，标准输出，和标准错误。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec5.html


5、程序和进程
================================================
（1）程序
	程序（program）是存放在磁盘文件中的可执行文件，是我们可以看得见得一个文件。通过使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。8.9节将说明这些exec函数。例如shell中，我们执行"ls"的时候，“ls”实际就是程序名称，它就是一个实际的可执行文件，一般存放在"/usr/bin"目录下面。

（2）进程和进程I D
	程序的一次执行实例被称为进程（process）。当程序被加载到内存中执行的时候，它就变成了进程，也就是说，内存中运行该程序的一个实例，这个实例就是进程。一个程序可以对应多个进程，就好比我们同时执行了好多次"ls"，这个时候，每次执行ls的时候，都会将这个程序加载到内存中一次，相应就产生了对应着此次执行该程序的实例。每个UNIX进程都一定有一个唯一的数字标识符，称为进程ID（process ID） ，进程ID总是一非负整数，用来表示运行的进程。
	综上可知，程序只是一堆可执行代码，“静态”地存放在磁盘上面。而进程就是每次执行程序的时候，被加载到内存中开始运行的“动态”的实例。程序只是一个可执行的文件，也就是我们编写代码之后，编译、链接出来的一个结果，而进程就是这个编译链接出来的结果程序，真正运行的过程。本书后面会对进程的各种控制（创建、终止、开始、停止等）进行详细讲述。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec6.html


6、错误处理
================================================
	当UNIX函数出错时，往常返回一个负值，同时将整型变量errno设置为具有特定信息的一个值。例如，open函数如成功执行则返回一个非负文件描述符，如出错则返回-1，同时设置errno。在open出错时，有大约15种不同的errno值(文件不存在，许可权问题等)。
	这里的errno就是一个系统的全局变量。文件<errno.h>中定义了变量errno以及可以赋与它的各种常数,这些常数都以E开头。关于errno的具体信息，可以参见系统的用户手册（例如在我的LINUX上面可以运行"man 7 errno"）。POSIX中将它定义为：
	extern int errno;

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec7.html



