++++++APUE读书笔记-前言-说明（2）++++++



	这里给出本书正文部分每个章节的大致内容，便于阅读、查阅时候参考；通过它，我们也可在阅读本书正文内容之前，对本书所述的大体内容有所了解。本书正文部分每个章节的大致内容总结如下：

APUE读书笔记-00预备知识（01）-Linux文件系统以及目录结构简介
	Linux和Windows操作系统中的文件系统些不同，在学习使用Linux之前，能够了解这个不同之处助于后续的学习。本节先对Windows和Linux上面文件系统的一些概念进行区分，然后介绍一些Linux文件系统相关的原理，最后较为详细地介绍了Linux系统的目录结构。

APUE读书笔记-00预备知识（02）-Linux命令简介
	本节最开始介绍Linux命令相关的基本知识，然后给出一些基本的Linux命令。

APUE读书笔记-00预备知识（03）-Linux下C语言编程简介
	看过本节，应该能够大体了解Linux下面的C编程是怎么回事了。本节的最简实践部分，可以给您提供一个尝试在Linux下运行您的C程序的机会。

APUE读书笔记-00预备知识（04）-Linux系统中程序库文件简介
	本节对Linux库的编译，生成，使用进行了简单的介绍，并且通过一个简单例子（开发自己的库）进行说明。

APUE读书笔记-00预备知识（05）-预留
	本节仅对一些可能会利于阅读本书的、其他的预备知识给出，并以此结束“预备知识”这一章，本节中已经对此进行说明，这里不再重复。

APUE读书笔记-01UNIX系统概述
	本章从程序设计人员的角度先快速浏览UNIX，并对书中引用的一些术语概念进行简要的说明并给出实例。在以后各章中，将作更详细的说明。本章也对想要熟悉UNIX环境的程序设计人员简要介绍了UNIX提供的各种服务。

APUE读书笔记-02UNIX标准和实现
	在本章中，我们首先看到过去的20年间UNIX编程环境的标准化上面发生了许多的事情，以及所做的各种不同的标准化的努力。然后，我们讨论针对本书中所涉及到的、系统实现中的、UNIX编程标准化上面的努力。这里讨论了一些重要的标准，如ISO C，POSIX，Single UNIX Specification以及它们在我们本书中所涉及到的四个系统中的作用。所有标准化中，一个重要的部分就是每种实现所定义的各种不同的限制规范，所以，我们也会看到这些限制以及定义它们的各种不同方法。这里同时提到，我们本书所涉及的四个系统即是：FreeBSD, Linux, Mac OS X, 以及 Solaris。

APUE读书笔记-03文件输入输出
	本章描述了UNIX系统提供的基本输入输出（I/O）函数。文件输入输出函数包括：打开文件、读取文件、写文件等等。大多数UNIX系统上面的文件输入输出操作，都可以使用5个函数来完成：open，read，write，lseek，以及close。这些函数也经常被称作非缓冲I/O函数，因为，每次read或者write都会发起一次内核的系统调用。这些非缓冲的I/O函数并不是ISO C的一个部分，但是却是 POSIX.1 和 the Single UNIX Specification的一个部分。通过使用read和write，我们看到了不同I/O大小的时候对读取一个文件的时间的影响（在一定范围内，请求数据越大，读写系统调用被发起的次数越少，导致占用系统时间也减少）。我们也看到了将被写入的数据刷新到磁盘上面的方法，以及它们对应用程序执行效率的影响。当多进程向同一个文件追加内容的时候，以及当多个进程创建同样一个文件的时候，介绍了原子操作。我们也看到了内核内部用来共享打开文件信息的相关数据结构。我们将在后面的章节中，继续谈到这些数据结构。我们也讨论了函数ioctl和函数fcntl。后面第14章的时候，我们会回到这些函数，我们将使用ioctl操作STREAMS I/O系统，使用fcntl来实现记录锁。

APUE读书笔记-04文件和目录
	本章以stat结构为中心,详细讨论了其中的每个成员。前面章节的讨论集中在正规文件上（就是普通的文件），例如打开文件、读取写入文件。而本章的讨论使得我们也看到了UNIX文件的所有属性。在这个过程中，我们也会讲到每个修改这些属性的函数：改变属主，改变权限等等。对一个文件的所有属性以及UNIX编程操作文件所需要的基本函数有了大体的了解。我们也会看到UNIX文件系统以及符号链接更为细节的内容。

APUE读书笔记-05标准输入输出库
	在本章，我们讲述了被大多数UNIX应用程序使用的标准输入输出（即标准I/O）库，我们将会看到这个库提供的所有函数，以及一些实现的细节和效率方面问题的考虑。由于这个库也被许多非UNIX的操作系统实现了，所以这个库由ISO C标准指定。标准输入输出库处理了诸如缓存分配，以及分配优化的大小的块进行I/O，这样我们就不必担心如何使用正确的块大小进行I/O了（如原书3章9节所描述的那样），这个库也就很容易使用了，但是同时，正是因为这些缓存，也引入了我们没有预料到的很多让人困扰的一些问题，所以在使用标准库进行输入输出时，我们需要注意这个库中的缓存的情况。

APUE读书笔记-06系统数据文件和信息
	本章讲述了各种访问系统数据文件的函数。UNIX系统需要许多数据文件用于日常操作，例如：密码文件/etc/passwd以及组文件/etc/group等，以前，这些系统数据都是ASCII文本文件，被标准I/O库读取；但是，对于较大的系统，顺序扫描密码文件时非常耗时的。我们想要以非ASCII文本方式来存放这些数据，但是向上层应用程序提供一个和文件格式无关的接口（通过这些接口来读写文件屏蔽了具体实现细节）。也就是本章将讨论的函数，其中包括系统标识函数，日期和时间函数等。另外，也介绍了影子口令（可以增加系统的安全性），以及说明了添加组ID可以让一个用户同时参加多个组。

APUE读书笔记-07进程环境
	本章对UNIX系统环境中一个C程序的运行环境进行了介绍。在下一章讲述进程控制相关的内容之前，我们需要先对单个进程的情况有所了解。我们将会看到main函数在执行程序的时候是如何被调用到的，命令行参数是如何传递给新的程序的，典型的内存布局是什么样的，以及如何申请释放内存，进程如何使用环境变量，以及各种终止进程的方法（其实，就是通过exec函数执行新的程序，exit等终止进程）。另外，我们也会看到longjmp函数和setjmp函数，以及它们和堆栈的交互情况。最后我们通过讲述一个进程的资源限制来结束本章。

APUE读书笔记-08进程控制
	本章我们将讲述UNIX系统提供的进程控制相关的内容。想要更为深入地了解编程，需要对UNIX系统中的进程控制机制有所了解。我们讲述了新进程的创建，程序的执行，以及进程的终止。我们讲述了在许多程序中都使用的、需要掌握的几个基本函数：fork, exec函数族, _exit, wait, 以及waitpid。其中，fork函数使得我们也看到了一种竞争条件。我们也会看到进程属性相关的各种ID：真实(real user)用户/组ID，有效(effective user)用户/组ID，保存(saved)用户/组ID，以及进程的基本控制（控制原语）如何影响它们。通过了解进程的各种用户ID和组ID（real,effective,save），我们知道如何去写一个安全的set-user-ID程序。本章也谈到了解释器文件的运作以及system函数的详细实现，最后我们通过讲述大多UNIX系统提供的进程记账机制结束本章，这也使得我们从一个不同的角度来看待进程控制函数。这样，我们已经对单一进程环境以及子进程有了一定的了解，下一章我们将看到不同进程会话之间的关系，以及作业控制相关内容。我们然后在第10章讲述信号的时候结束对进程的讨论。

APUE读书笔记-09进程关系
	本章中，我们细入去讲述了进程组间的各种关系。在前面的章节中我们了解到进程之间具有一定的关系。首先，每个进程都有一个父进程（最初的内河级别进程通常是它们自己的父进程）。当子进程结束的时候父进程会收到通知，这样父进程就可以获取子进程的退出状态。当我们讨论waitpid函数的时候，我们也提到了进程组的概念，以及我们如何等待一个进程组中的任何一个进程结束。本章我们将会看到当我们登陆之时，我们的登陆shell和从登陆shell上启动的所有进程之间的关系。进程组之间的关系，主要就是会话，会话的概念是在POSIX.1中引入的，会话由进程组构成。另外，作业控制是目前多数UNIX系统提供的一个特性，我们讲述了如何通过支持作业控制的shell来实现作业控制。进程的控制终端，/dev/tty也在讨论这些进程关系的时候有所涉及。我们在谈到这些进程关系的时候，引用了大量的信号相关的概念，下一章，将会继续讲述这些信号概念，并且对UNIX系统中的信号机制做详细地讲述。

APUE读书笔记-10信号
	本章对unix系统的信号部分做了一个比较全面的介绍。信号是软中断，许多重要的程序都需要处理信号。信号提供了一种异步事件的途径：通过一个用户在终端键入中断按键，来停止一个程序，或者提前结束管道中的下一个程序。对于高级unix系统编程来说，了解信号处理函数为什么以及如何做的是非常重要的。我们首先见识了早期系统实现中信号部分的缺陷（例如Version 7这样的系统提供的信号模型并不是可靠的，信号可能会丢失，也可能在执行关键代码的时候，很难关闭选择的信号）；然后我们涉及到POSIX.1中的可靠信号概念以及所有相关的函数（例如4.3BSD和SVR3改变了信号模型，提供了稳定的信号机制，Berkeley和AT&T所作的改变并不是兼容的。POSIX.1提供了标准化的可靠信号处理，我们就讨论这个）；当我们把所有这些的细节都说明过了之后，我们就能够编写POSIX.1的abort,system,和sleep函数的实现了；我们最后介绍了作业控制信号和信号名称和信号号码之间的切换。

APUE读书笔记-11线程
	本章我们介绍了线程相关的内容。通过前面章节对进程的相关讨论，我们可以知道，进程间可以进行有限的共享，而线程则可以进行更多的共享，所有同一个进程中的线程都可以共享访问例如文件描述符号，内存等进程资源等。本章，我们将会深入到进程的内部，看到如何在单进程环境中使用多线程控制。我们先讨论了创建和销毁一个线程的POSIX相关函数；然后引入了线程的同步机制，防止在它们之间出现共享的资源不一致的情况。因为我们经常在想要在多个用户之间共享单个资源的时候，需要处理一致性的问题，所以，本章中重点讨论了三个基本的同步机制，互斥信号量，读写锁，以及条件变量，同时我们也看到了如何利用它们来保护共享资源。

APUE读书笔记-12线程控制
	前面我们讲述了和线程以及线程同步相关的基础知识，本章我们将学习对线程的具体控制。线程提供了在unix系统中将一个任务分割的可选的途径。使用线程，可以在各个线程之间方便地共享数据，但是也会引入一些同步的问题。在本章，我们介绍了如何使用线程并且处理这些线程之间的同步问题，我们会看到一些线程和线程同步相关的一些属性，而这些属性在前面的章节中都是忽略没有谈到的（通过只使用其默认值而略去不谈的）。我们也会讨论线程中存在的可重入性问题，讨论同一进程中的线程如何和其他的线程保持数据的私有性，最后我们也谈到了一些基于进程的系统调用如何和线程进行交互。

APUE读书笔记-13守护进程
	这一章我们来看一下守护进程的结构，以及如何写一个守护进程。在大多UNIX系统中，守护进程是一直运行的，它们一般在系统启动的时候运行，在系统关闭的时候终止。而这一章我们就实现了一个函数，适合用来把一个进程初始化为守护进程。将我们的进程初始化运行成一个守护进程，需要我们对之前讲述的进程之间的关系有一定的了解。因为守护进程一般都没有控制终端，所以它们运行在后台。没有控制终端，所以我们讨论了守护进程登记错误消息的一些方法。我们也讨论了一些UNIX系统上面守护进程遵循的一些比较传统的约定俗成的规则，然后给出了一些实现这些规则的例子。

APUE读书笔记-14高级输入输出
	这一章描述了大量的函数和内容，它们涉及到高级的I/O操作：非阻塞I/O，记录锁，System V流（STREAMS），多I/O(select和poll函数相关的内容)，readv和writev函数，内存映射I/O（关于mmap）。我们需要在后面描述进程内部通信以及许多例子的时候涉及到这些内容。进一步说：非阻塞I/O是一种I/O操作，操作的时候没有阻塞的情况发生；记录锁(本书第20章中开发的一个数据库操作函数的例子中对其进行了详细的说明可以做为参考)；System V的STREAMS(在后面我们讲述基于流的管道，传递文件描述符号，以及System V的客户服务端链接时会用到)；使用select 和poll函数的多I/O(后面的许多例子中会用到)；readv和writev函数(后面也有许多地方用到它们)；内存映射I/O。

APUE读书笔记-15进程内部通信
	前面我们讲述进程控制，的时候，多个进程交互的方式是通过fork传递打开的文件描述符号，或者通过文件系统；这里我们将要讲述进程之间通信的另外的技术：IPC，或者内部进程通信，其中的机制允许运行在同一台机器上面的进程之间相互通信。过去UNIX中的IPC有非常多的实现方法，非常混乱，其中可移植到其它unix平台的不多。通过POSIX和Open Group（以前是X/Open）的标准化的努力，状况才有所改善。但是仍然有不同的地方。这里的参考资料就给出了一个表格，表格中列出的IPC可以在本书的四个平台上面使用。关于这些IPC通信方法，有的是在本地进程之间进行通信，有的是在不同机器进程之间的通信，哪些系统支持哪些通信的方式，在书中都有所说明，具体参考书中内容，这里不做重复。我们将IPC分为三个部分进行介绍：这里，我们对经典的IPC技术进行介绍；下一章我们讨论使用套接字技术的网络IPC技术；然后，我们再介绍IPC的一些高级特性。本章我们将详细讲解的内部进程通信技术：管道（PIPEs和FIFOs，这里，有名管道即FIFOs，而无名管道即PIPEs）；和三种XSI的通用IPC技术（消息队列，信号量，和共享内存）。信号量实际上是一种同步机制，并不是真正的IPC机制，它一般用来同步共享资源的访问，例如共享内存段；通过pipes，我们看到了popen函数的实现，协作处理进程，以及使用标准输入输出库时候缓存时候遇到的问题；在对比了消息队列和全双工管道，信号量和记录锁的时间之后，我们可以得到如下建议：应该学习管道(pipes)和有名管道(fifos)，因为这两种基本的技术在许多的应用程序中工作的效率还是非常高的，避免在新的应用程序中使用消息队列和信号量，可以使用全双工管道和记录锁来替代，因为它们使用起来要简单得多，尽管使用mmap函数也能实现类似共享内存的功能，但是共享内存还是有它的作用的。在后面，我们将会看到网络的IPC技术，这允许进程之间跨越不同的机器进行通信。

APUE读书笔记-16网络通信
	在前面的章节，我们讲述了unix提供的、允许运行在同一台机器上面的进程之间相互通信的、经典的IPC方式；本章将会介绍在不同机器上运行的进程之间的通信（通过一个公共的网络），即网络通信。我们讨论了网络IPC的套接字接口（API），POSIX.1上面定义的套接字API是基于4.4BSD的，尽管随着时间的逝去，接口有了些许的变化，但是当前的套接字接口和之前被引入的早期的原来的1980年的4.2BSD的套接字接口还是非常类似的。通过这些接口，我们可以知道套接字末端如何被命名，以及我们在和服务端进程进行通信的时候怎样能够发现相应的地址信息，进而可以实现让进程和本地或者别的机器上面的进程进行通信；这也是套接字的一个目的，无论在同一个机器还是不同的机器上面通信都使用同一套接口。尽管可以使用套接字通过不同的网络协议实现通信，这里我们将范围限制在Tcp/Ip协议上面，这也是因特网上事实的标准。我们展示了使用无连接方式（也就是基于数据报的方式）的套接字和面向连接的套接字的例子。我们也简要地讨论了异步和非阻塞的套接字I/O以及用来管理套接字选项的接口。本部分内容只对套接字进行了简单的介绍，更详细的资料请参见其他资料。在下一个章节中，我们将要看到一些高级的IPC内容，包含我们如何使用套接字在运行在同一台机器上面的进程之间传递文件描述符号。

APUE读书笔记-17高级进程通信
	在前面的两章，我们介绍了各种类型的进程通信（内部和外部 ），包括管道和套接字；在本章我们将会看到两个高级的通信（IPC）方式：基于流的管道以及Unix域套接字；以及我们可以对它们进行怎样的操作。通过这些形式的IPC，我们可以将打开的文件描述符号在进程之间进行传递，服务进程可以将名称和这些文件描述符号进行关联，客户进程可以使用这些名称和服务进程之间进行通信。我们也会看到，操作系统如何为每一个客户进程提供单一的IPC通道。这个章节的关键之处就是在进程之间传递文件描述符号，以及接收来自客户进程的单一连接的能力。我们已经看到了使用STREADM pipes和UNIX域套接字对此如何进行实现。尽管所有的平台都支持UNIX域套接字，但是实现都有所不同，所以增加了我们开发可移植的程序的难度。我们也开发了两个版本的打开文件服务程序，一个版本通过客户进程调用fork和exec来执行；另外一个是采用守护进程的方式来处理所有的用户请求。两个版本都使用了文件描述符号的传递和接收函数。后面的版本也使用了前面介绍的客户服务连接相关的函数，以及前面的多I/O函数。

APUE读书笔记-18终端输入输出
	本章我们将要看到所有POSIX.1的终端相关函数以及一些平台特定的内容。无论什么操作系统，对于终端输入输出的处理都是一个非常杂乱的领域，UNIX系统也是这样，一般在大多数编程手册中，终端输入输出是最长的部分。终端输入输出之所以很复杂，其一部分原因也是因为人们使用终端输入输出来做许多事情：终端，计算机之间的硬连接线，调制解调(modems)，打印机等等。对于UNIX系统，在1970s出现了一个分歧：System III开发了一套和version7不一样的终端函数集合；SystemIII形式的终端输入输出在System V中延续下来，而Version 7形式的成为基于BSD系统的标准；和信号处理一样，这两个不同的分歧在POSIX.1中不存在了。本章我们将要看到所有POSIX.1的终端相关函数以及一些平台特定的内容。终端有许多的特性和选项，我们可以修改它们中的大多数，来适应我们的需求。在本章，我们叙述了大量的可以改变终端操作的功能：特殊输入字符和选项标记。我们也看到了所有的终端特殊滋是以及许多可以设置或者重置终端设备的选项。终端的输入有两种模式：canonical（每次一行）模式和noncanonical模式。我们展示了两种模式下面的例子，也提供了一些函数可以在POSIX.1终端选项以及原来的BSD的cbreak和raw模式之间映射。我们也描述了如何获取和改变终端窗口的大小。

APUE读书笔记-19伪终端
	本章，我们将介绍伪终端相关的内容。在前面，我们看到了终端的登陆通过一个终端设备, 并且自动提供终端的语义；在终端和我们运行的程序之间有一个终端行规范，所以我们可以设置终端特殊字符 (backspace, line erase, interrupt, 等.)和类似的内容。然而，当一个来自网络连接的登陆请求到达的时候，在网络连接和登陆的shell之间并不会自动地提供终端行规范，这需要用到伪终端，前面的图形(原书第9章第3节)中，给出使用伪终端设备驱动来提供终端的规范。除了网络登陆之外，我们将会看到伪终端还会有其他的应用之处。我们开始对如何使用伪终端进行了一个展示，然后讨论特定的应用。我们之后会提供在各种平台上面建立伪终端的函数，并且使用这些函数写一个叫做pty的程序。我们将会展示这个程序的多个用途：创建一个对终端上面所有输入输出字符的转换脚本（script程序），然后运行协作处理进程来防止出现我们在进程通信时候遇到的那个缓存问题。通过这个pty程序，我们展示了伪终端的许多特性。一般我们在大多数UNIX系统中使用伪终端来提供网络登陆。我们也通过一个用批处理脚本启动交互程序的脚本程序，看到了其他使用伪终端的使用。

APUE读书笔记-20应用
	本章讲述的是利用已有的知识，进行实际的应用开发的过程。本章对应原书的第20、21章，这两章分别讲述了一个用来操作数据库的库的开发，以及一个可以和网络打印机通信的程序的开发。而本章只给出这两个部分的最简单的介绍，并没有对此进行完全的翻译，如何使用已有知识进行这一章所涉及的应用的开发，具体请参见原书的参考资料，这里不再对此进行叙述。


