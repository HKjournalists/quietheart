++++++APUE读书笔记-19伪终端-02总体概述++++++



2、总体概述
================================================
	伪终端的意思是，这个终端对于应用程序来说表现像是一个终端，但是实际上它并不是一个真正的终端。下面的图就展示了一个典型的进程使用伪终端的组织结构。
	                         进程使用伪终端的典型结构
	
	                     +----------+         +----------+
	                     |    user  |  fork   |   user   |
	                     |  process |-------->|  process |
	                     +-----^----+  exec   +-----^----+
	                           |                    |stdin,stdout,stderr
	            +- - - - - - - - - - - - - - - - - - - - - - - - -+
	            |              |                    |             |
	                 +---------v-------+   +--------v-------+
	            |    | read and write  |   | read and write |     |
	                 |    functions    |   |    functions   |
	            |    +-----|-----^-----+   +----|------^----+     |
	                       |     |              |      |
	            |          |     |         +----v------|----+     |
	                       |     |         |    terminal    |       Kernel
	            |          |     |         | line dscipline |     |
	                       |     |         +----|------^----+
	            |          |     |              |      |          |
	                 +-----v-----|-----+   +----v------|----+
	            |    | pseudo-terminal |   | pseudo-terminal|     |
	                 |     master      |   |     slave      |
	            |    +-----|-----^-----+   +----|------^----+     |
	                       |     |              v      |
	            |          |     +<-------------+      |          |
	                       v                           |
	            |          +-------------------------->+          |
	            +- - - - - - - - - - - - - - - - - - - - - - - - -+
	
	a.一般来说，进程打开伪终端主控端(后面用pseudo-terminal master表示)，然后调用fork。子进程建立新的会话，打开相应的伪终端从控端（后面用pseudo-terminal slave表示），复制文件描述符号到标准输入、标准输出、标准错误输出，然后调用exec。pseudo-terminal变成子进程的控制终端。
	b.对于slave端的用户进程来说，它的标准输入，标准输出，以及标准错误输出是一个终端设备。进程可以对这些文件描述符号调用所有前面描述的终端I/O相关的函数。但是，因为在slave下面没有真正的终端设备，所以不会起作用的那些函数（改变波特率，发送break字符，设置oddparity等），会被忽略。
	c.任何写入到master端的内容都会被视作slave端的输入，反之亦然。实际上，所有到达slave端的输入来自pseudo-terminal master上面的用户进程。这个行为看起来就像是一个双向的管道。但是通过slave上面的终端行规范模块，我们可以有除了管道之外更多的能力。
	上面的图中的伪终端表现是FreeBSD,Mac OS X, 或者 Linux系统上面的大致情况。后面，我们将要展示如何打开这些设备。
	
	在Solaris下，伪终端通过使用STREAMS子系统构建。下面的图形列出了Solaris下面的伪终端STREAMS模块的组织结构。两个用虚线框起来的STREAMS模块(ttcompat和pckt)是可选的。pckt和ptem模块用来提供伪终端的语义规范。另外两个模块(ldterm和ttcompat)提供行处理规范。
	                         Solaris下面伪终端的结构
	
	                     +----------+         +----------+
	                     |    user  |  fork   |   user   |
	                     |  process |-------->|  process |
	                     +-----^----+  exec   +-----^----+
	                           |                    |stdin,stdout,stderr
	            +- - - - - - - - - - - - - - - - - - - - - - - - -+
	            |              |                    |             |
	                 +---------v-------+   +--------v-------+
	            |    |  stream head    |   |   stream head  |     |
	                 +-----|-----^-----+   +----|------^----+
	            |          |     |              |      |          |
	                       |     |         +- - v- - - |- - +
	            |          |     |         .    ttcompat    .     |
	                       |     |         . STREAMS module .
	            |          |     |         + - -| - - -^ - -+     |
	                       |     |              |      |
	            |          |     |         +----v------|----+     |
	                       |     |         |     ldterm     |
	            |          |     |         | STREAMS module |     | kernel
	                       |     |         +----|------^----+
	            |          |     |              |      |          |
	                 +- - -v- - -|- - -+   +----v------|----+
	            |    .      pckt       .   |      ptem      |     |
	                 .  STREAMS module .   | STREAMS module |
	            |    +- - -|- - -^- - -+   +----|------^----+     |
	            |          |     |              |      |          |
	                 +-----v-----|-----+   +----v------|----+
	            |    | pseudo-terminal |   | pseudo-terminal|     |
	                 |     master      |   |     slave      |
	            |    +-----|-----^-----+   +----|------^----+     |
	                       |     |              v      |
	            |          |     +<-------------+      |          |
	                       v                           |
	            |          +-------------------------->+          |
	            +- - - - - - - - - - - - - - - - - - - - - - - - -+
	
	需要注意的是slave上面的三个STREAMS模块和以前"高级输入输出"中的一个名为"列出stream上的模块名称"的用于网络登陆的代码中的输出是一样。后面我们将会展示如何构建这个结构的STREAMS模块。
	
	现在开始，我们将要通过去掉"read and write functions"来简化前面的"进程使用伪终端的典型结构"图形，或者通过去掉"stream head"简化前面的"Solaris下面伪终端的结构"图形。我们将会使用PTY表示伪终端的简写，把前面"Solaris下面伪终端的结构"的slave PTY之上所有的STREAMS模块放到"terminal line discipline"盒子中。
	我们现在将会看看一些伪终端的典型使用。
	
	网络登录服务
	伪终端被编译成支持网络登录的服务。典型的例子就是telnetd和rlogind服务。第15章给出了rlogin服务的具体步骤。当登录shell运行在远程主机上面的时候，我们会有下面图形的结构。使用telnetd服务也会有类似的结构。
	
	                        rlogind服务进程的组织结构
	
	            +--------------------+   fork     +-----------+
	            |      rlongind      +------------>   login   |
	            |       server       | exec,exec  |   shell   |
	            +----/-----^---\---^-+            +---|----^--+
	                /     /     \   \          stdout |    |stdin
	               /     /       |   \         stderr |    |
	     +......../...../........|...|................|....|.........+
	     .   +---v-----/----+    |   |           +----v----|-----+   .
	     .   |    TCP/IP    |    |   |           |    terminal   |   .
	     .   +---|-----^----+    |   |           |line discipline|   .
	     .       |     |         \    \          +----|----^-----+   .
	     .       |     |          \    \              |    |         .
	     .   +---v-----|----+    +-v----\---+       +-v----|--+      .kernel
	     .   |    network   |    |   PTY    |       |   PTY   |      .
	     .   | device driver|    |  master  |       |  slave  |      .
	     .   +------^-------+    +-|----^---+       +-|----^--+      .
	     .          |              |    |             v    |         .
	     .          |              v    +<------------+    |         .
	     .          |              +---------------------->+         .
	     +..........|................................................+
	                v
	       ...................
	             network
	
	我们在rlogind服务和loginshell之间两次调用exec，因为login程序会在两者之间，用来用户验证。
	上面这个图形中的一个比较关键的地方就是驱动PTY master的进程一般同时都会也读取另外一个I/O stream。在这个途中，另外的I/O stream就是 TCP/IP box。这也意味着进程必须使用一些多I/O的形式，例如select或者poll，或者必须被分割成两个进程或者线程。
	
	script 程序
	script程序由大多数的UNIX系统提供，它会将终端会话过程中的任何输入输出拷贝到一个文件中去。这个程序通过将它自身放置在终端和我们新启动的一个登陆shell之间来做到这个。下面的图详细列出了script程序的交互。这里我们特别指出script程序一般从一个登陆的shell中运行，然后这个登陆的shell等待script终止。
	
	                                   script程序
	
	                         +-----------+
	                         |script file|
	                         +-----^-----+
	                               |
	 +-----------+ fork +----------|---------+   fork     +-----------+
	 |login shell+------>  script process    +------------>   shell   |
	 +-----------+ exec +----/-----^---\---^-+   exec     +---|----^--+
	  (sleeping)            /     /     \   \          stdout |    |stdin
	                       /     /       |   \         stderr |    |
	             +......../...../........|...|................|....|.........+
	             .   +---v-----/-----+   |   |           +----v----|-----+   .
	             .   |    terminal   |   |   |           |    terminal   |   .
	             .   |line discipline|   |   |           |line discipline|   .
	             .   +---|-----^-----+   \    \          +----|----^-----+   .
	             .       |     |          \    \              |    |         .
	             .   +---v-----|-----+   +-v----\---+       +-v----|--+      .kernel
	             .   |    terminal   |   |   PTY    |       |   PTY   |      .
	             .   | device driver |   |  master  |       |  slave  |      .
	             .   +------^--------+   +-|----^---+       +-|----^--+      .
	             .          |              |    |             v    |         .
	             .          |              v    +<------------+    |         .
	             .          |              +---------------------->+         .
	             +..........|................................................+
	                        v
	                    - - - - --
	                   / user at a\
	                   \ terminal /
	                    - - - - --
	
	当script运行的时候，任何经过PTY slave上面的终端行规则的输出都会被拷贝到script file(一个script的文件)中去(一般被称作typescript)。因为我们的键盘键入一般通过那个行规则模块来显示，所以script file也会包含我们的输入。然而由于密码不会被显示出来，所以script file不会包含我们输入的任何密码。
	当写这本书的第一个版本的时候，作者Rich Stevens使用script程序来捕获例子程序的输出。这个避免了相比较他自己手动来拷贝这些程序的输出，导致的印刷上面可能遇到的错误。然而，script程序的缺点就是，需要处理出现在script file中的控制字符。
	在后面写的pty程序的时候，我们将会看到一个简单的shell脚本将这个程序变成一个script程序。
	
	expect 程序
	伪终端可以用来以非交互的模式来运行交互的程序。大量的程序需要一个终端来运行。有一个例子就是passwd命令，这个程序需要用户键入一个密码来相应提示符号。
	除了可以修改所有的交互程序，让它们本身可以支持批量处理模式的操作，一个更好的解决方法就是，提供一个方式，可以让所有的交互程序能够从一个脚本中运行。expect程序就提供了这样的功能。它使用伪终端来运行其他的程序，这和我们后面讲述的pty程序类似，但是expect可以提供一种程序语言来检查运行的应用程序的输出，然后确定再将给应用程序发送什么作为应用程序的输入。当一个交互的程序从一个脚本中运行的时候，我们无法从脚本中只拷贝所有内容到应用程序，以及反之。所以，我们需要给应用程序发送一些输入，查看它的输出，然后决定之后给应用程序发送什么。
	
	运行协作处理进程
	在前面协作处理进程(协作处理进程参见前面，简之即被协作者输入给协作者，协作者处理之后再送回给被协作者)的例子中，我们无法启动一个使用标准输入输出库作为输入输出的协作处理程序，因为当我们通过一个管道和协作处理程序交互的时候，标准输入输出库是将标准输入输出设成满缓冲形式的，这样会导致死锁。如果我们没有那个编译好了的协作处理程序的源代码，那么我们无法使用fflush来解决这个问题。15章第4节中"通过写它的标准输入以及读取它的标准输出来运行写作处理程序"这个图，展示的就是一个进程来驱动协作处理程序。我们需要做的只是将一个伪终端放置在两个进程之间。这样使得协作处理程序以为，它运行在一个终端上面，而不是另外一个进程驱动它运行。如下图所示。
	
	                     使用伪终端来驱动一个协作处理进程
	
	                                                            coprocess
	      +-----------+  pipe1    +-------------+            +-------------+
	      |  driving  |---------->|   pseudo    |----------->| stdin       |
	      |  program  |<----------|  terminal   |<-----------| stdout      |
	      +-----------+  pipe2    +-------------+            +-------------+
	
	现在协作处理进程的标准输入和标准输出看起来就像是一个终端设备，所以标准输入输出库会设置这两个流为行缓冲的方式。
	
	父进程可以以两种方式获得在它本身和协作处理进程之间的伪终端。(这里父进程可以是前面使用两个管道和协作处理进程通信的程序，也可以是使用一个单一的STREAMS管道的程序)。一个方法就是，父进程直接调用pty_fork函数（后面有这个函数相关的内容）而不是调用fork。另一个方法就是使用exec执行pty程序（后面有这个程序的实现），并且将协作处理进程作为它的参数。我们将在介绍完了pty程序之后，看看这两个解决的方法。
	
	查看长时间运行的程序的输出
	如果我们有一个程序，那个程序运行很长的时间，我们可以在任何一种标准的shell下面将这个程序简单地放到后台运行。但是，如果我们将这个程序的标准输出重新定向到一个文件中的时候，或者它并不产生许多输出的时候，我们无法方便地检测这个进程，因为标准输入输出库对它的标准输出设置成为了满缓存(标准输出被重新定向成了一个文件，而根据前面，一个文件被标准输入输出库读写的时候会被首先设置成满缓冲的形式)。 我们所能够看到的只是标准输入输出库将成块的输出写到文件中去，可能每块数据的大小达到8,192字节。
	如果我们有源代码，我们可以插入fflush调用。另外，我们可以通过pty程序运行这个程序，这样让标准输入输出库以为它的标准输出是一个终端（这样就不会成为满缓冲了）。下面的图形就展示了这个结构，我们将它称为慢输出程序。fork/exec箭头从login shell指向pty进程，箭头是虚线的，用来强调pty进程运行在后台作业当中。
	
	                          通过伪终端运行慢输出程序
	
	                               +-------------+
	                               | output file |
	                               +------^------+
	                                      |
	        +----------+           +------|------+           +----------+
	        |  login   |  fork     |     pty     |   fork    | slow out |
	        |  shell   |- - - - - ->   process   |---------->|          |
	        +--|----^--+  exec     +--|-----^----+   exec    +--|-----^-+
	           |    |                 |     |             stdout|     |stdin
	           |    |                 |     |             stderr|     |
	   +- - - -|- - |- - - - - - - - -|- - -|- - - - - - - - - -|- - -|- - - -+
	   |   +---v----|------+          |     |              +----v-----|----+  |
	       |   terminal    |          |     |              |   terminal    |
	   |   |line discipline|          |     |              |line discipline|  |
	       +---|----^------+          |     |              +----|-----^----+
	   |       |    |                 |     |                   |     |       |
	           |    |                 |     |                   |     |         kernel
	   |   +---v----|------+       +--v-----|----+           +--v-----|--+    |
	       |   terminal    |       |    PTY      |           |   PTY     |
	   |   | device driver |       |   master    |           |   slave   |    |
	       +------^--------+       +--|-----^----+           +--|-----^--+
	   |          |                   |     |                   v     |       |
	              |                   v     +<------------------+     |
	   |          |                   +------------------------------>+       |
	   + - - - - -|- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
	              v
	         /---------\
	        | user at a |
	        |  terminal |
	         \---------/
	
参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch19lev1sec2.html



