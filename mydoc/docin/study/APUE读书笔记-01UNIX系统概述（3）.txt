++++++APUE读书笔记-01UNIX系统概述（3）++++++



7、用户标识
================================================
（1）用户ID
	前面所述的密码文件中的登录项中的用户ID（user ID）是个数值，用于向系统标识各个不同的用户。通常每个用户有一个唯一的用户ID，不同用户对系统具有不同的权限（例如可以访问哪些文件，执行什么程序等）。用户ID为0的用户为根(root )或超级用户(superuser)。在密码文件中，其登录名为root，我们称这种用户的特权为超级用户特权，它具有整个系统无上的管理权限。^_^

（2）组ID
	密码文件中的登录项也包括用户的组ID（group ID），它也是一个数值。一般来说，在密码文件中有多个记录项具有相同的组ID。在UNIX下，组被用于将若干用户集合到某一共同的课题或部门中去。这种机制允许同组的各个成员之间共享资源(例如文件)。4.5节将讲述到，可以设置文件的许可权使组内所有成员都能存取该文件，而组外用户则不能。
	组文件将组名映射为数字组ID，它通常是/etc/group。对于用户而言，使用名字比使用数值方便，所以密码文件包含了登录名和用户ID之间的映射关系，而组文件则包含了组名和组ID之间的映射关系。另外，除了在密码文件中对一个登录名指定一个组ID外，某些UNIX版本还允许一个用户属于另外一些组。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec8.html


8、信号
================================================
	信号是通知进程发生某种条件的一种技术。例如，若某一进程执行除法操作，其除数为0，则将名为SIGFPE的信号发送给该进程。进程有三种选择处理信号：
	(a) 忽略该信号。有些信号表示硬件异常，例如，除以0或访问进程地址空间以外的单元等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。
	(b) 按系统默认方式处理。对于0除，系统默认方式是终止该进程。其它信号有不同的默认行为。
	(c) 提供一个处理函数，信号发生时则调用该函数。使用这种方式，我们将能知道什么时候产生了信号，并按所希望的方式处理它。
	通过系统的用户手册，我们可以了解具体有哪些信号，以及它们的编号（例如我在Linux上运行"man 7 signal"将显示当前Linux支持的信号信息）。我们可以使用kill函数，产生特定的信号，发送给指定的进程（当然我们必需是该进程的所有者）；也可以通过键盘的方式，敲入特殊按键，产生信号。例如，我们运行ls程序之后，立即键入"[Ctrl]+C"，这样会导致"ls"运行完成之前中止，因为"[Ctrl]+C"的意思就是给当前终端上运行的程序发送终止信号（这里我给出的例子其实不太好，ls命令执行的比较快，如果目录中文件不多的话，这里需要你键入的速度足够快才能看到效果，否则没等你键入，ls就执行完了，就看不到效果了^_^）。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec9.html


9、关于进程时间
================================================
	为了衡量一个进程的执行时间，unix使用三个值：
	（a）Clock time
	运行这个进程所花费的时间，这个时间还依赖于系统上执行的其他进程的数量。一般我们假设系统上没有其他进程运行。
	（b）User CPU time
	运行这个进程所花费的用户cpu时间。也就是执行用户（和内核相对）指令所花费的时间。
	（c）System CPU time
	运行这个进程所花费的系统（内核）cpu时间。也就是进程在核心态下所消耗的时间，例如调用系统调用。
	用户cpu时间和系统cpu时间统称进程的cpu时间。进程时间可以使用clock tick来衡量，例如一秒钟50个clock tick.测量一个程序的占用时间可以使用time命令。
	这里，再次总结一下，Clock time应该是我们看到的程序运行到结束的总时间，包括实际运行时间，以及由于调度产生的等待时间；而User+System为cpu时间，也就是除了进程调度和等待等因素后，纯粹的执行时间，也就是占用cpu的时间；user表示在用户空间占用的cpu时间，system表示在内核空间占用的cpu时间例如系统调用（一般来说，一次系统调用的时间开销，要比用户空间的一次调用开销大）。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec10.html


10、关于系统调用和库函数
================================================
	对于系统调用和库函数的关系，前面大致介绍过，这里再次对此进行说明。
	（a）系统调用是用户和内核交互的接口，用来请求内核提供相应服务。
	原来的系统调用接口是用汇编声明，现在用c语言函数方式声明了，其具体的实现方式就不一定是什么了。这样使得用户只需要像用c语言函数一样地，通过包含其声明的头文件，使用系统调用就行了，而不用关心其内部是怎么实现的。
	（b）c语言的库函数是用c语言实现的，它一般是需要调用系统调用来实现的。
	系统调用一般和一些c语言的库函数名称一样，用户可以像使用库函数一样使用系统调用，但是两者不同，可以自己定义库函数来取代原来的库函数，而系统调用是无法取代的。例如malloc库函数就是用sbrk系统调用实现的。system库函数就是用fork和exec系统调用实现的。
	（c）系统调用接口简洁，并且提供了所有的功能，但是不如库函数友好。而库函数可以简单理解成是对系统调用的“封装”。
	注意，一般man手册里面，其第2节的内容是系统调用，第3节的内容是库函数（这一点在前面的预备知识中已经提到过）。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec11.html


总结
================================================
	本章简单对UNIX系统进行了一下概要说明。我们对一些我们将要遇到的基本的术语进行了解释，后面将会经常提到并且进一步解释它们。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch01lev1sec12.html



