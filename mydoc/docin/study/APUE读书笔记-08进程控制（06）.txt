++++++APUE读书笔记-08进程控制（06）++++++



7、waitid
================================================
	Single UNIX Specification 的XSI extension包含了一个额外的函数用来取回进程的退出状态。waitid函数和waitpid类似但是更为灵活。
	#include <sys/wait.h>
	int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
	类似waitpid，waitid允许进程指定等待那个子进程。但是waitid不是把指定的信息（例如子进程id，id组）都集中到一个参数里而是利用两个参数来进行指定。参数id的解释方式取决于idtype的值。如下列出了idtype各种取值时候id的解释方式：
	P_PID	idtype取这个值的时候，id表示等待一个指定的子进程id。
	P_PGID	idtype取这个值的时候,表示等待任何在指定进程组的子进程，而id就包含了要等待的子进程的进程组id。
	P_ALL	idtype取这个值的时候，表示等待任何子进程，此时id参数被忽略。

	options参数是一些标志的比特位，表示调用者关心哪些状态的变化。如下所示：
	WCONTINUED	表示等待一个进程，这个进程之前被stopped了并且被continued了，并且它的status没有被报告。
	WEXITED	表示等待已经exited的进程。
	WNOHANG	表示如果没有可用的子进程退出状态，那么就立即返回而不是阻塞。
	WNOWAIT	表示不会破坏子进程的退出状态码。子进程的退出状态可以在后来的wait,waitid,或者waitpid调用中取到.
	WSTOPPED	表示等待一个被stopped的子进程，这个子进程的状态没有被报告。

	参数infop是个结构指针。这个结构包含导致子进程变化的发生的信号的详细信息，后面会讨论这个结构。
	在本书讨论的四个系统中，只有solaris支持这个waitid。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch08lev1sec7.html


8、wait3和wait4函数
================================================
	大多数unix系统的实现提供了wait3和wait4函数，这两个函数本来是从Unix中的BSD分支中继承过来的。这两个函数提供的wait,waitid,waitpid所没有的特性是它多了一个额外的参数允许内核返回结束进程和它所有的子进程所消耗的资源统计。
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <sys/time.h>
	#include <sys/resource.h>
	pid_t wait3(int *statloc, int options, struct rusage *rusage);
	pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);
	所谓资源信息，包含了诸如用户CPU时间数量的统计，系统CPU时间数量的统计，接受的信号数量，页相关的统计信息等等。可以参照geTRusage的man手册来获取更多的信息。

	下面是5个wait函数的参数对比情况：
+---------------------------------------------------------------------------------------------------------+
| Function | pid | options | rusage | POSIX.1 | Free BSD 5.2.1  | Linux 2.4.22 | Mac OSX 10.3 | Solaris 9 |
|----------+-----+---------+--------+---------+-----------------+--------------+--------------+-----------|
| wait     |     |         |        |    •    |        •        |      •       |      •       |     •     |
|----------+-----+---------+--------+---------+-----------------+--------------+--------------+-----------|
| waitid   |  •  |    •    |        |   XSI   |                 |              |              |     •     |
|----------+-----+---------+--------+---------+-----------------+--------------+--------------+-----------|
| waitpid  |  •  |    •    |        |    •    |        •        |      •       |      •       |     •     |
|----------+-----+---------+--------+---------+-----------------+--------------+--------------+-----------|
| wait3    |     |    •    |   •    |         |        •        |      •       |      •       |     •     |
|----------+-----+---------+--------+---------+-----------------+--------------+--------------+-----------|
| wait4    |  •  |    •    |   •    |         |        •        |      •       |      •       |     •     |
+---------------------------------------------------------------------------------------------------------+

	wait3函数是在早期的Single UNIX Specification版本中包含的，在第2个版本中wait3就被归类为遗留类的函数了在版本3中wait3就被去掉了。

参考：
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch08lev1sec8.html


9、竞争条件
================================================
	在多个进程访问共享资源的时候可能会导致竞争（例如多个进程都向标准输出输出内容）,fork的时候很可能导致竞争条件。fork之后产生竞争条件，其结果和父子进程执行的次序有很大的关系。我们无法预测是父进程还是子进程先运行，这取决于系统的负载和内核的调度算法。实际前面的例子中已经存在了竞争条件.实际上我们用sleep等待来实现子进程比父进程后运行，这样是无法保证一定这样的，如果系统负载很高的话，即使我们sleep了很长时间，也有可能最后sleep的进程比没有sleep的进程先调用。可以用类似如下的轮询方式:
	while (getppid() != 1)
		sleep(1);
	但是这也浪费cpu的时间为了避免竞争条件和轮询，我们可以使用信号机制，后面会讲到。另外有许多的进程通信机制也提供了一些手段后面也会讲到。具体例子这里不说了，可以参照给出的参考网址。

参考:
http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch08lev1sec9.html



