一、要做的事情：
使用pc模拟systemblock。

情况是这样的：
摄像机上面有一个systemblock硬件模块，可以控制媒体播放。（例如播放按钮，停止按钮，开始按钮，等等）
但是开发的时候，没有那个systemblock硬件，我们就只能decksim模拟systemblock模块，然后让它通过串口发送一系列字符串，然后sc2p代码部分负责分析处理这些字符串，然后达到模拟的目的。
现在又变化了，我们不用decksim通过串口通信的方法来模拟了，我们要自己写一个网络程序，在pc上面通过网线，来模拟相应的功能。
综上，我们的目的就是写一对网络通信程序，一个在pc上面运行，一个在开发板上面运行，然后pc机器上的程序（类似客户端）完成相应的控制模拟操作。

后来经过一次会议发现,原来pc端和板子端的网络程序应该由IA他们编写并且提供,我们需要做的就是:
1)把原来decksim发过来的指令和流程弄懂
2)把他们编写的网络程序发送过来的指令和流程弄懂
3)将他们的网络程序的指令和流程映射成decksim的指令流程
4)得确定在哪里对上述内容进行映射,还要看映射好的decksim指令怎样发送到"原有流程"中.
5)上面提到的"原有流程"就是原先发送过来的decksim指令是如何发送过去的,到此为止,具体怎么处理指令我们就不用管了.


二、计划：
1）要先会用decksim并看懂相应decksim发送字符串的地方。它究竟发送了什么字符串来实现各种控制命令。
2）要看看sc2p代码中是如何接收处理这些发送的字符串的。
3）编写pc端网络程序通过网线向开发板发送相应字符串。
可以考虑先编写一个可以互相收发字符串的程序（最好先了解一下守护进程和socket编程的概念）.
4）在开发板上面编写网络程序，接收pc端发送过来的信息。
5）开发板上的网络程序将从pc上面接收的字符串再发给sc2p，完成decksim的模拟。

三、如何开始：
1）搞清楚decksim使用时候，测试时候，常用的一些命令，以及这些命令的含义以及操作的顺序。

2）弄清使用decksim进行常用的测试的命令和操作次序之后，察看decksim代码，弄清楚每个操作过程相应的decksim发送给终端的字符串是什么。

3）将最终要发送的字符串通过网络程序相互发送。

四、需要理解的一些知识：
关于Clip：
刚开始格式化好了一个卡，然后录制的时候，会在卡上自动生成TAKE,CLIP,以及其他的文件来存放录制的数据以及相应的配置。
录制的时候，一次录制叫做一个take,如果take很大的话，可能就会被分成多个clip，这些都由前面生成的目录来进行相应的管理。我们能够在文件系统中看到每个实实在在的clip的，每个clip应该就是一个独立的文件。

当前decksim中的一些命令：
具体察看相关的手册(Scenario实行工具 使用指南.pdf)。

这里列出一些看似重要的命令部分。
~浏览至50页。
启动系统之后，运行diablo.bin程序，然后启动decksim之后进入"待机"模式。这时候，可以选择的有如下模式：(rec,ply,mass,mnt,cfg or exit,shutdown)

1)关于播放模式：
*进入播放模式:
输入 "ply"
进入播放模式之后，会弹出一个popup对话框，可以按照这个popup对话框，进行各种控制。popup对话框本身已经显示了当前状态的许多信息，可以参考文档的内容。

*显示帮助信息: 
输入"help"

*退出播放模式:
输入"exit"

**常用播放模式命令如下:
*自行选择活动的槽:
输入"slot"
这里，实际已经提供了一个slot的默认值，这些默认值得配置存放在某个decksim脚本里，可以通过代码看到.如果非要自己指定一个slot那么就用这个命令吧,输入之后按照弹出的对话框的提示进行进一步操作。

*对所选的slot内容显示它们的缩略图:
输入"thumb"

*指定要播放的位置：
输入"position"
输入之后，根据popup出来的对话框来输入要播放的clip以及具体位置。

*指定播放的速度：
输入"speed"
输入这个命令，可以指定将要播放的内容的速度（例如快进，慢进，常速，暂停等等）

*开始对单一的Clip进行播放：
输入"splay"
这里，在设置了各种播放的参数之后，可以运行这个命令，对单个clip进行播放了。这个时候实际就进入了播放的状态，同时还存在着一个弹出的对话框，用户可以向这个对话框输入其他的命令，进行各种控制,这个弹出对话框中还显示着当前的状态（PLY表示处于播放状态）。

*对多个Clip进行播放：
输入"pplay"
这里的过程和splay类似。还有许多其它的播放命令例如"dplay"等等，这里不再细说，具体察看参考文档。

*暂停播放：
输入"pauseon"
这个命令在splay之后正在播放的时候就能执行。

*解除暂停播放：
输入"pauseoff"

*停止播放：
输入"stop"

??????record命令为什么出现在了ply模式中?
cformat???
amode
**

2)关于录画模式：
这里，发现，录画时候，如果想要录画指定的格式可以先在板子上面用那个小按钮调好（比如imagesize为1080,祯率为29即30等），然后调用相应的脚本进行录画。
*进入录画模式：
输入"rec"

*察看帮助:
输入"help"

*退出录画模式:
输入"exit"

**常用播放模式命令如下:
*选择slot:
输入"slot"
出现slot选择对话框的时候，输入这个命令可以选择slot,如果不选择那么使用它默认的值。

*选择录画模式：
输入"mode"
这会弹出相应的选择对话框,输入help可以看到相应的提示,如果选择好了variable录画模式,会继续让你选择frame频(不太明白都有什么录画模式,究竟选择哪个录画模式??????)

*开始录画:
输入"record"
这样,会向刚才选择的slot中存放录画的内容,录画的期间可以根据对话框进行其他的操作.

*停止录画:
输入"stop"
这样,会停止录画.

*指定屏幕画面大小:
输入"imgsize"
这样,会提示让你选择制定的屏幕大小,可以使用"help"来看具体的参数含义.

*设置祯频:
输入"frate"
可以查看"help"了解相关的值.(祯频是什么意思??????)

*设置位率:
输入"brate"
可以查看"help"了解相关的值.(位率是什么意思??????)

*指定录画的格式:
输入"cformat"
究竟有什么格式,可以在弹出的对话框中输入"help"来进行察看.

*指定录画时候的audio格式：
输入"amode"

*设置录画缓存有效：
输入"cacheon"

*设置录画缓存无效：
输入"cacheoff"
**

3)mass模式:
*进入mass模式:
输入"mass"
具体什么是mass模式??????

*察看帮助:
输入"help"

*退出mass模式:
输入"exit"

4)maintenance模式:
*进入maintenance模式:
输入"mnt"

*显示帮助:
输入"help".

*退出当前模式:
输入"exit"

**进入maintenance模式之后,有如下的命令:
*选择slot:
输入"slot"

*格式化:
输入"format"
这样会按照指定的slot以及format方法对媒体进行初始化.(??????)

**


五、计划实现的接口：
设计的pc端的用户操作程序应该具有什么样的功能？(这个设计应该我们不是我们作的了)
先将操作的接口规定好了，然后再对接口进行实现。
但是规定操作接口之前需要知道有什么接口可以规定，所以要明白decksim相应的操作，甚至会阅读decksim的代码。


六、阅读decksim脚本的所获得的信息：
1,首先decksim脚本要确定输入的模式以及相应的输入文件，

2,然后给终端依如下序列发送字符(subSc2pSimStart调用):
sendln "sc2psim"
wait #10'>' #10'->'
sendln "print"
wait #10'>' #10'->'
这里，可以通过查阅ttl的语法手册确定语句的含义。

3,然后初始化启动(依次如下给终端发送字符,以及相应接收字符,参考:'.\Sub\SystemStart.ttl')：
sendln '# mediaSyLogTimeSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '13 00 9F F5 45 08 13 01 0A 00 00 00'  ;这里的数字经过非常复杂的处理，从代码注释看是这个，我还不确定是否与时间等因素有关。
wait #10'>' #10'->'
sendln '# ;'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaSyOutputLevelSet'
wait #10'>' #10'->'
sendln '# packet'
wait #10'>' #10'->'
sendln '# 0F 00 0F 00 00 00 00 80'
wait #10'>' #10'->'
sendln '# ;'
wait #10'>' #10'->'
sendln '# run' ;(不是run吗？)
wait #10'>' #10'->'

sendln '# mediaFrValidFrameTimingSet'
wait #10'>' #10'->'
sendln '# packet'
wait #10'>' #10'->'
sendln '# 91 01 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '# ;'
wait #10'>' #10'->'
sendln '# run'
wait #10'>' #10'->'

sendln '# mediaSyLocaleSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '12 00 'localeModeParam ;???????这个localeModeParam是什么？localeModeParam = '01000000' 在DefaultSet.ttl中
wait #10'>' #10'->'
sendln  ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

4,模式相关(参考'.\Sub\DeckIdle.ttl')：
sendln '# mediaDkDeckModeSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '2D 01 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框


5,经过前面的步骤之后，开始进入和用户交互输入的地方。
通过文件或者用户对话框的输入，循环获取相应的输入命令.
从这开始，用户的输入将会决定不同的行为这里先尝试看看能否分别把play和record的常用命令序列解析出来：
5.1)play:
5.1.1)用户输入的命令序列假设为：
ply
position
1
1
0f
splay
wait 1000

这将调用subPlayMain.(102行)
然后会依次给终端如下序列发送信息：
a)初始化（'.\Sub\PlayInit.ttl'）：
sendln '# mediaSyVideoFilterSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '1E 00 'videoFilterFlagParam ;拼接videoFilterFlagParam    = '00000000'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaDkDeckModeSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '2D 01 00 00 00 00 03 00 00 00'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaDkDeckStatusGet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '2E 01 00 00 00 00'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaDkRecordingPropertySet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '2F 01 00 00 00 00 00 00 00 00 00 00 00 00 3C 00'
wait #10'>' #10'->'
sendln '00 00 0A 00 00 00 'keyFrameOffsetParam ;字符串拼接，keyFrameOffsetParam     = 'FFFFFFFF' 
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaDkEncodeModeSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '32 01 00 00 00 00 03000000 02000000 02000000 02000000' ;各种拼接
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaMdMediaStatusGet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '6F 00 01 00 00 00' ;拼接了slotNo,slotNo='01'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

'# mediaDkDeviceInfoSet'
'packet'
'41 01'
'00 00 00 00' 
'08 00 00 00'
'01 00 00 00' 
'01 00 00 00' 
'00 00 00 00' 
'00 00 00 00'
'00 00 00 00' 
'00 00 00 00'
'00 00 00 00' 
'00 00 00 00' 
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
wait #10'>' #10'->'
sendln '00 00'
wait #10'>' #10'->'
sendln '74 65 73 74 00 80 C0 00 B8 80 74 E0 28 80 C0 60'
wait #10'>' #10'->'
sendln 'B8 80 C4 7B B7 80 C0 00 B8 80 40 33 BB 80'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框
;至268行

sendln '# mediaDkClipFormatSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '34 01 00 00 00 00 '
wait #10'>' #10'->'
sendln clipFormatParam  ;clipFormatParam = '00000000'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框


sendln '# mediaDkAudioModeSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '44 01 00 00 00 00 '
wait #10'>' #10'->'
sendln audioTypeParam ;audioTypeParam = '00000000'
wait #10'>' #10'->'
sendln audioChNumberParam ;audioChNumberParam      = '02000000'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendn 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

sendln '# mediaDkAudioFaderEnable'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '4D 01 00 00 00 00 01000000 00000000';字符串拼接clipFadeFlagParam       = '01000000'	chapterFadeFlagParam    = '00000000'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

;if slotNo!='00'
sendln '# mediaDkActiveSlotSet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln '30 01 00 00 00 00'
wait #10'>' #10'->'
sendln slotNo ;slotNo='01'
wait #10'>' #10'->'
sendln '00 00 00'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>'
然后对读取得行进行检查，获得api的返回信息是否正常，如果正常则从返回的行中获取状态等处理，不正常则弹出提示框

b)获取关于thumbnail相关的信息('.\Sub\ThItmListGet.ttl')
;if slotNo!='00'
;setsync方式进行以下步骤
sendln '# mediaCpClipThumbnailItemListGet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln 'C9 00 01 00 00 0000000000 01000000 00000000 00000000 00000000 00000000' ;slotNo='01',searchKeyTypeParam='00000000' sortOrderParam='01000000' formatSearchKeyTypeParam='00000000' localeLimitedParam='00000000' resolutionSearchKeyParam='00000000' fpsSearchKeyParam='00000000'
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
然后循环从终端输出中读取每一行，直到该行包含'API Result>C9 0C'
然后设置输入为该行。
然后通过对该行进行读取，获得各种关于thumbnail的相关信息。

c)处理显示thumbnail相关的各种信息('.\Sub\ThumbnailDisplay.ttl')
;thumbnailItemListCount > 0
sendln '# mediaCpThumbnailItemsPropertyGet'
wait #10'>' #10'->'
sendln 'packet'
wait #10'>' #10'->'
sendln 'CB 00 ' thumbnailItemListIDParam ' 00 00 00 ' startClip thumbnailItemListIDParam ' ' endClip thumbnailItemListIDParam ;各种字符串拼接，这里thumbnail相关的字符串变量都是从上面的获取thumbnail相关信息里面的道的，
wait #10'>' #10'->'
sendln ';'
wait #10'>' #10'->'
sendln 'run'
之后循环根据一个thumbnail参数运行一个脚本，进行过程比较复杂。
后面的处理过程都很类似并且非常的麻烦，想要提取其中的字符串，似乎很多，先跟踪到这里，开始看脚本，具体如何处理什么字符串看以后有必要再整理吧。
至此，ply部分的初始化过程大概完成。剩下的每个命令相应的处理序列，请参照相应的脚本。






