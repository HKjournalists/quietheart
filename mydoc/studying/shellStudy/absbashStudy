=======abs复习
说明：越上面，越新。只记录自我感觉比较新的东西。
参考：http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/sha-bang.html
#20110825
*在脚本或者是脚本函数中执行的最后的命令会决定退出状态码. 在脚本中, exit nnn命令将会把 nnn退出码传递给shell( nnn必须是十进制数, 范围必须是0 - 255). 当脚本以不带参数的exit命令来结束时, 脚本的退出状态码就由脚本中最后执行的命令来决定(就是exit之前的命令).0表示成功, 在范围1 - 255的整数表示错误.

*在if后面也不一定非得是test命令或者是用于条件判断的中括号结构( [ ] 或 [[ ]] ).与此相似, 在中括号中的条件判断也不一定非得要if不可。

*算术测试需要使用(( )),退出状态将会与[ ... ]结构完全相反!例：
(( 0 ))
echo "Exit status of \"(( 0 ))\" is $?."         # 1，而[ 0 ]返回$?=0，下面类似.
(( 1 ))
echo "Exit status of \"(( 1 ))\" is $?."         # 0
(( 5 > 4 ))                                      # 真
echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0

if [ 0 ]      # zero
then
  echo "0 is true."
else
  echo "0 is false."
fi            # 0 为真.

参考：http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/fto.html


#20110823
$0就是脚本文件自身的名字, $1 是第一个参数, $2是第二个参数, $3是第三个参数, 然后是第四个. [1] $9之后的位置参数就必须用大括号括起来了, 比如, ${10}, ${11}, ${12}.

shift命令会重新分配位置参数, 其实就是把所有的位置参数都向左移动一个位置.
$1 <--- $2, $2 <--- $3, $3 <--- $4, 等等.原来的$1就消失了, 但是$0 (脚本名)是不会改变的. 
http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/escapingsection.html

#20110822
~+
当前工作目录. 相当于$PWD内部变量. 

~-
先前的工作目录. 相当于$OLDPWD内部变量. 
至http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/special-chars.html

#20110819
*"[[ ]]":这是比"[]"扩展的条件测试符号。
*"(())":与let命令很相似, ((...))结构允许算术扩展和赋值. 举个简单的例子, a=$(( 5 + 3 ))。双圆括号结构也被认为是在Bash中使用C语言风格变量操作的一种处理机制. 
例如：
(( a = 23 ))
(( a++ ))
(( a-- )) 
(( t = a<45?7:11 ))#三目

*重定向
&> >&  <>
command &>filename 重定向command的stdout和stderr到filename中.
command >&2 重定向command的stdout到stderr中.

[i]<>filename 打开文件filename用来读写, 并且分配文件描述符i给这个文件. 如果filename不存在, 这个文件将会被创建. 
举例：
$touch tempfile
$5<>tempfile echo 1111 >&5 
注意方向不能错，如：$echo 1111 >&5 5<>tempfile是错误的。
或者：
$exec 5<>tempfile
$echo 1111 >&5 
exec相当于单独执行，之后/dev/fd/里面会有5这个描述符号。
之后我们会发现，文件tempfile里面有1111这样的内容了。
关闭描述符号：
$exec >&5-

注意如果使用"exec 1<>tempfile"，那么之后所有的命令的标准输出就都没有了，都跑到了tempfile里面。

#20110818
*"()"的作用:
a)命令组.在括号中的命令列表, 将会作为一个子shell来运行.
b)数组。例如：Array=(element1 element2 element3)



*{xxx,yyy,zzz,...}
大括号的扩展，例如：
"{t1,t2}"相当于"t1 t2"，所以"cp {t1,t2}"相当于"cp t1 t2"。
"t{1,2}"相当于"t1 t2"，所以"cp t{1,2}"相当于"cp t1 t2"。
"{a,b}{1,2}"相当于"a1 a2 b1 b2"，所以"echo {a,b}{1,2}"相当于"echo a1 a2 b1 b2"。

*{}
大括号表示代码块。事实上创建了一个匿名函数，不同的是在其中声明的变量,对于脚本其他部分的代码来说还是可见的。
可以用来进行输入输出重定向例如：
{
	...
}>file1
会把代码块中的所有输出都重定向到文件file1中.
http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/special-chars.html


#20110817
*以'#!'开头的将会做为魔术数，并且使用'#!'后面的程序来解释当前脚本。
一个技巧是，文件前面内容为"#!/usr/bin/less"这样，当运行这个文件的时候，会相当与执行了"less <文件名>"
*编写完脚本之后,可以使用"sh scriptname",或者"bash scriptname"来调用这个脚本. (不推荐使用sh <scriptname, 因为这禁用了脚本从stdin中读数据的功能. ) 更方便的方法是让脚本本身就具有可执行权限,然后直接运行"./scriptname"来执行脚本。
*空命令[冒号, 即:]. 等价于"NOP" (no op, 一个什么也不干的命令). 有很多作用。
*${parameter}
与$parameter相同, 也就是变量parameter的值. 在某些上下文中, ${parameter}很少会产生混淆.
可以把变量和字符串组合起来使用.例如：your_id=${USER}-on-${HOSTNAME}
还支持一些特殊的语法，例如：
${parameter:-default}表示如果参数没有被设置那么就使用默认值。
http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/special-chars.html







===================2009年的内容
网址：http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/sha-bang.htm
#20090720
一些小技巧:
如果在文件的最开始是：
#!/bin/rm
那么执行该文件会自动把文件删除，并且不可能会执行到文件中的命令了。

#20090721
创建一个新文件和touch等价的方法：
>>newfile
这也会创建一个新文件。
---------
在指定的时间点执行命令用at例如：
at 2pm January 15
将会产生提示, 提示你输入需要在这个时间上需要执行的命令序列.用户每次只能输入一行. 输入将以Ctl-D结束. 
--------------
#20090722
 1 echo "A comment will follow." # 注释在这里.
  2 #                                      ^ 注意#前边的空

如果注释'#'在行的中间，必须前面有一个空格，如：
echo 'good' #这个注释'#'前面的空白是必须的。
----------


 1 echo hello; echo there
  2 
  3 
  4 if [ -x "$filename" ]; then    # 注意: "if"和"then"需要分隔. 
  5                                # 为什么?
  6   echo "File $filename exists."; cp $filename $filename.bak
  7 else
  8   echo "File $filename not found."; touch $filename
  9 fi; echo "File test complete.
----------
空命令[冒号, 即:]. 等价于"NOP" (no op, 一个什么也不干的命令). 也可以被认为与shell的内建命令true作用相同. ":"命令是一个bash的内建命令, 它的退出码(exit status)是"true"(0). 

:命令可以后面连接多个任意参数，例如"$ : adsdf arg2"，也返回true.
"${var=test}"这个语法的含义是如果之前没有var变量的定义就设置var变量的默认值，并返回设置的值；如果以前有var定义，那么这句话就不会设置var并且将var原来的值返回。

---------
双圆括号结构也被认为是在Bash中使用C语言风格变量操作的一种处理机制.
---------
在括号中的命令列表, 将会作为一个子shell来运行

----------
代码块[大括号, 即{}]. 又被称为内部组, 这个结构事实上创建了一个匿名函数(一个没有名字的函数). 然而, 与"标准"函数不同的是, 在其中声明的变量,对于脚本其他部分的代码来说还是可见的. 

#####20090723
for i in 1 2 3 4 5 6 7 8 9 10            # 第一个循环.
do
   echo -n "$i "#这个命令在一行打印1-10，如果没有-n那么打印10行。
done & 
####20090724
export命令将会使得被export的变量在所运行脚本(或shell)的所有子进程中都可用. 不幸的是, 没有办法将变量export到父进程中, 这里所指的父进程就是调用这个脚本的脚本或shell. 
------
双引号被称为部分引用, 有时候又被称为"弱引用"单引号被称为全引用, 有时候也被称为"强引用".
$variable事实上只是${variable}的简写形式. 在某些上下文中$variable可能会引起错误, 这时候你就需要用${variable}了

#####20090727
=既可以用做条件测试操作, 也可以用于赋值操作, 这需要视具体的上下文而定. 

------
不像其他程序语言一样, Bash并不对变量区分"类型". 本质上, Bash变量都是字符串. 但是依赖于具体的上下文, Bash也允许比较操作和整数操作. 其中的关键因素就是, 变量中的值是否只有数字. 

------
一个脚本只能够export变量到这个脚本所产生的子进程, 也就是说只能够对这个脚本所产生的命令和进程起作用. 如果脚本是从命令行中调用的, 那么这个脚本所export的变量是不能影响命令行环境的. 也就是说, 子进程是不能够export变量来影响产生自己的父进程的环境的. 

------
$0就是脚本文件自身的名字, $1 是第一个参数, $2是第二个参数, $3是第三个参数, 然后是第四个. [1]   $9之后的位置参数就必须用大括号括起来了, 比如, ${10}, ${11}, ${12}. 

######20090728

shift命令会重新分配位置参数, 其实就是把所有的位置参数都向左移动一个位置.
$1 <--- $2, $2 <--- $3, $3 <--- $4, 等等.原来的$1就消失了, 但是$0 (脚本名)是不会改变的. 如果传递了大量的位置参数到脚本中, 那么shift命令允许你访问的位置参数的数量超过10个, 当然{}标记法也提供了这样的功能. 

------
当在命令行中使用时, 如果在双引号中包含"!"的话, 那么会产生一个错误(译者注: 比如, echo "hello!"). 这是因为感叹号被解释成历史命令了. 但是如果在脚本中, 就不会存在这个问题, 因为在脚本中Bash历史机制是被禁用的. 

######20090730
在脚本中, exit nnn命令将会把 nnn退出码传递给shell( nnn必须是十进制数, 范围必须是0 - 255).当脚本以不带参数的exit命令来结束时, 脚本的退出状态码就由脚本中最后执行的命令来决定(就是exit之前的命令).不带参数的exit命令与 exit $?的效果是一样的, 甚至脚本的结尾不写exit, 也与前两者的效果相同. 

------
$?保存了最后所执行的命令的退出状态码. 当函数返回之后, $?保存函数中最后所执行的命令的退出状态码. 一般情况下, 0表示成功, 在范围1 - 255的整数表示错误,或者是反常的条件.

------
退出码值的含义	例子	注释
1	通用错误	let "var1 = 1/0"	各种各样的错误都可能使用这个退出码, 比如"除0错误"

2	shell内建命令使用错误(Bash文档上有说明)		很少看到, 通常情况下退出码都为1

126	命令调用不能执行		程序或命令的权限是不可执行的

127	"command not found"		估计是$PATH不对, 或者是拼写错误

128	exit的参数错误	exit 3.14159	exit只能以整数作为参数, 范围是0 - 255(见脚注)

128+n	信号"n"的致命错误	kill -9 脚本的$PPID	$? 返回137(128 + 9)

130	用Control-C来结束脚本		Control-C是信号2的致命错误, (130 = 128 + 2, 见上边)

255*	超出范围的退出状态	exit -1	exit命令只能够接受范围是0 - 255的整数作为参数

------
if/then结构用来判断命令列表的退出状态码是否为0(因为在UNIX惯例, 0表示"成功"), 如果成功的话, 那么就执行接下来的一个或多个命令.
有一个专有命令[ (左中括号, 特殊字符). 这个命令与test命令等价, 并且出于效率上的考虑, 这是一个内建命令. 这个命令把它的参数作为比较表达式或者作为文件测试, 并且根据比较的结果来返回一个退出状态码(0 表示真, 1表示假). 

#20090731
如果if和then在条件判断的同一行上的话, 必须使用分号来结束if表达式. if和then都是关键字. 关键字(或者命令)如果作为表达式的开头, 并且如果想在同一行上再写一个新的表达式的话, 那么必须使用分号来结束上一句表达式.

------
1 if [ -x "$filename" ]; then

#20090803
在if判断中，返回值是0代表真，返回值为1代表假。
例如，如果当前目录下面有文件file，那么我运行：
$test -e file
返回0，如果没有这个文件那么会返回1。运行man test可以查看许多test的选项，如-z等。

------
在if后面也不一定非得是test命令或者是用于条件判断的中括号结构( [ ] 或 [[ ]] ). 

#20090804
注意"<"使用在[ ]结构中的时候需要被转义. 

------
-a
逻辑与
exp1 -a exp2 如果表达式exp1和exp2都为真的话, 那么结果为真.

-o
逻辑或
exp1 -o exp2 如果表达式exp1和exp2中至少有一个为真的话, 那么结果为真.
这与Bash中的比较操作符&&和||非常相像, 但是这个两个操作符是用在双中括号结构中的. 
-o和-a操作符一般都是和test命令或者是单中括号结构一起使用的.

#20090805
Bash不能够处理浮点运算. 它会把包含小数点的数字看作字符串. 如果非要做浮点运算的话, 可以在脚本中使用bc, 这个命令可以进行浮点运算, 或者调用数学库函数. 

#20090811 
# 设置脚本的参数, $1, $2, 等等.
set -- "First one" "second" "third:one" "" "Fifth: :one"
set a b c      # 这样也会设置位置参数.

------
把标准错误和标准输出都重定向用 &>

------
$$
    脚本自身的进程ID. $$变量在脚本中经常用来构造"唯一的"临时文件名(参见例子 A-13, 例子 29-6, 例子 12-28, 和例子 11-26). 这么做通常比调用mktemp命令来的简单.

------
$!
    运行在后台的最后一个作业的PID(进程ID)

------
$_
    这个变量保存之前执行的命令的最后一个参数的值. 

#20090813

${parameter}
与$parameter相同, 也就是变量parameter的值. 在某些上下文中, ${parameter}很少会产生混淆. 

#20090818
$RANDOM是Bash的内部函数 (并不是常量), 这个函数将返回一个伪随机  [1]  整数, 范围在0 - 32767之间.可以事先給它设定一个随机种子，同样的随机种子产生的伪随机数列可能就一样了。假设1是随机种子，那么这样：RANDOM=1

#20090824
内建命令指的就是包含在Bash工具包中的命令, 从字面意思上看就是built in. 这主要是考虑到执行效率的问题 -- 内建命令将比外部命令执行的更快, 一部分原因是因为外部命令通常都需要fork出一个单独的进程来执行 -- 另一部分原因是特定的内建命令需要直接访问shell的内核部分. 
一个内建命令通常会与一个系统命令同名, 但是Bash在内部重新实现了这些命令. 比如, Bash的echo命令与/bin/echo就不尽相同, 虽然它们的行为在绝大多数情况下都是一样的. 

--------
read
    从stdin中"读取"一个变量的值, 也就是, 和键盘进行交互, 来取得变量的值. 使用-a参数可以read数组变量
	没有变量分配给'read'命令,输入将分配给默认变量, $REPLY.

	1 # 不敲回车, 读取一个按键字符.
	2 
	3 read -s -n1 -p "Hit a key " keypress
	4 echo; echo "Keypress was "\"$keypress\""."
	5 
	6 # -s 选项意味着不打印输入.
	7 # -n N 选项意味着只接受N个字符的输入.
	8 # -p 选项意味着在读取输入之前打印出后边的提示符.
	9 
	10 # 使用这些选项是有技巧的, 因为你需要用正确的顺序来使用它们.


----------
一个cd命令的bug
当我们使用两个"/"来作为cd命令的参数时, 结果却出乎我们的意料. .

bash$ cd //
bash$ pwd
//
	      
----------
pushd, popd, dirs
这几个命令可以使得工作目录书签化, 就是可以按顺序向前或向后移动工作目录. 压栈的动作可以保存工作目录列表. 选项可以允许对目录栈做不同的操作.
pushd dir-name把路径dir-name压入目录栈, 同时修改当前目录到dir-name.
popd将目录栈最上边的目录弹出, 同时将当前目录修改为刚弹出来的那个目录.

dirs列出所有目录栈的内容 (与$DIRSTACK变量相比较). 一个成功的pushd或者popd将会自动调用dirs命令.

对于那些并没有对当前目录做硬编码, 并且需要对当前工作目录做灵活修改的脚本来说, 使用这些命令是再好不过了. 注意内建$DIRSTACK数组变量, 这个变量可以在脚本中进行访问, 并且它们保存了目录栈的内容. 

-----------
eval arg1 [arg2] ... [argN]
将表达式中的参数, 或者表达式列表, 组合起来, 然后评价它们(译者注: 通常用来执行). 任何被包含在表达示中的变量都将被扩展. 结果将会被转化到命令中. 如果你想从命令行中或者是从脚本中产生代码, 那么这个命令就非常有用了. 
bash$ process=xterm
bash$ show_process="eval ps ax | grep $process"
bash$ $show_process
1867 tty1     S      0:02 xterm
2779 tty1     S      0:00 xterm
2886 pts/1    S      0:00 grep xterm


#20090826

不使用任何选项或参数来调用set命令的话, 将会列出所有的环境变量和其他所有的已经初始化过的变量
如果使用参数--来调用set命令的话, 将会明确的分配位置参数. 如果--选项后边没有跟变量名的话, 那么结果就使得所有位置参数都被unsets了. 

-------
unset命令用来删除一个shell变量, 这个命令的效果就是把这个变量设为null. 注意: 这个命令对位置参数无效. 

------
export命令将会使得被export的变量在所运行脚本(或shell)的所有子进程中都可用. 不幸的是, 没有办法将变量export到父进程中, 这里所指的父进程就是调用这个脚本的脚本或shell. 关于export命令的一个重要的用法就是使用在启动文件中, 启动文件用来初始化和设置环境变量, 这样, 用户进程才能够访问环境变量. 

#20090827
source, . (点 命令)
当在命令行中调用的时候, 这个命令将会执行一个脚本. 当在脚本中调用的时候, source file-name 将会加载file-name文件. sourc一个文件(或点命令)将会在脚本中引入代码, 并将这些代码附加到脚本中(与C语言中的#include指令效果相同). 最终的结果就像是在使用"source"的行上插入了相应文件的内容. 在多个脚本需要引用相同的数据, 或者需要使用函数库的情况下, 这个命令非常有用. 
如果source进来的文件本身就一个可执行脚本的话, 那么它将运行起来, 然后将控制权交还给调用它的脚本. 一个source进来的可执行脚本可以使用return命令来达到这个目的. 

---------
如果不带参数调用exit命令退出的话, 那么退出状态码将会将会是脚本中最后一个命令的退出状态码. 等价于exit $?.

------
exec
这个shell内建命令将使用一个特定的命令来取代当前进程. 一般的当shell遇到一个命令, 它会forks off一个子进程来真正的运行命令. 使用exec内建命令, shell就不会fork了, 并且命令的执行将会替换掉当前shell. 因此, 在脚本中使用时, 一旦exec所执行的命令执行完毕, 那么它就会强制退出脚本.
exec命令还能够用来重新分配文件描述符. 比如, exec <zzz-file将会用zzz-file来代替stdin. 

------
type
与外部命令which很相像, type cmd将会给出"cmd"的完整路径. 与which命令不同的是, type命令是Bash内建命令. -a是type命令的一个非常有用的选项, 它用来鉴别参数是关键字还是内建命令, 也可以用来定位同名的系统命令. 

#20090828
disown
    从shell的激活作业表中删除作业. 
比如我运行了三个程序都用[ctrl]z把它们停止到后台了，然后我运行disown就会把这些停止的进程中最后一个删掉。

---------
wait
    停止脚本的运行, 直到后台运行的所有作业都结束为止, 或者如果传递了作业号或进程号为参数的话, 那么就直到指定作业结束为止. 返回等待命令的退出状态码.
	你可以使用wait命令来防止在后台作业没完成(这会产生一个孤儿进程)之前退出脚本. 
例如我运行一个gtk编写的窗口程序:
$./hello&
然后用:
$wait
这样shell会挂起，知道我关闭hello程序。
---------
	在一个脚本中, 使用后台运行命令(&)可能会使这个脚本挂起, 直到敲ENTER, 挂起的脚本才会被恢复. 看起来只有在这个命令的结果需要输出到stdout的时候, 这种现象才会出现. 这是个很烦人的现象. 

---------
suspend
    这个命令的效果与Control-Z很相像, 但是它挂起的是这个shell(这个shell的父进程应该在合适的时候重新恢复它). 

---------
command

对于命令"COMMAND", command COMMAND会直接禁用别名和函数的查找.

译者注, 注意一下Bash执行命令的优先级:

1 1	别名
2 2	关键字
3 3	函数
	4 4	内建命令
5 5	脚本或可执行程序($PATH)

	Note	

这是shell用来影响脚本命令处理效果的三个命令之一. 另外两个分别是builtin和enable. (译者注: 当你想运行的命令或函数与内建命令同名时, 由于内建命令比外部命令的优先级高, 而函数比内建命令的优先级高, 所以Bash将总会执行优先级比较高的命令. 这样当你想执行优先级低的命令的时候, 就没有选择的余地了. 这三个命令就是用来为你提供这样的机会. )
	builtin

	当你使用builtin BUILTIN_COMMAND的时候, 只会调用shell内建命令"BUILTIN_COMMAND", 而暂时禁用同名的函数, 或者是同名的扩展命令. 
	enable

	这个命令或者禁用内建命令或者恢复内建命令. 比如, enable -n kill将禁用内建命令kill, 所以当我们调用kill命令时, 使用的将是/bin/kill外部命令.

	-a选项会enable所有作为参数的shell内建命令, 不管它们之前是否被enable了. (译者注: 如果不带参数的调用enable -a, 那么会恢复所有内建命令.) -f filename选项将会从适当的编译过的目标文件 [1] 中, 让enable命令以共享库的形式来加载内建命令. 

----------------
表格 11-1. 作业标识符
记法	含义
%N	作业号[N]
%S	以字符串S开头的被(命令行)调用的作业
%?S	包含字符串S的被(命令行)调用的作业
%%	"当前"作业(前台最后结束的作业, 或后台最后启动的作业)
%+	"当前"作业(前台最后结束的作业, 或后台最后启动的作业)
%-	最后的作业
$!	最后的后台进程

#20090831
mv的-f
当使用非交互脚本时, 可以使用mv的-f(强制)选项来避免用户的输入.rm的-f也是类似的。
---
rm将无法删除以破折号开头的文件.
解决这个问题的一个方法就是在要删除的文件的前边加上./ 例如：
$ rm ./-badname
另一种解决的方法是在文件名前边加上" -- ".如： 
$ rm -- -badname

------
mkdir的-p
-p选项将会自动产生必要的父目录, 这样也就同时创建了多个目录. 
$mkdir -p project/programs/December

#20090901
find寻找文件的时候,对每一个找到的文件执行命令：
find
    -exec COMMAND \;
如果COMMAND中包含{}, 那么find命令将会用所有匹配文件的路径名来替换"{}". 

#20090902
set -e
这个作用是如果有命令是非0那么整个脚本就退出了.
举个例子:
$set -e
$ls -a
11              diary.txt          mix.sed     split1
$ls asdfasdsdfsw
ls: cannot access asdfasdsdfsw: No such file or directory
这里就退出shell了。ls返回的结果$?=1,所以退出了shell

#20090903
readlink
显示符号链接所指向的文件.

bash$ readlink /usr/bin/awk
../../bin/gawk
-------------------------
mktemp

使用一个"唯一"的文件名来创建一个临时文件. [4] 如果不带参数的在命令行下调用这个命令时, 将会在/tmp目录下产生一个零长度的文件.

bash$ mktemp
/tmp/tmp.zzsvql3154

#20090904
run-parts
run-parts命令 [1] 将会执行目标目录中所有的脚本, 这些脚本会以ASCII码的循序进行排列. 当然, 这些脚本都需要具有可执行权限.
cron 幽灵进程会调用run-parts来运行/etc/cron.*下的所有脚本. 

打印/etc目录中所有以p开始d结束的文件名字：
run-parts --list --regex '^p.*d$' /etc
------------
yes
在非交互的脚本中可以用这个命令实现交互的功能：
yes命令的默认行为是向stdout连续不断的输出字符y, 每个y单独占一行. 可以使用control-c来结束输出. 如果想换一个输出字符的话, 可以使用yes different string, 这样就会连续不断的输出different string到stdout.
作用：在命令行或者脚本中, yes的输出可以通过重定向或管道来传递给一些命令, 这些命令的特点是需要用户输入来进行交互. 事实上, 这个命令可以说是expect命令(译者注: 这个命令本书未介绍, 一个自动实现交互的命令)的一个简化版本.
举例:
yes | fsck /dev/hda1将会以非交互的形式运行fsck(译者注: 因为需要用户输入的y全由yes命令搞定了)(小心使用!).
yes | rm -r dirname 与 rm -rf dirname 效果相同(小心使用!). 
-----
banner
    将会把传递进来的参数字符串用一个ASCII字符(默认是'#')给画出来(就是将多个'#'拼出一副字符的图形), 然后输出到stdout. 可以作为硬拷贝重定向到打印机上. (译者注: 可以使用-w 选项设置宽度.) 
---
printenv
    显示某个特定用户所有的环境变量. 

#20090910
dmesg
    将所有的系统启动消息输出到stdout上. 方便除错, 并且可以查出安装了哪些设备驱动和察看使用了哪些系统中断. dmesg命令的输出当然也放在脚本中, 并使用grep, sed, 或awk来进行分析.

--------------------
runlevel
    显示当前的和最后的运行级别, 也就是, 判断系统是处于终止状态(runlevel为0), 单用户模式(1), 多用户模式(2或3), X Windows(5), 还是正处于重起状态(6). 这个命令将会访问/var/run/utmp文件. 
