　图 5. 内部（简化的）模块卸载过程
　fig5.jpg
　当调用内核函数 sys_delete_module（将要删除的模块的名称作为参数传入）之后，第一步便是确保调用方具有权限。接下来会检查一个列表，查看是否存在依赖于这个模块的其他模块。这里有一个名为 modules_which_use_me 的列表，它包含每个依赖模块的一个元素。如果这个列表为空，就不存在任何模块依赖项，因此这个模块就是要删除的模块（否则会返回一个错误）。接下来还要测试模块是否加载。用户可以在当前安装的模块上调用 rmmod，因此这个检查确保模块已经加载。在几个维护检查之后，倒数第二个步骤是调用模块的 exit 函数（模块内部自带）。最后，调用 free_module 函数。

　　调用 free_module 函数之后，您将发现模块将被安全删除。该模块不存在依赖项，因此可以开始模块的内核清理过程。首先，从安装期间添加的各种列表中（系统文件、模块列表等）删除模块。其次，调用一个与架构相关的清理例程（可以在 ./linux/arch/<arch>/kernel/module.c 中找到）。然后迭代具有依赖性的模块，并将这个模块从这些列表中删除。最后，从内核的角度而言，清理已经完成，为模块分配的各种内存已被释放，包括参数内存、per-CPU 内存和模块的 ELF 内存（core 和 init）。

　　为模块管理优化内核

　　在许多应用程序中，动态加载模块非常重要，但加载之后，就没有必要卸载模块。这允许内核在启动时是动态的（根据找到的设备加载模块），但并不是在整个操作过程中都是动态的。如果不需要在加载之后卸载模块，那么可以进行一些优化，减少模块管理所需的代码。您可以 “取消” 内核配置选项 CONFIG_MODULE_UNLOAD，删除大量与卸载模块相关的内核功能。

　　结束语

　　这一直是内核里面模块管理过程的高级视图。要获得模块管理的细节，源代码本身就是最佳的文档。关于在模块管理中调用的主要函数，请查看 ./linux/kernel/module.c（以及 ./linux/include/linux/module.h 中的头文件）。您还可以在 ./linux/arch/<arch>/kernel/module.c 中找到几个与架构相关的函数。最后，可以在 ./linux/kernel/kmod.c 中找到内核自动加载函数（可以根据需要从内核自动加载模块）。这个功能可以通过 CONFIG_KMOD 配置选项启用。
