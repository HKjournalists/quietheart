下一步是对加载的 ELF 映像执行一组健康检查（它是有效的 ELF 文件吗？它适合当前的架构吗？等等）。完成健康检查后，就会解析 ELF 映像，然后会为每个区段头创建一组方便变量，简化随后的访问。因为 ELF 对象的偏移量是基于 0 的（除非重新分配），所以这些方便变量将相对偏移量包含到临时内存块中。在创建方便变量的过程中还会验证 ELF 区段头，确保加载的是有效模块。

　　任何可选的模块参数都从用户空间加载到另一个已分配的内核内存块（第 4 步），并且更新模块状态，表明模块已加载（MODULE_STATE_COMING）。如果需要 per-CPU 数据（这在检查区段头时确定），那么就分配 per-CPU 块。

　　在前面的步骤，模块区段被加载到内核（临时）内存，并且知道哪个区段应该保持，哪个可以删除。步骤 7 为内存中的模块分配最终的位置，并移动必要的区段（ELF 头中的 SHF_ALLOC，或在执行期间占用内存的区段）。然后执行另一个分配，大小是模块必要区段所需的大小。迭代临时 ELF 块中的每个区段，并将需要执行的区段复制到新的块中。接下来要进行一些额外的维护。同时还进行符号解析，可以解析位于内核中的符号（被编译成内核映象），或临时的符号（从其他模块导出）。

　　然后为每个剩余的区段迭代新的模块并执行重新定位。这个步骤与架构有关，因此依赖于为架构（./linux/arch/<arch>/kernel/module.c）定义的 helper 函数。最后，刷新指令缓存（因为使用了临时 .text 区段），执行一些额外的维护（释放临时模块内存，设置系统文件），并将模块最终返回到 load_module。

　　模块卸载细节

　　卸载模块的过程和加载模块基本一样，除了必须进行几个健康检查外（确保安全删除模块）。卸载模块过程首先在用户空间调用 rmmod（删除模块）命令。在 rmmod 命令内部，对 delete_module 执行系统调用，它最终会导致在内核内部调用 sys_delete_module（查看 图 3）。图 5 演示了删除模块的基本操作过程。
