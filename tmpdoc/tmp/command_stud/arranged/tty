tty [选项]...

[功能]
打印连接到标准输入的终端的文件名。

[描述]
命令选项：
-s, --silent, --quiet: 什么也不打印，只是返回退出状态码。
--help: 打印帮助信息。
--version: 打印版本信息并退出。

返回的状态码：
0 表示标准输入是一个终端。
1 表示标准输入不是一个终端。
2 表示给定的参数是不正确的参数。
3 表示发生了写错误。

[举例]
*查看当前的标准终端文件描述符号：
[quietheart@lv-k etc]$ tty 
/dev/pts/6
这里，输入tty之后，输出"/dev/pts/6"就是当前连接的终端对应的文件描述符号,我们可以通过向这个文件，这样会看到当前终端会输出我们写入的数据，例如：
[quietheart@lv-k etc]$ echo "mytest" >/dev/pts/6
mytest
可见，向/dev/pts/6文件写入的内容，直接显示到我们的终端上面了。如果我在机器上面开了多个终端，然后我在别的终端中输入上面的echo命令，那么将会看到对应"/dev/pts/6"的终端上面会显示相应的字符了。

*运行tty什么也不输出，然后查看其退出码：
[quietheart@lv-k etc]$ tty -s
[quietheart@lv-k etc]$ echo $?
0
这里，使用shell的命令"echo $?"来显示上一条命令的退出状态码。状态码的含义如下：
0 表示标准输入是一个终端。
1 表示标准输入不是一个终端。
2 表示给定的参数是不正确的参数。
3 表示发生了写错误。

[其它]
*基本概念：
1,tty(终端设备的统称):
tty一词源于Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘与显示器取代，所以现在叫终端比较合适。终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。
2,pty（虚拟终端):
如果我们远程telnet到主机或使用xterm时,也需要一个终端交互，这就是虚拟终端pty(pseudo-tty)
3,pts/ptmx(pts/ptmx结合使用，进而实现pty):
pts(pseudo-terminal slave)是pty的实现方法，与ptmx(pseudo-terminal master)配合使用实现pty。

*Linux终端：
在Linux系统的设备特殊文件目录/dev/下，终端特殊设备文件一般有以下几种：
1,串行端口终端(/dev/ttySn)
串行端口终端(Serial Port Terminal)是使用计算机串行端口连接的终端设备。计算机把每个串行端口都看作是一个字符设备。有段时间这些串行端口设备通常被称为终端设备，因为那时它的最大用途就是用来连接终端。这些串行端口所对应的设备名称是/dev/tts/0(或/dev/ttyS0), /dev/tts/1(或/dev/ttyS1)等，设备号分别是(4,0), (4,1)等，分别对应于DOS系统下的COM1、COM2等。若要向一个端口发送数据，可以在命令行上把标准输出重定向到这些特殊文件名上即可。例如，在命令行提示符下键入：echo test > /dev/ttyS1会把单词”test”发送到连接在ttyS1(COM2)端口的设备上。可接串口来实验。
2,伪终端(/dev/pty/)
伪终端(Pseudo Terminal)是成对的逻辑终端设备(即master和slave设备, 对master的操作会反映到slave上)。
例如/dev/ptyp3和/dev/ttyp3(或者在设备文件系统中分别是/dev/pty/m3和 /dev/pty/s3)。它们与实际物理设备并不直接相关。如果一个程序把ptyp3(master设备)看作是一个串行端口设备，则它对该端口的读/ 写操作会反映在该逻辑终端设备对应的另一个ttyp3(slave设备)上面。而ttyp3则是另一个程序用于读写操作的逻辑设备。
这样，两个程序就可以通过这种逻辑设备进行互相交流，而其中一个使用ttyp3的程序则认为自己正在与一个串行端口进行通信。这很象是逻辑设备对之间的管道操作。对于ttyp3(s3)，任何设计成使用一个串行端口设备的程序都可以使用该逻辑设备。但对于使用ptyp3的程序，则需要专门设计来使用 ptyp3(m3)逻辑设备。
例如，如果某人在网上使用telnet程序连接到你的计算机上，则telnet程序就可能会开始连接到设备 ptyp2(m2)上(一个伪终端端口上)。此时一个getty程序就应该运行在对应的ttyp2(s2)端口上。当telnet从远端获取了一个字符时，该字符就会通过m2、s2传递给 getty程序，而getty程序就会通过s2、m2和telnet程序往网络上返回”login:”字符串信息。这样，登录程序与telnet程序就通过“伪终端”进行通信。通过使用适当的软件，就可以把两个甚至多个伪终端设备连接到同一个物理串行端口上。
在使用设备文件系统 (device filesystem)之前，为了得到大量的伪终端设备特殊文件，使用了比较复杂的文件名命名方式。因为只存在16个ttyp(ttyp0—ttypf) 的设备文件，为了得到更多的逻辑设备对，就使用了象q、r、s等字符来代替p。例如，ttys8和ptys8就是一个伪终端设备对。不过这种命名方式目前仍然在RedHat等Linux系统中使用着。
但Linux系统上的Unix98并不使用上述方法，而使用了”pty master”方式，例如/dev/ptm3。它的对应端则会被自动地创建成/dev/pts/3。这样就可以在需要时提供一个pty伪终端。目录 /dev/pts是一个类型为devpts的文件系统，并且可以在被加载文件系统列表中看到。虽然“文件”/dev/pts/3看上去是设备文件系统中的一项，但其实它完全是一种不同的文件系统。
即: TELNET ---> TTYP3(S3: slave) ---> PTYP3(M3: master) ---> GETTY

*实践
以下过程是在ubuntu上面的实践结果。
1,虚拟终端/dev/tty*和伪终端/dev/pts/*：
假设有5个xterm终端的话，会发现/dev下面有一个/dev/ptmx /和5个/dev/pts/*
而如果用"[Ctrl][Alt]F1"进入一个终端的话，就会发现/dev下面多出一个/dev/tty1

2,查看终端的方法：
使用命令"tty"可以查看当前对应的终端，命令"ps -ax"可以查看所有程序以及对应的终端。通过这个命令，发现如果多开一个screen程序，或者用telnet登陆之后，那么机器上面就会多一个/dev/pts/*。可知，一般伪终端用户模拟终端程序。

3,向指定终端发送信息：
如果运行"echo hello >/dev/tty2"，
那么"[Ctrl][Alt]F2"打开"/dev/tty2"对应的终端，就会发现刚才发送的hello了。
注意，如果发送"echo -n ls >/dev/tty2"那么会显示ls,但是回车之后，并没有执行ls。可见:ttyN是代表linux的纯命令行终端，而写到这个终端的字符串只是做为这个终端的输出，并没有当做终端的输入处理。

如果运行"echo hello >/dev/pts/2"，
那么，就可以在xterm的第二个窗口看到hello了。可知，/dev/pts/n是Xwindows模式下的伪终端.

参考资料：
http://blog.csdn.net/freeman1975/archive/2009/10/19/4696781.aspx
"info tty"
"man tty"
