http://blog.itpub.net/category/42725/66614

北极的杯
所有资料都来自网络！
22 10, 2010
缩进::Vim进阶索引[8]
作者 helloxchen 12:52 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
Table of Contents

    * 缩进::Vim进阶索引[8]
    * 1 基础知识
    * 2 预设规则
          o 2.1 autoindent
          o 2.2 smartindent,cindent
          o 2.3 lisp 
    * 3 进阶规则（indentexpr）
          o 3.1 简单缩进
          o 3.2 indentkeys 
    * 4 缩进进阶
          o 4.1 例2
          o 4.2 例2 
    * 5 进阶提示
          o 5.1 去除缩进
          o 5.2 缩进与格式化选项
          o 5.3 缩进与折叠 
    * Appendix A 表达式与沙箱 

缩进可以使用文本结构更清晰易读。在Vi中，这通过是使用专用的外部程序（如：indent或c beautifier类的程序）实现的。Vim除保留了原有外部程序支持外更增加了一些内部的支持。包括了插入模式下的交互进行的缩进与'='指令的缩进操作。
1 基础知识

:h indent.txt
:h =
:h 'equalprg'
:h indentkeys

Vim中缩进有三种基本的使用方式。一是在普通（正常）模式下使用'='指令。可以圈选范围后使用可以在指令后加上移动的指令。使用的方式与其他编辑指令是一样的（比如'd'）。'=='表示对当前行进行缩进。看下面的例子：

=ip
    对当前段落缩进
=G
    将由当前行至文章末尾的范围缩进
30==
    缩进由当前行开始的30行 

二是在编辑的过程（插入模式）使用某些键触发。比如，使用'autoindent'时，在插入模式中输入回车（即按回车键）时Vim自动对新行应用缩进规则。
三是粘贴文本时，使用']p'指令对粘贴文本强制运用缩进。详见：:h ]p

此外，'gq'或ex命令':left'也能用来缩进文本。由于它们属于文本格式化的内容，这里不作讨论。

注意：当'equalprg'不为空时，'='/'gq'总是使用equalprg中设置的外部工具。除此之外其他的缩进操作不影响。

    在equalprg中使用的外部程序通常是整理（过滤）文本的工具，很少是单独用于缩进的工具。此外，如果通过外部程序实现缩进，有一些缺点不可避免：

        * 使用上不方便。如果要实现交互方式的缩进（即边输入边根据输入实现缩进），要不断运行外部程序，运行效率低。通过cinkeys/indentkeys的设置Vim可以在输入时计算缩进。
        * 对大多数的一般应用而言，用户只需要最基本的缩进支持——如autoindent。而你却很难找到这样的程序。
        * 许多工具不跨平台。
        * 不够灵活。你其实不想为一些简单的缩进而写新的程序。 

Vim应用缩进的过程如下：

   1. 依据设置使用缩进规则计算缩进宽度。

          在不同的缩进规则同时开启时只能有一个起作用。在所有开启的缩进项中只有优先级最高的起作用。它们的优先级排列如下：
          indentexpr > cindent > smartindent > ai

          缩进宽度：以一个半角字符的宽度为基本单位计算的总缩进的量。缩进时，Vim会在行首增加相应宽度的空格或制表符。举例而言，如果缩进宽度为4，则Vim在行首增加4个半角空格；如果缩进宽度为8，Vim在行首增加一个制表符。 

   2. 删除目标行首的制表符与空格。
   3. 根据expandtab与tabstop的设置及缩进宽度添加相应的空格或制表符。

          制表符的宽度与'tabstop'的设置有关。默认值是8，所以8个半角空格（或其他字符）的宽度与一个制表符一样。如果将'tabstop'设为4，那么如果缩进宽度为9则Vim在行首增加2个制表符与1个半角空格。如果不想使用制表符可以:se noet 

如果要实验各种缩进方式的话，建议定义如下的快捷键以便随时按<F9>查看缩进的设置：

map <F9> :se autoindent? smartindent? cindent? lisp? indentexpr? equalprg? paste? cpoptions?<CR>

有些选项，如'paste'会影响缩进，所以需要查看这个设置项的情况。各个设置项的情况可以见各自的文档。
2 预设规则

为了方便用户Vim提供了一些预置的缩进规则：自动缩进（autoindent）、智能缩进（smartindent）、c缩进（cindent）、lisp缩进（lisp）。
2.1 autoindent

autoindent的缩进规则是最简单的。它使用与上一行一样的缩进量。换言之如果你为当前行加了3个空格的缩进，则开始下一行时Vim会自动添加3个空格的缩进。写python脚本时，使用这种缩进就够了。

使用autoindent，只要开启相应的选项：:se autoindent 或 :se ai

注意：indentexpr、lisp、cindent、smartindent中的任一项开启都会覆盖autoindent的设置。
2.2 smartindent,cindent

:h C-indenting
:h smartindent
:h cindent
:h cinkeys
:h cinwords
:h cinoptions
:h cinkeys-format

smartindent的缩进规则可应用于与c语法类似的语言如AWK、JavaScript等，当然也可以用在c语言。它的规则是将{}块内的语句缩进一定宽度。嵌套的{}块内的语句则相对于上一层语句缩进一定宽度。

cindent的缩进规则是专门用于c语言的缩进。与smartindent相比，cindent除了更严格地对应c语言的语法外，还增加了风格选项——为了适合不同的c语言风格，Vim提供了相当多的定置项改变cindent的缩进方式。设置项包括了：

cinkeys
    这个选项定义了一组可以触发缩进的按键。在遇到这些按键是Vim会根据缩进规则重新计算当前行的缩进。定义按键的格式可以见:h cinkeys-format
cinwords
    定义了一组让下一行相对对当前行增加缩进的关键字。在遇到定义在cinwords中的字时，Vim为接下来一行增加缩进。
cinoptions
    缩进风格选项。参考：:h cinoptions-value、 

2.3 lisp

:h lisp
:h lispwords

根据lisp语法缩进，我懂得很少，所以——详见帮助。
3 进阶规则（indentexpr）

:h cpo
:h indentexpr
:h indentkeys

与折叠一样，缩进也支持使用表达式定义缩进。这个表达式可以是任意表示数值的表达式也可以是返回数值的自定义/内置函数，这个数值将做为缩进的宽度。也与折叠一样Vim使用v:lnum表示目标行的行号。其它常用的函数包括了indent()、getline()、 prevnonblank()、nextnonblank()等等。与折叠不一样的是使用缩进表达式不用另外指定缩进方式，只要赋于indentexpr 项一个值，就会覆盖autoindent或smartindent/cindent的设置。

Vim的缩进表达式要比折叠表达式直观得多。我们直接通过例子了解缩进表达式的使用。
3.1 简单缩进

先看几个简单的缩进表达式：

" 缩进宽度总为4
:se indentexpr=4
" 不使用表达式缩进
:se indentexpr=
	
" 将缩进宽度设为与&sw设置一致
:se inde=&shiftwidth
	
" 逐渐增加缩进
:se inde=v:lnum

这一组表达式还是比较容易理解的，都是直接将一某个数值（不需要什么计算）作为缩进量。 此外，三元条件表达式在折叠篇中也已经看了不少：

" 偶数行缩进4格
:se indentexpr=v:lnum%2?0:4
	
" 取消注释行的缩进
:se inde=getline(v:lnum)=~'^s*#'?0:indent(v:lnum)
	
" 行首缩进：
:se inde=(getline(v:lnum-1)=~'^s*$')?4:0
" 悬挂缩进：
:se inde=(getline(v:lnum-1)=~'S')?4:0
	
" 相对于上一行缩进行首带着-号的行
:se inde=getline(v:lnum)=~'^s*-'?indent(v:lnum-1)+4:0
	

这一小节的的最后一个例子是个常用到的缩进：根据编号缩进。

1. statement
1.1. substatement
2. statement
2.1. substatement
2.1.1. subsubstatement
2.2. substatement

在看需求文档时几乎每一行都是编号的。程序员从不同的渠道获得这些文档，可能是从某个需求管理系统，电子邮件或者SKYPE。它们有不一样的缩进，有一些甚至没缩进。自动缩进工具此时显得特别有用。

    对于写需求文档的人来讲他们除了要能智能的缩进他们可能还需要一个可以自动编号（根据缩进或者行首的*字符的个数）的编辑器。当然Vim用户是不需要再花时间找这样的工具的！ 

要将这些编号可以用以下的脚本：

" 根据编号缩进
:se inde=len(split(substitute(getline(v:lnum),'^[ t]*([0-9.]+).*','1',''),'.'))*&sw

将函数写成单行形式的最大挑战是要加上非常多的转义符。而且记住：使用单引号，不要用双引号。具体的原因See 附录的解释.

如果不想记转义规则可以用函数将它包装起来。当然，这样也就没办法在模式行中使用了：

func! GetIndent(lnum)
  let ind=len(split(substitute(
        getline(a:lnum),'^[ t]*([0-9.]+).*','1',''),'.'))
  return ind
endfunc
se inde=GetIndent(v:lnum)*&sw

3.2 indentkeys

在定义了缩进表达式后，我们可以在文本输入完成后使用'='或'=='进行缩进。如果要在编辑的过程中实时地缩进，我们需要定义合适的'indentkeys'。考虑下面的表达式：

" 将字串长小于20的句子右对齐
" 这条命令实际等价于:right 20
se inde=20-len(substitute(getline(v:lnum),'^[t ]+','',''))

因为默认的indentkeys中包含了o,O，所以在开启新行时，Vim就已经计算了缩进——但这时我们的输入还没完成，所以缩进宽度是错的。我们需要让Vim在句子输入完成后再计算缩进宽度。也就是在我们按下回车后先计算并应用缩进再插入换行符。同时还需要定义一个在插入模式中可以使用的缩进命令，以随时强制Vim计算缩进。就像所有Vim的其他功能一样，Vim也为这个功能提供了设置项，这次是 indentkeys，

se indentkeys=*<CR>,!^F

*<CR>表示在插入模式下按回车键时，先重新计算缩进再加入换行符。如果只有<CR>则Vim会先加入换行符再计算缩进——这时新增行成了目标行。
!^F表示在插入模式下按Ctrl-F时，重新计算缩进但不插入字符。关于*和!在indentkeys（及cinkeys）中的意义可以见：:h indentkeys-format
4 缩进进阶

在处理缩进时经常会遇到嵌套的格式文本，幸好它们都大同小异。考虑下面的文本嵌套结构：

[marker]
  block
  [marker]
    block
  [end marker]
[end marker]

这种类型的文件很常见xml（<xxx>block</xxx>），C代码（{block}），opera书签文件（opera6.adr）等1。

下面我们将一起为两个使用这种结构的文本的写缩进脚本。
4.1 例2

在一些情况下'marker'与'end marker'不那么明显。下面是一个文本目录树：

+ item1
- item2
  + subitem
  - subitem
    * subsubitem
  -
-
* item3

这里的marker是跟减号跟随文字，end marker则是一个减号（后面没有文字）。事实上将这个end marker改成一个空行，在处理上也不会有什么不同。2

但无论是哪种形式只是对marker的判别方式有一些区别，其结构并无本质区别。

状态及对应的处理方式;

    * 当前条目如果只有一个减号（^s*-s*$），则当前条目相对上一条目减少缩进量。
    * 上一条加号或星号开始（^s*[+*]） 当前条目与上一条目的缩进一样
    * 上一条如果只有一个减号（^s*-s*$），则当前条目减少缩进量。
    * 上一条如果由一个减号开始（^s*-s*S+$），则当前条目增加缩进量。 

这样脚本就很清楚了，

func! MyIndent(lnum)
  let lastline=getline(a:lnum-1)
  if a:lnum==1 | return 0 | endif
	
  if getline(a:lnum)=~'^s*-s*$'
    let diff=-1
  elseif lastline=~'^s*[*+]'
    let diff=0
  elseif lastline=~'^s*-s*$'
    let diff=-1
  elseif lastline=~'^s*-s*S'
    let diff=1
  endif 
	
  return indent(a:lnum-1)+diff*&sw
endfunc
	
se inde=MyIndent(v:lnum)

4.2 例2

最后是一个完整的例子仍是嵌套的文本块，看一下下面的文本，

[
outer block
[[
inner block
]
]
[
[inner block]
]
]

这个仍然是marker与end marker的格式。[是marker，]是end marker。我们要写一个使之能正确缩进的脚本，其中的关键在于判断嵌套的深度来决定缩进宽度。我们可以使用一个buffer变量保存嵌套深度，遇到 [增加，遇到]减少深度。但因为=命令可以多次不连续地对不同文本块使用，所有变量的存在可能会导致不正常的结果。为此，仍像前面的例子一样我们将根据前一行的状态判断缩进深度。根据上一行的marker，计算当前行的缩进宽度。描述如下，

    * 如果上一行是[，当前行增加宽度
    * 如果上一行是]，当前行减少宽度
    * 否则，保持上一行的宽度 

还要考虑到一点，同一行可能数量不等的多个]或[——事实上这是这个例子与上一个例子唯一的不同之处。因为一对[]的缩进刚好可以抵消，我们可以通过它们的差决定缩进的宽度。另外，如果当前行有[或]还要相应增加或减少当前行的缩进。所以改进后的描述如下，

    * 将上一行[的数量减去]的数量，得到初始的缩进宽度
          o 结果为正，则为当前行增加相应数量的缩进
          o 否则，为当前行减少相应数量的缩进 
    * 在前面计算的基础上计算当前行的[与]的差，得到缩进的增量。
          o 结果为正，则为当前行增加相应数量的缩进
          o 否则，为当前行减少相应数量的缩进 

现在我们可以写脚本了，

" 其中，根据[]数量计算宽度这一段是重复的，
" 我们可以写成一个单独的函数
	
func! IndentSum(lnum,incre)
" 两个参数分别表示目标行行号与缩进的初始量
    let line=getline(a:lnum)
    " 通过'['与']'的数量计算缩进宽度
    " 每多一个[则增加一个单位的缩进
    " 每多一个]则减少一个单位的缩进
    " 没有]或[的行使用与上一行一样的缩进
    let in=len(split('x'.line.'x','['))-1
    let ou=len(split('x'.line.'x',']'))-1
    " [的数量减去]的数量
    return &sw*(in-ou)+a:incre
endfunc
	
func! BIndent(lnum)
    " 上一非空行的行号
    let llnum=prevnonblank(a:lnum-1)
    if llnum==0 | return 0 | endif
    " 由上一行得到初始的缩进宽度
    let ind=IndentSum(llnum,indent(llnum))
    " 计算当前行的的缩进增量
    let ind=IndentSum(a:lnum,ind)
    return ind
endfunc
	
se inde=BIndent(v:lnum)

现在，你已经可以写c缩进的脚本了（将上面脚本中的[]换成{} :) ）。这种缩进的计算方式几乎是一个套路了。基于同样的模式，同样的工作流程的一个xml的缩进的例子可以见Vim安装目录中indent/xml.vim。
5 进阶提示

这一章是关于缩进的一些零散的内容。
5.1 去除缩进

:h g@
:h operatorfunc

现在你可以用'='进行缩进了你可能还需要一个可以去除缩进的指令。当然你可以用'<<'，但这个命令一次只缩进一层。很遗憾你并不能使用'4<<'将文本向左移4次（这条命令将4行文本往左移一次），你只能一次一次来（或者按1 次<<，再按3次.）。如果你确实需要一次去除许多缩进的话，可以使用下面的map宏：

:nnoremap <<< :left<CR>
:vnoremap <<< :left<CR>

这个宏有两个主要缺点，一是会使<<命令变慢，因为Vim要等等看后面是否还有一个<。这可以通过减小设置项'timeoutlen'的值，减少等待时间，但你的操作也要相应变快才行。或者另外定义一个按键序列，不使用<<<。二这条命令不支持对象选择。这不算是个很大的缺点，但如果支持的话显然会更方便一点。我们可以用g@包装上命令，使之具有对象选择的功能：

func! Deindent(dummy)
  exe 'normal! ' . "'[V']:left<CR>"
endfunc
se opfunc=Deindent
	
nnoremap <<< g@
vnoremap <<< g@

现在试一下<<<G, <<<aB或<<<ip。g@的用法见Vim文档。
5.2 缩进与格式化选项

:h gq
:h formatoptions
:h formatprg

缩进与文格式化(gq)紧密相关，你可能会有兴趣看一下这一部分的内容。
5.3 缩进与折叠

在折叠篇我们知道可以以缩进作为折叠的规则。因此这实际给我们一种同时定义缩进与折叠的方式。在学了这一篇之后这个折叠的缩进规则就能派上用场了！

:se fdm=indent

Appendix A 表达式与沙箱


直接写表达式跟将表达式包装在一个函数中有一个最主要的不同是，前一种方式中的及空格需要进行转义。所以在模式行中要使用很多的。另外要注意的是"与'是不一样的。

:h expr-quote
:h expr-'

在写Vim脚本或命令时"的字串是允许使用转义字符的，而'的字串则不进行转义。如"t"表示的是一个制表符而't'表示的是一个斜杠和一个字母t。't'等价的双字号字串是"t"。
在脚本篇我们就讲过了一个例子：

echo '|t|'
echo "|t|'

但对于indentexpr及其它在沙箱中计算表达式的设置项来讲，数值表达式在进入沙箱中先进行了一次表达式的计算 ——只是计算字串值。例如，当你执行:se inde=len('abct')时，先计算字串的“安全值”。即在计算函数的值之前，Vim会先计算字串表达式的值，所以函数现在成了，

"len('abct')"

这个字串表达式的值，大家都知道是（通过:echo &inde可以观察字串表达式的值）：

len('abct')

然后，再计算函数的值，结果是4（3个字母加一个制表符）。

在执行=命令时，Vim首先计算了字串表达式的值，再eval字串的值（即执行len('abc')并返回数值）。

注意，在写表达式时你并不需要在前后加上引号，Vim会自动为你加上双引号并进行计算字串的值。这个过程中Vim还进行了一些处理以确保值是“安全的”。其中包括移掉未转义的。可以简单的记为这些表达式中不能有未转义的双引号"，空格和斜杠。还是例子比较实在，

命令 	字串表达式 	字串值
:se inde=len('t') 	"len('t')" 	len('t')
:se inde=len('t') 	"len('t')" 	len('t') 	未转义斜杠会被忽略掉
:se inde=len(' abc') 	无 	无 	空格未被转义，不合法表达式
:se inde=len('ab"c') 	"len('ab"c')" 	len('ab 	双引号"未被转义，所中间的"后的字串被省略
:se inde=len("t") 	"len("t")" 	len("t")

正因为在计算len()之前已经先计算了字串值一次，所以本来，

func! GetIndent(lnum)
	return len(split(substitute(getline(v:lnum),'^[ t]*([0-9.]+).*','1',''),'.'))*&sw
endfunc
se inde=GetIndent(v:lnum)

不用转义的表达式，直接放到:se inde命令后，就成了：

:se inde=len(split(substitute(getline(v:lnum),'^[ t]*([0-9.]+).*','1',''),'.'))*&sw

可以看到多了一堆的反斜杠（''）。不与这些转义规则打交道的方法是尽量将它们包装在独立的函数中（这样不用使用沙箱）。如果一定要用的话尽量少用空格与双引号。

Footnotes

[1] 事实上几乎所有的嵌套结构都是这样的

[2] 但有个'-'号会比空行直观一点。

22 10, 2010
TAGS::Vim进阶索引[7]
作者 helloxchen 12:49 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
TAGS::Vim进阶索引[7]
Table of Contents

    * Vim进阶索引[7]::TAGS
    * 1 基本的tags用法
    * 2 tags文件格式
    * 3 相关命令
    * 4 tags进阶
          o 4.1 编写/转换为Vim文档
          o 4.2 exuberant ctags
          o 4.3 增加taglist支持
          o 4.4 生成导航窗口 
    * 5 小结 


Vim进阶索引[7]::TAGS

    tags最广为人知的应用是taglist。但大家对tags本身的关注却少得多。我希望这一篇文章能帮你懂得使用tags、生成tags和扩展tags的应用范围。与之前的几篇不一样的是这一篇的脚本使用了许多Vim7的新特性——大部分是关于List的。 

这几个是相关的文档：

:h tagsrch
:h taglist()

当我们在查看Vim文档时，只要在关键字（即两边带有"|"的字）上按CTRL-]就可以跳转到指定的位置——Vim是如何做到这一点的呢？它怎么会知道目标位置在哪呢？

其实在进行跳转时，Vim借助了一个叫"tags"的文件。tags文件是一个表格，表格中的记录以行为单位。每一条记录包含一个tag（标签）及一条对应该标签的位置信息。当我们按CTRL-]时，Vim 在"tags"中查找相应的标签——即当前光标下的字。如果找到则读取该条记录的位置信息。并根据该信息转到相应的位置。标签就相当于HTML的链接文本，而tags文件则记录了每个链接的链接文本（标签）及其对应的href信息（位置信息）。在任意文件的任意位置，都可以使用通过标签跳转到该标签所对应的位置——只要该标签存在于某个Vim可以找到的tags文件中。

通常Vim会在当前目录下（:pwd）查找tags文件。但你可以指定某个目录下的特定文件为tags文件——不一定要命名为tags，但无论你为它取什么文件名，为了指代方便这里我们还是叫它为tags文件。当你需要为它指定其他名字或位置时，你可能用得着modeline或filetype功能。

如果你还没见过tags文件，现在打开Vim文档所用的tags文件看一下：

:e $VIMRUNTIME/doc/tags



1 基本的tags用法

如果你没用过Vim中的相关功能，你可以通过这一节的例子了解tags的基本用法。如果你用过——看下一章。
新建一个工作目录，我们会在这个目录下建三个文件做实验。

先建立如下文件，命名为“file.txt”:

第一行
第二行
第三行
第四行
vim:tags=./tags

接下来建立一个tags文件。tags文件有三栏，第一栏是标签，第二栏是文件名，第三栏表示在文件中的第几行。我们先建立四个标签：A,B,C,"A B"（这个例子中标签名不重要，可以随便取。）分别用来表示上面文件中的第一、二、三、四行。新建名为“tags”的文件，并输入如下内容——注意栏与栏之间用制表符（tab）分隔：

A	file.txt	1
A B	file.txt	4
B	file.txt	2
C	file.txt	3

最后，在新建一个文件，并在任意位置输入"A B C"并保存——字符之间要留有空格。将光标移到字母B上按CTRL-]，现在你应该在file.txt的第二行了也就是我们在tags文件中设定的位置上了。现在按CTRL-T可以回到原来的位置。然后再按CTRL-]又跳到file.txt的第二行了。现在，你可以反复地按CTRL-O和CTRL-I后退前进。还有一个问题，怎么使用 "A B"这个标签呢？方法是先选中再按CTRL-]——也就是先将光标放到字母A上，指令序列如下：vfB<C-]>。

中文字与字之间没有空格，所有在中文环境中也经常要使用选中再按CTRL-]的方式跳转。



2 tags文件格式

:h 'tags'
:h tags-file-format

让我们从上面的例子总结一下tags文件的格式：共有三栏（一般也都是三栏），栏与栏之间用一个制表符（Tab）分隔。最前面一栏是标签，后面是具体的位置信息——为表示方便我们估且称之为锚点。第二栏用于定位到特定文件，第三栏将位置具体到特定的行。

B file.txt 2

可解读为标签“B”所指代的位置是“file.txt”文件的第2行（或者说标签“B”对应的锚点在“file.txt”的第2行。）

但上面例子使用最简单的tag格式。实际上，你可能会遇到下面这样子的tags文件：

A	file3.txt	10
ANSWER	file3.txt	norm 30G4|
B	file2.txt	2;"	kind:f	kkk:vvv
C	file3.txt	32
C	file7.txt	/somewhere

我们看一下跟原来的tags文件有什么不一样：

    * 这个tags文件，包含的位置信息分属不同的文件。这意味着通过tags文件，你不仅可以转到同一文件的不同位置，还可以在一堆文件中跳转。
    * 它包含了不只一种定位的方式。在原来的例子中，行的位置是直接用数字表示的。但实际上Vim可以懂Ex命令。所以遇到"norm 30G4|"Vim会将光标定位到第30行的第4列。而遇到“/somewhere”，Vim会在file7.txt中查找第一个somewhere出现的位置。通过正则表达式的字元就可以进行更复杂的定位。对于不需要修改的文档可以使用行号而需要编辑的文档可以使用正则表示式，这样即使做了修改也能定位到正确的位置。
    * 有两个同样的标签C指向了不同位置。这种情形当你使用C标签时，Vim会提示有多个匹配，可以:tn跳到下一个匹配。
    * 标签B的行号后面有“尾巴”。Vi或其他编辑器中“;"”后的内容被视为注释。但Vim可以读取这部分的内容，所以我们可以通常这一部分为tags添加额外的信息。看下面的解释。 

只要遵循一定的规范就可以让注释变为有用的信息。我们一起再做个实验，将上面的示例文本，用Vim保存为"tags"。然后在Vim中输入如下命令，观察结果：

:echo taglist("^")
:echo taglist("^B")
:echo taglist("^B")[0]['kind']
:echo taglist("^B")[0]['kkk']

可以看到在返回的字典列表中，多了一个kkk项，可以通过它取得kkk的值vvv。我们可以继续往tags里增加“键:值”对。只要记住，每一项之间要用制表符分开（包括;"与第一项之间），键与值之间用冒号（:）分隔。 另外，Vim支持中文键值但不支持中文键名。如果需要遍历列表可使用:for（:h :for）语句。而且每个tag都有kind项，不论有无给出kind的值，它的值可以是任意的单个字母。为kind赋值时“kind:”也可以省略。所以，标签B也可写为：B file2.txt 2;" f kkk:vvv

    注意：tags文件的编码(encoding)要与Vim的默认编码一致，不然可能会出现中文文字工作不正常的情况。 



3 相关命令

就像往常一样，Vim提供了非常多的命令——但本文的目的不在帮用户背命令。关于这些命令可翻看文档。

:h tag-commands

    下面这几个命令是一定要掌握的：

         :h tag
         :h CTRL-]
         :h CTRL-T
         :h CTRL-O
         :h CTRL-I

    提示：在使用:tag时是可以使用tab键补全的，此外还可以使用正则表达式搜索标签。如：:tag /agname 

现在我们已经了解它的原理、它的格式，也知道怎么样使用这些tags文件了。现在我们要进入进阶的部分了——我们要根据需要定制自己的tags。



4 tags进阶

可以使用的tag命令是固定的，就是Vim提供的那些命令。但生成什么样的tags文件用户是可以控制的。因而用好这个功能的关键也在于怎么生成tags、生成什么什么样的tags。生成什么样的tags取决于用户的意图，怎么生成则依赖于我们的工具。使用ctags程序无疑是最方便的选择，对于每种语言基本上都可以找到对应的ctags工具。只是生成编程用的tags相对用户的多样需求来讲稍嫌不足。下面的内容将通过例子演示怎么根据自己的意图生成合适的 tags，也会涉及如何扩展ctags的功能。

    Vim本身就可以生成tags（:h :helptags）。但是大多数情况下你用ctags类工具生成tags文件。但是你也可以借助sed，awk，perl……等工具，甚至是手工编辑。:h tags-file-format 




4.1 编写/转换为Vim文档

我们已经知道tags可以在文档间建立关联。这样既方便用户查询又可以方便地在文档间切换。如果你希望为自己的文档增加tags，你只需要定义好锚点和标签的样式（其实就是为锚点和标签增加独特的标识或分隔符，这样工具才能分辨关键字与普通字词）。好的样式可方便工具找到生成tags的规则，减少调试正则表达式的时间。在标签样式中尽量不在要标签中使用空格，使用命令才方便。对于中文我们可能需要定义一个可以将标签与其他文字分隔的样式。这样才能方便地使用CTRL-]。

我们的第一个例子是基于大家都已经熟悉Vim在线文档系统。在这个系统中大家使用:help命令找到相关主题的文档，还能在关键字之间方便地跳转。现在我们知道这个系统的幕后英雄就是tags。

这一节就要讲怎么用Vim文档格式制作出自己的文档（准确地说是使用Vim的tags约定写自己的文档）。当然，先回答个问题——为什么要制作Vim格式的文档呢？

    * 重用已有设计是省时省力的方案。
    * Vim文档的格式很简单。
    * 有现在的tags工具——:helptags。
    * 可以使用Vim的文档系统。除了在开发插件的时候用得着外，你可曾想过通过输入:h 01082007查看自己2007年8月1日的日记呢？额……我承认这个想法有点“非常规”。那你有没有想过在Vim中输入:h Best-Tips呢？:) 

这是制作Vim文档的步骤：

   1. 写作并在适当的地方加入锚点和标签。写Vim文档的惟一要求就是对标签和锚点应用特定的样式：
          * 锚点样式：在关键字两边加上“*”号和空格表示一个锚点；另外，关键字不能包含空格；如： *vim:* 。
          * 标签样式：在关键字两边加上“|”。如：|vim:|。 
   2. 在文档的最后插入modeline。这是可选步骤。
   3. 在文档中使用了上面的规则后，用:helptags .生成tags文件。
   4. 使用:tag等命令访问文档 

下面是一个完整的（但无用的）Vim格式文档，看完大家就知道怎么一回事了。

*花花幼儿园班级手册.txt*
	
*小明*
是个很乖的小孩。他跟|小强|是好朋友。
	
*小强*
是个聪明的小孩。他跟|小丽|是同桌。
	
*小丽*
是个可爱的小女孩。她跟|小明|是邻居。
	
vim:set ft=help: 使用Vim文档的高亮配置

将上面的文本保存.txt文件。现在使用这条命令生成tags
:helptags .

使用tag命令打开文件（不知道为啥使用中文标签有时会失败——虽然补全可以补出来。使用正则语法，也就是标签前加一个“/”可以增加成功率）
:tag /小强

需要的话，你还可以将这个文件整合到Vim的文档中，这样你可以通过:h命令访问自己的文档。方法一是直接将你的文档复制到vimfiles下面的doc目录下，然后重新运行:helptags。这种方法简单但是你可能不想让自己的文档跟其他的文档混在一起，这时候你需要用方法二：首先新建一个名为 “doc”的目录——必须命名为doc，将你的文档放进去，doc目录可放在任何你觉得合适的位置。假设目录的位置是：/foo/bar/doc。使用:helptags生成tags。最后在vimrc中加入一行：

let &rtp=&rtp . ',/foo/bar'

上面这一行脚本将doc的上级目录加进Vim的runtimepath中（:h 'rtp'），只有这样:h命令才找得到你的文档。如果你的路径中有空格记得加上“”。

你当然不会将“花花幼儿园班级手册.txt”整成Vim的帮助——我也不会。这个技巧的价值依赖于应用的场合。我用Vim写gawk脚本，所以我想如果 gawk的文档也能用Vim的线上文档系统打开的话那会方便得多。当然这是完全可以做到的，只要依照Vim的格式，在gawk文档中插入适当的锚点。这只需要一些自动替换加上少量手工调整。这样我可以在任何时候输入:h GWK-dcngettext()查询gawk函数dcngettext的细节。如图所示：

vim_tut_gwk_help

这样做的好处是你在写awk脚本时可以随时查看gawk文档——就像查看Vim文档一样。




4.2 exuberant ctags

说到tags的应用当然要谈到ctags工具。ctags工具预先定义了一组用来抓tags的规则。这样我们在写程序时可以使用tags的便利特性，而不用花时间收集tags——ctags会帮我们做。ctags类软件的操作方式大同小异，exuberant ctags1是最流行的版本。接下来讲的ctags指的就是exuberant ctags。我们将扩充ctags使之支持我们的应用。

ctags支持的语言非常多可以使用下面命令查看：ctags –list-languages。2最常见的用法是：ctags -R *。这条命令在在当前目录及子目录中找文件并生成tags。ctags根据扩展名判断所使用的语言。但即便ctags支持众多的语言，还是有许多语言，如 Smalltalk, D, Rebol, Haskell, Basic或者你新开发的语言等不在ctags的支持之列。因此，你需要学会扩展ctags的语言以便让Vim（或者其他用到tags的工具）的功能可以被利用起来。

    关于ctags的祥细信息可以在下面的链接中找到：
    ctags手册 里面包含有使用这个工具的祥细信息。
    为ctags增加语言支持里面介绍了如何扩展ctags的语言支持（包括从源码上增加语言）。 

步入正题，让我们先了解一些定义新的语言需要用到的“选项”：

`–langdef=<lang>‘
    告诉ctags，你要定义一种新的语言。如: –langdef=texinfo
`–langmap=<lang>:<ext1>[<ext2><…>][,<lang2>:<ext…>]‘
    将该语言与特定的扩展名关联起来。如：–langmap=texinfo:.texi.texinfo将扩展名“.texi”与“.texinfo”都关联到新定义的语言“texinfo”
`–regex-<lang>=/regexp/replacement/[kind-spec/][flags]‘
    <lang> 部分放上新定义的语言的名称。“regexp”是用来抓锚点的正则表达式，而“replacement”部分定义了与锚点对应的标签。这一部分的语法与 Vim的:s命令一样，只是正则语法上有些区别。比如， 用这个正则 /classW(foobar)/1/ 抓锚点“class foobar”后，可用标签foobar引用该锚点。“kind-spec”可以设定该tag的“kind”项，See kind, Taglist插件用kind项的值对tag进行分类。“flags”指定所使用的正则版本及是否区分大小写。默认使用扩展的正则表达式（Extended Regular Expression）即egrep所使用的正则语法。加上b可使用基本的正则语法——grep的默认的正则语法。加上i，则不区分大小写。如：–regex-texinfo=/^@chapterW+(.+)$/1/c/ 

下面是一个完整的例子。我们会为ctags增加VBScript的支持。3 我们的目的是在看到某个函数时可以方便地跟到定义该函数的地方。为此我们需要抓函数的定义作为锚点，以函数名为标签。明确了目标后剩下的就是写正则表达式了！

    在这一节写作过程中，我想到可能已经有人写过了这方面的内容，然后找到了这个：ctags增加VB支持。总的来说它VBS与VB的语法相似，正则也相近，除了VBS要简单得多。考虑了许久为了文章的完整性还是留下这一部分的内容，而不是只留下链接。 

如果你不熟悉VBScript的话，先看一下VBS中定义函数的两种方法：

' 无返回值的以Sub关键字定义函数，没参数的话可以不加括弧
Sub mysub(argument1,argument2)
 ' 语句放在这里
End Sub 
	
' 有返回值的以Function关键字定义函数
Function myfunction(argument1,argument2)
 ' 语句放在这里
 ' 返回值是字串foobar
 myfunction="foobar"
End Function

对于这两种函数，我们在抓tag时候将它们的kind分别设为s和f，分别表示subroutine和function。使用这个式样就可以抓大部分的sub锚点了/sub +(w+)/1/s/i，但我们需要考虑到一些特殊的情况，而且5.6之前的ctags不支持w字元。这是完整的命令：

:: 在命令行中使用时如果正则中含有空格需要用引号括起来（Linux用单引号，Windows双引号）
ctags --langdef=VBS --langmap=VBS:.vbs --regex-VBS="/^[ t]*sub[ t]+([a-z][a-z0-9_]*)/1/s/i" --regex-VBS="/^[ t]*function[ t]+([a-z][a-z0-9_]*)/1/f/i" *

但我们不希望每次都使用这么长的命令，而且实际使用时我们可能需要抓更多锚点。我们将选项放到单独的文件中，像这样：

--langdef=VBS
--langmap=VBS:.vbs
--regex-VBS=/^[ t]*sub[ t]+([a-z][a-z0-9_]*)/1/s/i
--regex-VBS=/^[ t]*function[ t]+([a-z][a-z0-9_]*)/1/f/i

然后，使用这条命令（将options.txt改为相应的路径与文件名）：

ctags --options=options.txt *

现在，在编辑VBScript的时候你也可以使用tags的功能了。不过你可能还希望让taglist也支持VBScript（或者其他你新定义的语言）——这是下一节的内容。




4.3 增加taglist支持

Taglist确实是很好用的Vim插件。我们将对它进行适当改造使之支持我们新定义的语言。在ctags中定义完语言后。你需要：1. 下载安装taglist。2. 修改taglist，一些情况下还要修改Vim的filetype设置。3. 使用。

仍以VBScript为例，这是修改的步骤：

首先，在taglist的安装目录中搜索“s:tlist_def_{vim_ftype}_settings”。这里是taglist定义不同文件类型，对应的类型的地方——因为kind项的那个字母，在不同文件类型中有不同的含义。我们定义的VBS的kind（类型）有两种s和f表示 subroutine和function。往下翻可以找到这一行：let s:tlist_def_awk_settings = 'awk;f:function' 这是awk的定义，意思是如果Vim设置的filetype为awk的话，那就将f解读为function。我们依葫芦画瓢：

let s:tlist_def_VBS_settings = 'VBS;s:subroutine;f:function'

这里是最容易出错的地方，这边的{vim_ftype}既要与ctags里定义的语言名称一致（也就是VBS），同时也要与Vim中的filetype一致。Vim中*.vbs的filetype是vb而不是单独的VBS或VBScript。所以，你要么需要改变*.vbs的filetype为单独的VBS，使用Vim能识别VBS的文件类型。要么更改变前面ctags中定义的语言名，也就是将VBS全部改为 vb——这样就不需要修改Vim的filetype定义。这里我选择前者，因为VBS与vb还是差别挺大的。

所以，在$VIMRUNTIME/filetype.vim中查找：

au BufNewFile,BufRead *.vbs,*.dsm,*.ctl		setf vb

并改为（注意大小写），

au BufNewFile,BufRead *.vbs,*.dsm,*.ctl		setf VBS

其次，在taglist中搜索：

let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '

并增加–options=options.txt，记得将options.txt改为实际的路径名和文件名。改完后像这个样子（注意字串前后都要留有空格）：

let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks --options=options.txt '

大功告成。现在你可以在VBScript中使用taglist了。试一下，……语法高亮没掉了。没事，将$VIMRUNTIME/syntax/vb.vim复制为vbs.vim就可以了。




4.4 生成导航窗口

在折叠篇我们用了一个唐诗的例子。在上一次我们使用折叠让显示更紧凑一点——就像是目录，我们只要点击一首诗就可以查看内容。但我们现在还是遇到了问题，我们收集的诗越来越多，为了管理方便我们把它们放在不同的文件中。只是这样一来我们没办法在同一个视图中查看所有的诗。

这次我们不仅要利用tags方便地在不同文件不同诗之间跳转，我们还要利用tags做一个导航窗口出来——这样我们只要双击某首诗的标题就可以在另一个窗口显示该诗。

《感遇其一》
作者：张九龄
兰叶春葳蕤，桂华秋皎洁。
欣欣此生意，自尔为佳节。
谁知林栖者，闻风坐相悦。
草木有本心，何求美人折？
	
《感遇其二》
作者：张九龄
江南有丹桔，经冬犹绿林。
岂伊地气暖，自有岁寒心。
可以荐佳客，奈何阻重深。
运命唯所遇，循环不可寻。
徒言树桃李，此木岂无阴。

我们选择标题作为锚点。因为所有的标题都含有《》很容易从这些锚点抓出标签。

" 一条简单的命令就可以从单个文件中抓取这种形式的tag
" 因为不需要编辑可以直接使用行号表示位置
g/《/ echo getline('.') ."t". expand('%') ."t". line('.')

生成的tags：

《感遇其一》	唐诗1.txt	1
《感遇其二》	唐诗1.txt	8

但我们希望在tag中增加作者的信息——这正是用ctags做不到的，同时要能处理多个文件：

" vim7 脚本
" 抓取当前目录下所有.txt的文件名，并逐一传给变量f
for f in split(glob('*.txt'),'n')
  " 以只读方式打开一个文件
  exe 'view '. f
  " 保存以下操作的输出到tags文件
  redir >> tags
    " 抓取如下格式的tag：{标签}	{文件.txt}	{行号};"	author:{作者}
    g/《/ let nl = getline(line('.')+1) |
       let author = (nl=~'作者：' ? substitute(nl,'作者：','author:','') : '') |
       echo getline('.') ."t". expand('%') ."t". line('.') .';"'."t". author
  redir END
endfor
" 任务完成
qa!

在shell/命令行使用这条命令，

" 将xxx.vim换成脚本的名称
vim -S xxx.vim

这将会在当前目录生成如下内容的tags：

《感遇其一》	唐诗1.txt	1;"	author:张九龄
《感遇其二》	唐诗1.txt	8;"	author:张九龄
  ...

    事实上这个例子中用gawk或perl会更自然也更方便（虽然Vim脚本也不长，但操作起来步骤比较烦琐），而且快得多。记住，Vim的用户总是选择合适的工具完成工作——这同样也是我们选择Vim的理由。 

现在我们有所有诗的tags了。现在用Vim打开tags文件。在任一首诗的标题上按CTRL-]就可以转到相应的位置。再按CTRL-T回到tags文件——似乎这样就可以收工了。

不过我们有一些附加的要求，我们希望能控制导航窗口的行为和内容。首先，这个导航窗口应该是持续打开的。其次可以使用双击在其他的窗口打开一首诗（而不是在导航窗口中）。最后，要能按我们的格式显示导航的内容。这需要20行左右的Vim代码：

" 用来更新目标窗口内容及更新目标文件名的函数。
" 当双击或者输入CTRL-]时调用这个函数。
function! SToc(tag)
  " 高亮标题
  exe 'match Todo /%' . line(".") . 'l/'
  " 获取目标窗口当前的编号
	let nr=bufwinnr(bufname(g:xbn))
  " 跳到目标窗口
	exe nr."wincmd w"
  " 在目标窗口中打开tag
	silent! exe "tag " . a:tag
  " 更新目标窗口中的文件名（全局变量）
	let g:xbn=bufname('%')
endfunction
	
" 负责初始化的函数
function! IToc()
  " 如果当前编辑区无文件，则打开一个临时窗口
  if bufname('%')=="" | view _blah_  | endif
  " 初始化全局变量，这个变量用来跟踪当前编辑区的文件名
	let g:xbn=bufname('%')
  " 打开一个窗口并做导航
  vsp __目录__
  " 不需要实体文件
  setlocal buftype=nofile
  " 简单的语法高亮
  syn match Comment "[^-]"
  " 从tags读取信息并转换成“用户友好”的格式显示
  call append(line('$'),
    map(taglist("^"),
    'substitute(printf("%-30s%s",v:val["name"],' .
    '(has_key(v:val,"author")?v:val["author"]:""))," ","-","g")'
    ))
  " 定义导航键
  map <2-LeftMouse> :call SToc('/'.expand("<cword>"))<CR>zt
  nmap <C-]> <2-LeftMouse>
endfunction
	
" 定义打开导航窗口的命令
command! -nargs=0 Toc call IToc()

    这20行脚本中有几个写Vim程序常用到的技巧。首是多个窗口的管理控制。其次是建立临时文件。还有taglist()函数的使用。最后是用command命令建立宏（command 的好处是可以使用参数，不过这里没有用到。） 

将脚本保存起来，用下面的命令运行

" 用下面的命令载入脚本，将xxx.vim改为实际的文件名
:so xxx.vim
" 使用这条命令打开导航窗口
:Toc

也可将脚本放到plugin目录下，这样只要随时输入:Toc就可以开始阅读了——当然，必须确保tags文件在'rtp'或当前的目录中。现在我们可以使用导航窗口中使用双击打开任意一首诗了……

vim_tut_poem

你可能会好奇为什么我们要大费周章写这样的一个创建导航窗口的脚本呢？在我们最初的版本中，我们只用了:g命令就生成了第一个tags文件。在第二个版本中我们使用脚本在tags文件中增加了额外的信息（作者/诗人）。我们只需要在Vim中打开tags文件就可以实现导航。但我们想要控制显示的内容，而 tags文件只需要在后台控制跳转。为此我们写了上面的脚本。在使用tags做导航时，我们需要控制显示在导航区的内容——而这一是实现更复杂应用的基础。附图是一个查看邮件的应用，是基于同的的技巧实现的。
vim mail reader
5 小结

tags的作用无非是帮助Vim查找定位跳转，但同样是跳转在不同的应用下起的作用也不一样：

    * 在文档或文档之间的不同部分建立连系。例如我们可以在一个文件的底部放上其他文件的标签，让用户方便地移动，就像是网页的“上一页”“下一页”。
    * 提供交叉引用。方便用户使用参考。如同Vim的文档，每一个词条对应着该词条的解释。最更要的也许是：无论是使用ctags还是其他工具，只要能找到自动生成tags的规则，我们就不需要人为的维护不同文件之间的关系了。这在Vim文档的例子中尤为明显——写Vim文档时只要遵循约定，Vim就能自动维护文档之间的引用关系。手工维护这些交叉引用是不可想像的。
    * 为文档建立结构图或导航图。就像前面唐诗的例子所展现的一样。
    * 特殊应用。作为补全的匹配源；信息汇总，等等……比如，抓一个网页的所有链接，再集中显示在一个新窗口。 4 

在文档间建立联系或提供交叉引用都是只要有tags就可以，而显示结构图或导航图则需要一点额外的努力——因为我们需要多开一个窗口。这种情况下应首先考虑taglist是否能做为现成的方案。

tags 能起什么作用取决与tags文件都有什么内容。因为生成什么样的tags才是决定tag功能的关键。如果出于编程的需要而用tags的话，那可能已经有某种ctags程序支持你所用的语言了。否则你可以用ctags的定义语言功能为某种语言生成tags文件。在一些应用中我们可能需要Vim或 awk，perl这类工具生成一些特殊的tags。但总的来说无论使用哪种工具都是关于正则表达式的运用。

Footnotes

[1] exuberant ctags != etags

[2] 较早的版本会直接显示支持的语言在帮助中，只要输入：ctags –help。就可以在最后的部分看到–{language}-types=…

[3] 为什么是VBScript？我们需要在ctags不支持的语言中找一种语法简单方便讲解，而又相对为人所知的语言做例子说明——其实选择不多。

[4] 在HTML文档中使用taglist时，会显示所有锚点的name
http://blah.blogsome.com/2007/08/04/vim_tut_tags/

22 10, 2010
外部程序::Vim进阶索引[6]
作者 helloxchen 12:48 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
外部程序::Vim进阶索引[6]
Table of Contents:

    * Vim进阶索引[6]::外部程序
    * 1 使用外部程序的Vim命令
    * 2 !命令
          o 2.1 !的两种使用风格
          o 2.2 实例 
    * 3 相关议题
    * 4 小结
    * Appendix A 



Up: (dir)

Vim进阶索引[6]::外部程序

    Windows 的用户可能会因为这一篇里面用了大量的Unix工具而倍感沮丧。但大可不必如此，这一篇里面我们更多的是讲一种使用Vim的理念──用户可以依据自身对外部工具的掌握程度适时地使用这些工具来减少工作量。常的工具都可以找到对应的Winodws版本，而且通常很小。 

unix 工具箱哲学的一个核心思想是每个工具只完成各自相对简单的任务，这些工具的真正威力来自于它们之间关系。你可以组合这些工具来完成复杂的工作。Vim虽然是一个交互式的编辑器，但这种思想仍在它身上得了很好的体现。它能很好地与其他工具配合来扩展功能或完成相对复杂的编辑工作。

这一篇教程我们将讨论与Vim中与外部程序有关的议题。



1 使用外部程序的Vim命令

Vim中有一些功能是通过外部程序来实现的。比如:make命令，Vim没有内置make工具。但是用户可以为:make命令指定一个外部程序，比如：gnu make或Windows下的nmake。这样我们在Vim中就可以使用:make命令了。设置make工具所用的设置项是'makeprg'。我们先看一下跟外部程序有关命令和其对应设置项。

:cscope

    * 设置项：'cscopeprg'
    * 说明：cscope是c/c++的源代码分析工具。'cscopeprg'默认设置即为“cscope”。要使用这项功能除了在编译时+cscope外，还要求系统上已安装了cscope类的程序。:cscope命令在Vim有一个专有的运行介面和选项，只适用于cscope或类似的工具。cscope虽然是为c/c++而生的，但存在着许多类似工具。如果在Vim的搜索路径或在系统的路径上只要将相应程序的名称传结csprg，否则必须写上完整路径。
    * 用法：在vim中使用这条:cs命令之前需要先在命令行下运行cscope生成数据文件。然后再在Vim中使用:cs add载入数据文件。输入:cs可看到在线帮助。当然还可以*cscope*。详细用法见文档。 

=

    * 设置项：'equalprg'
    * 说明：=这是条一般模式下的过滤命令。用来对c程序进行缩进。在缺省的情况下，这条命令用来进行C缩进。通过对'indentexpr'进行设置我们还可以决定缩进的方式。 

gq

    * 设置项：'formatprg'
    * 说明：这也是一条一般模式下的过滤命令，用来整理段落。缺省情形下使用内建的功能重排段落，可以通过调整，'tw''formatoptions'等项细化重排功能。缺省情况下调用Vim内置函数进行格式重排。 

:grep

    * 设置项：'grepprg'
    * 说明：grep查找文本，并返回结果（到错误列表中）。正如它的名称一样这条命令的作用就是跟!grep是一样了，因为在Unix下它就是调用grep程序 ──除了一点：Vim会为:grep命令生成一个窗口和匹配列表。用户可以在结果文件中跳转。Unix下默认设置为"grep -n"，Win32环境中默认设置为"findstr /n"。相关的设置项有'grepformat'，缺省下不需要设置。 

:make

    * 设置项：'makeprg'
    * 说明：写程序的话对这个应该不会陌生。默认情况下设置为make。这条命令在Vim中运行各种的make类工具。而它存在的理由和grep一样，Vim中我们可以通过结果方便地导航（通常是在“出错”的情况下）。 

K

    * 设置项：'keywordprg'
    * 说明：这是个一般模式命令用以运行查找Vim文档或man的命令。这条命令的特别之处在于传递参数给外部程序的过程将由Vim自动完成。它将当前“词”做参数传给'keywordprg'。缺省情况下，使用man（Unix）或内置的:help命令（Windows）。相关的设置项有：keywordprg iskeyword 

:shell

    * 设置项：'shell'
    * 说明：Linux下一般是根据环境变量`$SHELL‘或设置为`sh‘。Win32下默认设置为`command.com‘或`cmd.exe‘。如无特殊说明这一系列教程中所使用的命令解释器分别为Linux下的`sh‘（或`bash‘）和Windows Xp下的`cmd.exe‘。这个命令涉及的还有外部程序和脚本的使用!，所以无特殊需要最好不要改动。我们在Vim中的:sh命令，!过滤命令等都是通过shellprg 的设置来运转的。

      Linux下一般是根据环境变量`$SHELL‘或设置为`sh‘。Win32下默认设置为`command.com‘或`cmd.exe‘。如无特殊说明这一系列教程中所使用的命令解释器分别为Linux下的`sh‘（或`bash‘）和Windows Xp下的`cmd.exe‘。这个命令涉及的还有外部程序和脚本的使用!，所以无特殊需要最好不要改动。 

提示：这些设置的一个共同点是它们都不能在模式行中进行设置。出于安全的原因在模式行中不能使用这些设置项。

Vim 的Diff模式就是使用了工具GNU diff，这个程序是Vim的重要组成，Vim并未提供相应的设置项让用户更改。与vim相关的外部程序还有ctags类的程序，这类程序用来生成关键字的索引。但Vim用到的是tags文件所以也没有提供相应的设置项。（即使要生成tags，ctags也不是必需的）

这些就是使用或可设置为外部程序的命令。总的来说这些命令在某些方面提供了方便。但从功能性来说它们并非是必不可少的。不过既然有了我们还是利用起来吧。

由于这些命令的特性我们可以用来做一些有用的事情，现在来看一下我们还能怎么用这些命令。

=
gq
    这两条命令都是在一般模式中使用的过滤命令（一般的过滤在行模式中使用）。它们的工作方式都是一样的：对一定的范围使用过滤程序/内部命令，所以我们放在一起。通过指定合适的过滤程序我们就能决定这命令的作用。
    比如：设置为sort可以用来排序`se equalprg=sort‘，设置为`se equalprg=sort|uniq‘，排序并去除重复。
    总之任何过滤程序都可以在这里使用──而决不仅仅可以使用缩进或文本格式化的工具。
K
    与前面两个命令不同，这个命令的目的并非改变当前文本的内容或格式。这个命令以当前字为或选区(至多一行)为参数运行命令 。自动传递参数给相应的程序。利用它自动传递参数的特点我们可以运行一些需要参数的程序。
    除了用来查找Vim文档，man文档外最直觉的一个用法就是用来查字典了。只要是以一个字词为输入的所有程序都可以定义为'keywordprg'。如：stardict、locate、which等。

    下面是用K来运行当前圈选1的网址的例子（windows平台）：

         se kp=start c:progra~1operaopera.exe

:grep
:make
    这两条命令的真正有用的/有效的特性在于Vim可以根据运行的结果生成quickfix窗口。而且你可以用:cn, :clist, cw…等quickfix命令在不同的位置间跳转。要用好两条命令首先要了解这两个设置项：grepformat errorformat。这两个设置项的作用是捕捉并分析输出。在使用make工具时由于在使用不同编译器时输出的错误信息的格式也不尽相同，所以在设置好了grepprg或makeprg后还要教它“读懂输出”。

    在缺省情况下Unix平台的Vim的'grepprg'是'grep -n'而Windows下则是'findstr /n'，不过它们运行的结果都一样。假设你是命令行下（shell中）用前面的命令在当前目录查找：grep -n goes *.txtl，返回信息是以下面的格式出现的：

         a_text_file.txt:52: something goes here .........

    这条信息中包括了：文件名a_text_file，行号52，该行的内容共三个部分。这三个部分是由:隔开的。
    我们再看一下缺省情况下的gfm：

         :se gfm?
         grepformat=%f:%l:%m, ....

    同时设置的多种不同格式的grepformat间用,隔开。其中%f、%l、%m分别表示文件名，行号和提示信息（这个例子中就是该行的内容）。中间的:是帮助对应不同部分的关键，Vim在输出的信息中查找:并将冒号分隔起来的三个部分与gfm中的三部分对应起来。这样我们是Vim中使用grep后，它就能自动解读输出的信息并带我们到不同文件的特定行去了。要了解%f、%l等更多占位符的意义及用法见*error-file- format*

    提示：在Vim中通过程序的输出信息，使用cn cl cw等命令在文件中快速移动的这一特性称为quickfix。使用quickfix时，文件名是必需的——这样才能打开正确的文件，有行号的话更好——精确地定位到行。

    可以看到在设置好程序的前提下，要用好这两条命令的关键是设置好合适的gfm/efm。Vim文档中提供了相当多的现成的gfm和efm，几乎含盖了各种类型的编译器。所以在你设置"合适的gfm/efm"之前先看一看有没有现成的。

    这里再来看一下makeinfo的输出格式，

         somethingwrong.texi:5: Unknown command `blah'.

    与我为它设置的“错误信息格式”：

         se efm=%f:%l: %m
         se makeprg=makeinfo

    很眼熟不是？它跟grep是一样的只是刚才的查找结果现在成了“错误信息”，本质上:grep跟:make是一样的。除了命令名称和设置项名称的不同它们的其他地方是一样。在设置这些后我只要使用:make，Vim就会带我到出错的行去——如果有错的话。

    提示：se makeprg=makeinfo这条命令不是必需的，你可以将命令放到makefile中，然后使用make工具。当然直接用makeinfo编译文档还是使用make工具由你自己决定。当然efm是要设置的。同样的还有tex文档，你一样可以使用make工具但efm要设置正确。

    这两条命令的作用可不仅局限于使用各种make工具或grep类工具。想想下面的设置会产生什么样的效果：

         :se gfm=%f
         :se grepprg=find

    上面的设置让你可以快速定位特定的文件并打开。将find改为ls就有了一个简易的Explorer插件了。

    看到下面的命令，你可能会一头雾水，

         :se grepprg=cat
         :se gfm=%f
         :grep blah.txt

    但如果你知道blah.txt有着下面的内容后，你就会知道了——这是个项目文件。

         farsi.c
         farsi.h
         feature.h
         glbl_ime.cpp
         proto/buffer.pro
         proto/charset.pro

    再想一下如果blah.txt的内容是一些网址，上面的命令又会产生什么结果？就像这样：

         ftp://ftp.vim.org/pub/vim/
         http://sf.net/

    动手实验一下，然后:h netrw。

    最后提供用来调试sed/awk脚本用的'efm'：

         " sed
         se efm=sed: file %f line %l: %m
    	
         " awk 仅限于使用脚本文件时。
         se efm=awk: %f:%l: %t: %m

对于make和grep的设定可以在ft文件中设置或是在vimrc中使用au(:help :autocmd)进行设置。K,gq,=的功能也可以用map的方式来达到（这就是它们并非必不可少的原因），并且map也带来了灵活性。但使用keywordprg你不能指定Vim的内部命令，同时使用外部命令时map通常意味着更复杂的设置过程。有利有弊。

另外，Vim处理make和grep和cscope的方式是内建一个命令的接口(quickfix)，要达到同样的效果又需要用户写相当长度的脚本。可以说这点来说使用内置的接口还是要方便些的。

尽管我们可以通过这些Vim命令灵活地使用外部程序，但Vim与外部程序的互动更多地来自:!命令。



2 !命令

    Vim 为用户提供了极大的可能性，让用户可以自由的操纵他们的文本。尤其是通过内置的脚本解释器，用户只要写Vim脚本就可以扩展Vim的功能。但是Vim知道大量经得住时间考验的Unix工具如果闲置起来就太可惜了。通过提供方便的接口，Vim在保持体积小巧的同时也让用户有选择的余地。 

Vim的插件机制是以两种方式实现的：一是通过内置的脚本解释器。一是通过保留与外部程序协作的接口。本篇我们会看看如何在Vim中使用外部程序或shell脚本。

一般而言我们可以通过使用多个软件来满足我们的特殊要求：先用A程序处理一部分保存，再由B程序接着处理，……但是Vim提供的接口让我们在使用外部程序就象在使用内建的功能一样方便快捷，你不必在程序之间来回切换。

Vim调用外部程序主要是通过!实现的。!命令可以在行模式下也可以在一般模式中使用。带地址/范围地使用这条命令时（即作为过滤命令时），当前地址范围内的内容会被命令的输出所替代。否则只是在shell中运行该命令。详细用法见：! 和 :! 。

在你决定花点时间写Vim脚本前也许你应该先考虑以下这几个问题

    * 我需要什么样的结果？
    * 有这样的外部程序存在并且能更好或更简单地满足我的要求吗？
    * 最后就是你对哪种方式（Vim脚本或外部工具程序）更熟悉。 

比如你可能在整理一份软件列表，你需要某个目录的文件列表。毫无疑问你会选择用外部程序（或命令）：

:r !dir ...
:r !ls ...

这是另一种情况，你要将文本区中每一行文本复制一行在该行下面，你可以使用下面的任意一条命令：

%!sed p
g/^/norm Yp

使用两命令看上去没什么差别你只需要照自己的习惯来决定使用哪条命令。但如果你要对文本排序或是更复杂的工作呢？这时写Vim脚本会是很累人的工作。
2.1 !的两种使用风格

! 命令在shell中运行命令，所有能在命令行中运行的程序/工具都可以。对Linux来说这代表了几乎所有的可执行程序都可以从vim中启动运行。而 Windows中则与路径的设置有关，但通常来说在windows目录下和system32目录下的程序都可以直接在Vim中运行。此外还有命令解释器的内部命令。能在shell中运行的程序脚本或批处理文件都能在Vim中使用。但我们可以作一些简单的分类。
在Vim中使用命令不外乎有两种情况。

   1. 是把Vim当成一个shell接口（这种情况下要注意命令参数中的特殊字符。见*cmdline-special*）。如

           !touch abbcc
           !rm abbcc

      当然你也可以运行图型介面程序：

           " 用Opera预览效果
           !opera %
      	
           " 或者你想要后台运行firefox
           !firefox % &

      简单说这种使用方式就是把Vim当成shell用。但是在Vim中方便地运行其他程序不是我们的首要目标。Vim是一个编辑器，所以我会着重在编辑相关的内容──就是下面要讲的第二。
   2. 是为了获取程序的输出。又可细分为两种。过滤程序（filter）产生的输出；非过滤程序的输出。
          * 获取非过滤程序的输出。前面的读入目录的命令就是在Vim中使用非过滤命令的例子，这里再举几个例子：

                      r !date         "当前行下插入日期
            	
                      " 在当前位置插入脚本运行时间的测试结果
                      .!time myscript 
            	
                      " 运行用户的shell脚本或批处理程序，并获取输出
                      r !myshellscript
                 

            能够在命令行产生某种输出的程序（批处理/脚本）都能与Vim配合（如前面例子中的date），而其中一些从stdin读取数据处理后输出到stdout的程序，即filter程序，在Vim中的应用范围要更大一点。相对而言一个图形介面程序在这种情况几乎毫无用处可言，无法在命令行下运行也就代表着难以与其他程序配合。因为当一个程序在处理的结果是在对话框中显示的话，表示这个结果无法直接为Vim所用。我们必须至少要经过一个复制粘贴的过程:-(
          * 获取过滤程序输出。与非过滤程序不同的是过滤程序对给定范围内的文本进行“加工”，然后才产生输出。下面是一些使用过滤命令的例子。

                      " gggqG
                      %!fmt
            	
                      " 选择打印部分“列”数据
                      8,20!cut ..
            	
                      " 删除选区中的重复行，改变次序
                      '<,>'!sort |uniq 
            	
                      " 同上，但不改变行的次序
                      '<,>'!awk '{if ($0 in a) next}{a[$0]++}8'
                 

Unix下有相当多丰富的过滤程序资源，Windows下这类的工具较少(sort、more和findstr)。好在Unix下的最好的命令行工具（尤其是Gnu版本）通常都有Windows版本。它们通常很小——可以在这里下载。其中最强大的两个工具是awk、sed和CoreUtils工具包，稍大一点的选择是perl。
2.2 实例

由于这一篇更多地是涉及到工具软件的使用而非Vim本身，所以不会对这些例子进行很详细的解说。这里演示一下实际应用中外部程序的用法。这一次仍是以成绩单为例，这是其中的三条数据：

姓名    期中  期末
李阿月  72    70
林小丽  91    93
王小明  46    56

共三栏栏与栏之间用一个或多个空格隔开。

看一下外部命令是如何逐一完成任务的，思考一下用纯Vim的方式要怎么达到同样的目的。

   1. 首先是成绩单排序。按期末成绩，然后期中成绩：

           :2,$!sort -k3n -k2,2n

   2. 根据前面排序的结果，写上排名（在Unix上可以输出序号的工具很多如nl cat等，不过这次我们要用的是grep）：

           " 工具之间也可以协作
           :2,$!grep -n .|tr : ' '

   3. 计算平均成绩。在寄存器篇中我们用了下面的命令来更新目录中的行号：

           :1,25s/[0-9]+$/=submatch(0)+25/

      我们可以用同样的方式计处平均成绩，但Vim不支持浮点运算。
      而成绩通常会精确到0.5，所以我们使用了下面的脚本：

           :2,$!gawk '{$0=$0 "  " ($3+$4)/2}8'

   4. 如果我们打算在下面增加一栏计算总人数。总平均成绩，用Vim脚本就没那么容易了。

           :2,$!gawk '{sm+=$2;sf+=$3}8;END{print "人数：" NR " 期中平均：" sm/NR " 期末平均：" sf/NR}'

   5. 我们还能在成绩单后加入简单的统计，

           :2,$--!gawk -f myawkscript.awk

      上面的命令后会在成绩单后面加入下面的内容：

           -- 期末考成绩分布图示 --
           优	4人	%16■■■■
           良	8人	%32■■■■■■■■
           ....

      提示：对myawkscript.awk有兴趣的话可以见附录。
   6. 导出为CVS（这样就方便在其他数据处理分析工具中打开）：

           " 选择要导出的范围，然后输入……
           :'<,'>w !tr -s ' ' , >成绩.cvs



3 相关议题

    * 要以某一部分的文本，如圈选区的文本作为某个外部程序的输入但又不捕捉该程序的输出要怎么做呢？我们需要用到:w命令，格式如下：

           :3,5w !cmd

      我们前面导出为cvs用的就是这种方法。
    * 很多情况下我们需要在Vim脚本中运行并捕捉外部程序的输出。这时我们可以用system()函数（*system()*）。

           :let files = system("ls")

      上面的例子是文档中带的例子。看了这个例子大家应该就知道这个函数的用用法了。



4 小结

Unix的这些工具软件有着比Vim脚本更多的应用，对于个人的使用目的来讲写Vim脚本不应做为首选。别忘了从Vi诞生之始开始工具软件就一直是扩展Vi功能的主要途径。充分利用现有的外部程序资源一直是用好Vi的关键之一，除了节省大量时间外，使用对的工具正是Unix风格的一贯体现。如果你使用Linux/Unix的话花点时间在这些工具上会是很好的投资。

最后一点补充：在写完这一篇后，我才发现关于!的部分的篇幅与其在实际应用中的广泛和重要程度完全不符（这当然是因为我前面说过的“这更多是涉及外部程序和而非Vim的使用）。所以我想我得说明一下：对于相当一部分的老手来说!是他们解决一些棘手编辑问题的第一个选择，其次才是脚本。而其中有些人（尤其是perl老手）根本不愿意写超过5行的Vim脚本。
Appendix A

myawkscript.awk的代码：

# /usr/bin/gawk -f
# 从期末成绩计算各成绩段的人数、比例及图示
	
# 计算各成绩段的人数
{$3>=90?++a[1]:$3>=80?++a[2]:$3>=70?++a[3]:$3>=60?++a[4]:++a[5]}
	
# 显示输入的数据
8888
	
END{
split("优 良 中 及 不",rank)
print "n-- 期末考成绩分布图示 --"
# 显示统计信息
for(i=1;i<=5;i++){
    if(a[i]=="")a[i]=0
    printf "%st%d人t%d%%",rank[i],a[i],a[i]*100/NR
    # 显示图示
    while(a[i]-->0)printf "■"; print ""
   }
}



Footnotes

[1] 通过自定义一个识别网址的脚本，可以省略圈选的步骤。不过这是题外话了。
http://blah.blogsome.com/2006/06/27/vim_tut_bang/
-->

22 10, 2010
高亮::Vim进阶索引[5]
作者 helloxchen 12:46 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM

    * 高亮::Vim进阶索引[5]
    * 1 环境配色
          o 1.1 使用预置的配色风格
          o 1.2 修改环境配色 
    * 2 语法高亮
          o 2.1 修改当前的高亮设置
          o 2.2 定义新的高亮
          o 2.3 写语法文件 
    * 3 :highlight命令详解
          o 3.1 命令行下的颜色设置
          o 3.2 显示样式
          o 3.3 关于link 
    * 4 综合
          o 4.1 高亮tags
          o 4.2 生成web色索引
          o 4.3 其他应用 
    * 5 小结 

Vim进阶索引[5]::高亮

    与以前的教程相比，这一篇做了一些小改变：使用了缩写而不是每次都给出完整的命令。提示使用文档时不同给出完整的命令而是给出“关键字”——你可以用“:h 关键字”的方式找到Vim文档中的相应内容。
    –
    hq00e 

在语法高亮相信大家在使用Vim的文档时就已经见过了，Vim提供了一个测试用的脚本。输入下面的命令：

   :e $VIMRUNTIME/syntax/colortest.vim
   :so %

这个脚本除了让你知道Vim是可以显示许多颜色的外，它还是一个实时定义颜色的脚本实例。在本文的末尾我们会用同样的技巧生成一个Web色表。

Vim中与色彩有关的设定大致可以分为两部分：

    * Vim编辑环境配色。如Vim编辑区的前景背景颜色（文本的默认颜色）、状态栏颜色、错误提示颜色、光标、圈选区（可视区）、行号、折叠的颜色等。这些都属于编辑器的环境设定。
    * 文件使用的所使用的色彩。即所谓的语法高亮/语法着色，如Vim文档中索引标签使用粉红色，示例使用蓝色、链接使用青色。或是当你打开C语言文件时，注释蓝色、数据类型青色、字串粉红、关键字赭色。都是Vim根据文件类型启用相应的语法文件，对该应用颜色的部分进行识别并着色。 

本文将通过对这些色彩进行设置的实例，让用户逐步了解与色彩相关的命令。

1 环境配色

Vim的环境配色决定了用户编辑环境的基本风格。语法高亮可以关闭但环境配色是始终存在的，下面我们将逐步地改造并定义属于自已的配色风格。

1.1 使用预置的配色风格

要改变Vim的编辑环境的配色很容易因为Vim提供了多种预置的配色风格（颜色主题）。比如要使用'evening'风格：在菜单中选择“编辑-调色板-evening”。或者在命令行中使用:colorscheme命令1：

:colors evening

可以看到编辑环境包括编辑区的前景背景的颜色都发生了变化。命令行下Vim默认是黑底白字，图形下的Vim是白底黑字，在应用了上面的命令后都成了深灰的背景，银灰的前景。

提示：在菜单中选择“default”或使用命令:colors default，换回默认的配色。关键字：:colorscheme

1.2 修改环境配色

如果你不满足于使用现成的颜色主题的话，那我们来看一下如何修改环境配色。首先要掌握的命令是:highlight。

" 使用默认的高亮（移除用户定义的高亮，即根据'ft'重新载入语法文件）
:hi clear 
	
" guifg表示图型介面（gui）下的前景色（ForeGround）
" guibg表示图型介面（gui）下的背景色（BackGround）
:hi {组} guifg={值} guibg={值}
	
" 进行颜色关联。
" 这条命令使{组1}使用与{组2}一样的颜色设置
:hi link {组1} {组2}

例如，要将“组”为“c_name”的组在图形介面下的颜色设置为背景黑色，前景灰色可用如下命令：

:hi c_name guifg=gray guibg=black

让组“c_blah”使用与“c_name”一样的颜色设置：

:hi link c_blah c_name

注意：目前我们只涉及图形介面下Vim（gVim）的色彩控制。所以本文接下来的例子，在我们讲到命令行下的颜色设置之前，所有例子都是在gVim环境中完成的。

忘了解释一下“组”（高亮组）是什么？有什么用？Vim中“组”被用来表示一组颜色设置（前景、背景、字体、风格）。当某个介面元素（或是编辑区中的文本）应用了特定的“组”后，它就根据“组”表示的颜色设置来显示。应用了同样“组”的介面元素或文本会有一样的颜色显示。有:hi为“组”分配颜色时，如果组已存在则覆盖原有的设置，否则定义新组。

现在我们知道通过赋于guifg和guibg颜色值为组分配颜色。哪到底可以使用哪些颜色呢？图形介面下的颜色有“名称”或“数值”两种表示方式。名称如上面所用的gray、black还有大家熟悉的red、white、yellow，更多可以使用的颜色名称见文档：gui-colors。颜色还可以用“数值”来表示，方法是用三个分别表示“红、黄、蓝”的十六进制数值表示。如red还可以表示为#ff0000。记得数值前要加上#号。没错，这与html文件中颜色的表示方法是一样的。用这种方法我们可以表示更多的颜色：

" 将前景改为淡紫色
:hi c_name guifg=#E6E6FA

提示：此外guifg/guibg还支持三个特殊的值：none、fg、bg，分别表示无颜色、编辑区一般文本的前景色、一般文本的背景色。

要改变Vim的配色我们需要知道都有哪些组可以改。下面表中是Vim环境配色中介面元素所应用的“组”（组名在前）：

Cursor
    光标
ErrorMsg
    命令行中的错误提示
Folded
    折叠行
LineNr
    行号
NonText
    非文本区（控制字符和一些特殊字符和编辑器空白区等）
Normal
    编辑区一般文本的前景和背景色
Search
    搜索
StatusLine
    状态行
Visual
    圈选区 

提示：完整的列表见highlight-groups。非Windows用户还可以设置菜单、滚动条和提示框的颜色。见hl-menu。

现在做个实验，打开一个文档并依次输入下面的命令，观察变化：

:se ft= "关闭高亮
" 分别改变编辑区的前景色（guifg）和背景色（guibg）为灰色和红色
:hi Normal guifg=gray guibg=red
" 修改背景色为暗灰色，上面设置的前景色将被保留
:hi Normal guibg=#333333
	
"显示状态行
:se laststatus=2
" 设置状态行的颜色。
" 如果没“gui=none”会发现状态行的前/背景色颠倒了。
" 关于gui我们稍后再说
:hi Statusline guifg=green guibg=gray gui=None
" 状态栏的默认颜色
:hi statusline gui=bold,inverse guifg=fg guibg=bg
" 使错误提示使用与状态栏一样的颜色设置（默认是红色）
" 用hi link对已定义颜色的组重新定义颜色要加“!”
:hi! link ErrorMsg statusline
" 下面的命令会出错，错误提示成了绿色的
:hi link
" 清除颜色。
:hi! link ErrorMsg none
" 无颜色的错误提示
:echoerr "abc"
" 恢复默认的颜色
:hi clear

注：“:hi link {组} NONE”是:hi link的一种用法，用来清除组的颜色关联。

2 语法高亮

前面我们讲了如何更改Vim环境配色，如光标，状态行，错误提示的颜色。并没有涉及到如何根据编辑的文件来显示不同颜色，即语法高亮。与更改配色相比设置语法高亮要更复杂一些：配色中更改的组是确定的，因为编辑器中的介面元素是固定的，而语法高亮中所打开文件中那些需要高亮那些不需要，以及对不同类型的文件应用不同的语法高亮都要视具体的文件而定。很多时候我们还需要“创造”（自定义）出一些组来。但与配色一样在语法高亮中颜色的显示依然是由:hi命令控制。

2.1 修改当前的高亮设置

这一节我们将对当前文本中的语法高亮进行修改，你会发现这与修改环境配色相似——所不同的只是“组”名。这是一组实验：

:h syntax.txt "打开Vim文档
:hi helpHyperTextJump guifg=darkblue "改变文档中链接的颜色
:hi clear
"清除自定义颜色——包括上面的颜色
:hi! link helpHyperTextJump Identifier "恢复颜色

所以要定义颜色只要对相应的组名的颜色进行设置就行了。那你要问了，这个helpHyperTextJump是从哪来的我怎么会知道哪个的组名是哪个？如果我要定义自已的组名呢？
要查看当前的语法文件中定义了哪些组名可以用不带参数的:hi查看。此外，还可以用：

" 查看当前的文件类型（假设是texinfo文件）。
:se ft
texinfo
" 知道是texinfo文件后，使用以下命令打开相应的语法文件
" 在语法文件中，:syn命令后跟的就是组名。
:e $vimruntime/syntax/texinfo.vim

那用户该怎么定义自已的组呢？继续往下看吧……

2.2 定义新的高亮

在定义新的高亮组时我们要先回答这个问题：为什么要定义新的组呢？有很多可能的原因：其中之一是我们想在不修改原来的高亮的情况下增加一种色彩，为些我们需要定义新的高亮组，并分配适当的颜色。
现在我们要定义自已的组了，首先要为我们自定义的组取个名字，组的命名与变量一样只能由字符下划线和数字组成（虽然我们前面的例子中使用了不同的大小写，但组名是不区分大小写的）。下面的命令中我们定义了一个组名为“mygroup”的组2。
:hi mygroup guifg=#ff9999
这条命令告诉Vim将mygroup组的字串颜色定义为淡红色（lightred）。但Vim现在还不知道哪些字串属于mygroup，所以我们得告诉Vim——方法是使用:match命令：
:match mygroup /xxx/
这条命令告诉Vim凡匹配式样的xxx的字串都属于mygroup。这样当前文件中所有匹配“xxx”的字串都会变成淡红色。定义自己的颜色是不是很容易呢？先用:hi命令定义组及其使用的颜色。再用:match告诉Vim编辑区文本中哪些部分是属于自定义组的。最后，Vim会根据:match设置的规则将当前编辑区文本分为许多不同的组（如果有定义多个组的话），并对不同的组应用:hi为其分配的颜色

下面我们要用一个更实际的例子来加深对语法高亮的印象。

看一下这个简单的表格：

王小明	数学	46
李阿月	数学	72
林小丽	数学	91

这是某个班主任手中的成绩单。他/她的班级有25个学生，这是其中的三条数据。这个班级经常有考试，这个老师希望考试的结果更直接明了一点：不及格（少于60分）的成绩显示为红色，90分以上的成绩有显示为青色，这样他/她就可以很快知道哪些学生该补课3，而哪些学生该表扬。当科目为数学时将科目显示为蓝色，这个班主任教数学的！学生名字显示为粉红色——看来这个班主任是女的。最后全班最高分的颜色反白显示。
我们先取几个不同的组名4：“u_student、u_subject、u_mark_fail、u_mark_a”分别表示“学生、科目、不及格、优秀”等。将这个表格另存为文本文件并用gVim打开，使用下面的命令：

:hi u_student guifg=#ff9999 guibg=white
:hi u_subject guifg=lightblue guibg=white
:hi u_mark_fail guifg=red guibg=white
:hi u_mark_a guifg=darkcyan guibg=white
" 上面的命令定义了不同的组及其对应的颜色
" 现在我们要用match告诉Vim怎么分辨不同的组，
" 我们要用到一些的正则表达式
	
"行头开始至第一个空白字符
:syn match u_student /^S*/
:syn match u_subject /数学/
:syn match u_mark_fail /s[1-5]=.$/
:syn match u_mark_a /s100|s9.$/

你可能发现了每条match命令前面都多了:syn。这是因为使用match命令时前一个match定义的组的颜色会丢失。用match命令你没办法同时显示多种颜色。在上面的match命令前加上syn就行了，就可以显示所有自定义的颜色了。

提示：其实:syntax match与:match是不同的命令，不过“目前为止”它们的语法是一样的，我们在下一篇会讲到:syntax命令。

现在我们为成绩单加上颜色了，但下一次呢？我们可不希望每次打开都手动设置，我们可以将之放进单独文件中。将上面的命令复制到单独的文件中，然后用:so命令运行就可以了。

2.3 写语法文件

我们在前面写的脚本，保存起来就成了一语法文件。我们使用:so命令就可以运行了，不过你也许还希望它像其他语法文件一样能自动加载。要做到这一点也很简单。

在我们继续之前我简单描述一下语法文件加载的机制。Vim读入/新建文件时根据后缀名判断文件类型（或者根据模式行中设置的'filetype'设置项判断文件类型），然后在$VIMRUNTIME/syntax/和$VIM/vimfiles/syntax/中查找以文件类型为文件名，.vim为后缀的文件。找到的话加载该文件。

所以语法文件我们已经有了，我们只需要再选择合适的文件类型名。假设我们使用的文件类型名是'u_mark'，将上面的脚本命名为u_mark.vim放到这个目录中：$VIM/vimfiles/syntax/。然后要让Vim打开成绩单时知道自动应用语法文件。在学习autocmd和filetype的内容之前，在这里我们可以简单地使用模式行，来达到这个目的。在成绩单文件的末尾加入模式行：

   vim:ft=u_mark

现在打开成绩单文件时Vim就会自动加载语法文件。如果打开成绩单时还是没出现语法高亮请确定已经开启了语法高亮。使用:syn on开启高亮，必要的话将之放到.vimrc中。

3 :highlight命令详解

现在是对:hi进一步挖掘的时候了。
3.1 命令行下的颜色设置

在前面的内容中，我们讲:hi命令时一直都是以图形介面（gui）为例设置前景和背景色。由于命令终端对颜色显示的限制，Vim在命令行下可以使用的颜色相对gui要少得多，所以使用:hi命令时图形介面和命令行介面的颜色是分开设置的。对于黑白终端来说就无所谓颜色了，而彩色终端用cterm来表示，前景色就是“ctermfg”，而背景色是“ctermbg”。下面是一个表格：

终端类型    前景色      背景色      注释
term         -          -           黑白终端
cterm       ctermfg     ctermgb     彩色终端
gui         guifg       guibg       图形介面

在前面我们对编辑区文本的颜色进行了定义：
:hi Normal guifg=gray guibg=red
现在我们对其命令行下的颜色进行定义
:hi Normal ctermfg=gray ctermbg=red
我们可以简单地写成一行：
:hi Normal guifg=gray guibg=red ctermfg=gray ctermbg=red

有哪些颜色可以使用？见cterm-colors。

3.2 显示样式

:hi命令除控制颜色外还可以控制文字的显示样式。term、cterm和gui分别控制三种不同终端下的字体式样。这些字体样式包括了粗体、下划线、斜体、反显。使用多种样式时将样式用逗号隔开。详细样式见attr-list。

" 设置错误提示在不同终端下的显示样式
:hi ErrorMsg term=bold,reverse cterm=bold,reverse gui=reverse 
	
" 将某项的值设为NONE，可清除该项的样式设定
:hi ErrorMsg term=NONE

需要注意的是gui下不支持粗体的样式，但gui下多了一个字体的设置项font，用以指定字体：:hi tung_poem font=……

另外因为Normal组是做为Vim的基准设定，所以对Normal进行的字体样式设定将被忽略。

3.3 关于link

在使用:hi link命令时有几个细节要注意一下。文档中都有（hi-link），这里简单提一下。仍是以命令“:hi link {组1} {组2}”为例：

    * 如果在关联之前{组1}组已经定义过了了，则要使用加!号的形式:hi! link否则提示错误。
    * 当{组1}关联到{组2}后，{组1}组使用与{组2}一样的颜色设置。如果此时再用:hi对{组1}定义颜色，则关联被取消。{组1}回复到设置关联前的颜色设置（如果有的话），再应用新定义的颜色。
    * default开关项。由于Vim有多个配置文件，又有语法文件定义颜色。所以一组颜色可能被多次定义，为了让某一组颜色只在未定义时关联到其他组。可以使用开关项default：

           :hi default link {组1} {组2}

      一般而言，后定义（关联）的颜色总是覆盖先定义（关联）的颜色。在使用了这个开关项时，设置了default开关的总是被覆盖。仅当其他地方未定义{组1}时，才使用该关联。这主要是用在语法文件中，语法文件的加载要晚于配置文件。当在配置文件中定义颜色时，由于语法文件较晚加载自定义的颜色总是被覆盖。如果在语法文件中使用了default，则配置文件中自定义的颜色就能被显示出来。 

使用:hi link还能节省大量的时间，减少重复的劳动。完整的颜色定义通常较长，因为要兼顾各种终端的显示能力。这是Vim中对Comment组的颜色定义：

  :hi Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE

如果每定义一种颜色都要写这么长就太折腾人了。避免这种情况的最好方法是利用好预定义的颜色。这些是Vim预定义的组、所表示的意义及其使用的颜色与样式：
Comment 注释
Constant 常量
Identifier 变量名
Statement 语句
PreProc 预处理器
Type 数据类型
Special 特殊符号
Underlined 突出显示的文本
Ignore 无设置
Error 语法错误
Todo 待做事项

Vim的语法文件本身就大量地使用了:hi link命令，它们大部就是关联到上面所列的组。在上面成绩单的例子中我们定义了u_subject在gui下的颜色为蓝色，但使用下面这条命令我们除了达到同样的效果外，还定义在其他终端下的颜色：

:hi! link u_subject Comment

所以在定义新的颜色时，先在上面的列表中看一看有没有你需要的颜色，如果有的话又可以节省很多时间了。

4 综合

现在看一下与语法高亮相关的几个例子。
4.1 高亮tags

见文档：tag-highlight

4.2 生成web色索引

使用:hi命令和:syn match命令就可以让Vim显示出斑斓的色彩。现在我们要更进一步结合上面的两个命令与Vim脚本写出一个217色的Web安全色表。

" 生成Web色表
" 用法：so web_color_gen.vim
" 限制：只能在gui中使用
" 注意：这个脚本在Vim6.3/6.4中有时会出现颜色渲染错误的情况。
"       在Vim7中则没发现类似情况。
	
" 关闭搜索高亮
se nohls
	
" 定义数组
" 在Vim7中定义数组就不会这么累了
let c0="00"
let c1="33"
let c2="66"
let c3="99"
let c4="cc"
let c5="ff"
	
" 生成web色的数值表
let L1=0
while L1<6
  let L2=0
  while L2<6
    let L3=0
    while L3<6
       exec "norm o<ESC>" . ':s/^/=c{L1}.c{L2}.c{L3}." "/' . "<CR>"
      let L3=L3+1
    endw
    let L2=L2+1
  endw
  let L1=L1+1
endw
	
g/./exec 'hi '.expand("<cword>").' guifg=grey guibg=#'.expand("<cword>") |
     exec 'syn match '.expand("<cword>").' /'.expand("<cword>").' /'
	

新建空文档，然后运行脚本就可以看到web色表了。

这里有几个地方我解释一下。
exec "norm o<ESC>" . ':s/^/=c{L1}.c{L2}.c{L3}." "/' . "<CR>"
这条命令在文档中新起一行，并用:s命令插入颜色值。关于:s命令的rhs中使用=在“寄存器”篇中我们已经讲过了（见：sub-replace-special）。当L1、L2、L3分别为1、2、3时，这条命令就成了：
exec "norm o<ESC>" . ':s/^/=c1.c2.c3." "/' . "<CR>"
其结果就是在当前行下插入了“336699 ”。在这三组循环运行完后文档区将会有如下的web色数值表：

000000
000033
...
ffffff

还有就是expand()。这个函数的作用是将一些特殊的符号扩展为该符号所表示的字串。 expand("<cword>")将返回当前光标所在位置的“词”。常见的用法还有expand("%")、 expand("<sfile>")等。篇幅所限，关于这个函数的用法见*expand()*。

g/./exec 'hi '.expand("<cword>").' guifg=grey guibg=#'.expand("<cword>") ……

g/./表示对所有非空行执行命令。假设当前行在“336699 ”，对这行执行“exec 'hi…. .expand("<cword>")”命令时，expand("<cword>")将被扩展为“336699”，这样命令就成了：

hi 336699 guifg=grey guibg=336699

同样的后面的:syn命令就成了syn match 336699 /336699 /。在运行完这组命令后Vim就会刷新屏幕上的颜色了。

提示：这段代码只有在图形介面下能发挥功用，在脚本开头加入这段代码以检测运行环境：

if !has("gui")
    finish
endif

另外，在脚本末尾添加下面代码可以使用web色表更易读一点：

1d " 删除空行
" 格式化颜色表，每行六种颜色。
g/./norm 6gJ

这是运行结果（部分）：
660000 660033 660066 660099 6600cc 6600ff
663300 663333 663366 663399 6633cc 6633ff
666600 666633 666666 666699 6666cc 6666ff
669900 669933 669966 669999 6699cc 6699ff
66cc00 66cc33 66cc66 66cc99 66cccc 66ccff

4.3 其他应用

Vim定义的高亮还可以用以生成彩色的html文档或打印彩色文档。

    * 要生成html文档，只要先开启高亮然后简单的输入:TOhtml命令就可以生成使用与当前颜色设置一样的html文档了。TOhtml其实是一个插件，除了简单的用法，它其实还支持许多高级的控制选项如编码，CSS等。这是非常值得用户花点时间了解的命令——关键字“:TOhtml”。
    * :hardcopy命令会根据当前的色彩设定打印文档。此外在Linux/Unix中这个命令还可以用来生成PostScript文档。关键字“:hardcopy”。 

5 小结

至此对于给定的组我们已经能决定它颜色的显示了。然而，依赖:syn match加正则表达式的方式定义组仍有局限——它不能针对组与组之间的关系作出调整，注释的嵌套便是一例。这解决这些问题或者说要定义有更复杂规则的组我们需要对:syntax命令有进一步的了解。下一篇我们将深入高亮的另一重要命令:syntax并，定义更复杂的语法文件。


Footnotes

[1] 其实Vim中的颜色文件，配色文件，语法文件，配置文件和插件本质上都是脚本文件都可以用ru或so运行。colors命令可以认为是预设了目录的so命令。

[2] 这里用的命令格式与上面修改高亮时的命令格式是一样的，它们的唯一区别在于使用的是否是新的组名。如前所述，Vim并不知道它是修改已有组的颜色设置，还是定义了新的组。要检查特定的组是否已存在可以用:hi mygroup，如出现错误提示则说明在“当前应用的语法文件”中不存在组mygroup

[3] 在我读书的会儿老师会要求我们把错的题目抄800-1000遍

[4] 没错，你可以按自己的意愿选择组名

22 10, 2010
寄存器::Vim进阶索引[4]
作者 helloxchen 12:44 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
Table of Contents

    * Vim进阶索引[4]::寄存器
    * 1 数字与字母寄存器
          o 1.1 数字寄存器
          o 1.2 字母寄存器 
    * 2 其他寄存器
    * 3 寄存器相关命令
    * 4 寄存器的特殊性质
          o 4.1 是临时的存储空间
          o 4.2 寄存器也是变量
          o 4.3 在编辑窗口与命令窗口间交换内容
          o 4.4 在buffer之间及程序之间交换内容
          o 4.5 寄存器可以做为宏
          o 4.6 在重定向命令中使用
          o 4.7 表达式寄存器 
    * 5 小结 



Vim进阶索引[4]::寄存器

    以前经常要安装剪贴板的软件来支持多次的剪切粘贴操作。现在这些步骤可以省下了，Vim的寄存器就可以当成多个剪贴板来使用。但是寄存器可不这么简单…… 

寄存器是Vim用来储存文本的临时空间。当我们使用y或d指令时被复制或删除的文本会被送到寄存器，而我们可以通过p指令插入刚删除或复制的内容。寄存器在这里的作用就跟Window的剪贴板相似，但Vim的寄存器要更多，作用也更多。

在Vim中不同寄存器有固定的名称。我们可以通过这个名称访问它们的。寄存器的名称由单个字符组成——只有一个例外，大部分的寄存器名称是单个数字或字母有几个特殊的寄存器以其他字符为名。使用时需要在寄存器名称前加上"号以区别于一般命令以及标记（mark）。

:help registers
:help :registers
:help :copy-move
:help c_Ctrl-R
:help s=



1 数字与字母寄存器



1.1 数字寄存器

有些寄存器是有特殊作用的如数字寄存器。在介绍数字寄存器前先看一个命令:reg。现在输入这个命令:reg。有没有看到许多"号开始的数字或字符呢，这些就是寄存器。这里面有你以前删除的文本和最近复制的文本。

寄存器"0到"9就叫做数字寄存器。寄存器"0存着上一次复制操作所复制的文本。寄存器"1到"9分别保存着你最近删除的文本。"1的内容总是你上一次删除的内容。每删除一次这些寄存器的内容就往下传递。刚删除的文本到了"1，而原来的寄存器"1的内容到了"2，原来"2的内容到了"3，……，原来"9的内容则被丢弃。数字寄存器只保留最近9条删条的文本和一条复制的文本。

现在做一下下面的实验，在Vim中分四行输入123：

1
2
3

使用两次dd指令，依次将1、2两行删除。输入:reg观察寄存器"1、"2。可以看到：

"1   2
"2   1

再使用dd指令将第三行删除。再输入:reg看看结果……现在你应该知道数字寄存器的工作方式了吧。

而我们经常使用的p指令，就是将最近一次删除或复制的文本添加到当前位置。如果最近一次操作是复制则p就添加"0的内容，如果最近一次操作是删除就添加"1的内容。



1.2 字母寄存器

现在看一下今天要讲的第二种寄存器：字母寄存器（named register）。字母寄存器的名称是单个英文字母。可以用这种方式表示一个字母寄存器："a,"b,…,"z。同一个字母的大写形式与小写形式表示的是同一个寄存器，但它们在“行为”会有所不同，这点稍后说明。字母寄存器只有在用户指定时才被使用。

一般模式（normal mode）下要访问寄存器只要在使用复制和删除指令y和d时，在前面加上寄存器的名称即可。比如要将当前行及随后两行（1+2=3）复制到寄存器c 中："c3yy。要将刚保存到寄存器c的内容“粘贴”出来："cp。数字寄存器也是一样的使用方式，要将数字寄存器3的内容粘贴出来："3p。

提示：可是怎么知道那个寄存器有自己想要的内容呢？使用:reg或:display。在命令后加上寄存器名称则显示相应寄存器的内容。

字母寄存器的名称大写时有特殊用途。当我们使用大写的寄存器进行复制或删除文本时，寄存器原来的内容会被保留，刚删除或复制的内容则附加到原来内容的后面。如：`"Cdd‘时当前删除行会添加到寄存器c原有内容的后面。大小写的寄存器仅在复制和删除时有区别。而当使用p时，大小写寄存器名的作用是一样的。

说明：在一般模式下Vim的删除和复制命令相当灵活。有各种使用方式，下面是一些删除命令的例子——将d改为y就是复制的例子了。如

3dd
    删除3行
d2l
    向右删除2个字符
v2]d
    删除两个段落
df。
    从当前位置删除到句号
d`c
    删除至标记（:help :mark）c 

除些之外x命令和p命令也有各种形式。所有这些命令及其不同形式都可以与寄存器一起使用，方法是在d、y、x、p前面加上寄存器。篇幅所限我们不可能将与寄存器一起使用的删除复制命令一一列举。虽然我们举的例子者是yy或dd这样删除的最简单形式，但无特别说明在与寄存器一起使用时yy和dd可以是任何删除、复制或是粘贴形式，以下同。详细的删除复制及粘贴命令可以见:help deleting :help copy-move



2 其他寄存器

除了上面的两种寄存器外，Vim还有很多种寄存器。这是Vim的文档中对寄存器的分类：

""
    无名寄存器。保存最近一次复制或删除的文本。就是p命令默认使用的寄存器。

"-
    短删除寄存器（The small delete register）。事实上刚删除的文本并不一定被送到数字寄存器，如果删除的文本不含换行符（不足一整句）则文本被送至这个寄存器。如x、d2h这两条命令删除的文本都会被送到这个寄存器。注意下在这条命令虽然删除了一整行的文本但因不含换行符所以也被送到这个寄存器`0d$‘。

": ". "% "#
    只读寄存器。它们分别用来保存最近一次在命令行窗口使用的命令、最近一次插入的文本、当前编辑的文件名、当前的替代文件名。

"=
    表达式寄存器。

"* "+ "~
    选择与拖放的寄存器。在Windows中这几个寄存器就是剪贴板。在Linux中它们也是剪贴板——但这几个寄存器是有所区别的。

"_
    黑洞寄存器
    删除操作会影响现有数字寄存器的内容。前一个数字寄存器的值传给后一个数字寄存器，"9的内容被丢弃，新删除的文本则放入"1。这至少有两个直接的影响，一是"9的内容被丢弃；二是寄存器中文本的位置都发生了变化。而复制操作会改变"0的值。如果你不希望删除或复制的操作影响数字寄存器的话就使用这个寄存器。使用这个寄存器进行删除或复制的内容都会被丢弃——这还可以提高一点速度节省一点空间。

"/
    搜索式样寄存器。保存上一次搜索所使用的式样。注意这也包括了s命令中所使用的搜索式样。 



3 寄存器相关命令

前面已经说了一般模式下下的各种x、d、y、p命令都可以与寄存器一起使用，如"ayy。现在看一下在命令窗口中（或Ex模式）下怎么访问寄存器。
命令行中复制、删除和粘贴分别是`:y‘、`:d‘、`:pu‘。寄存器的使用方式是直接在上述命令后面加上寄存器的名称——不需要在寄存器前加入"号。如：

:2,4y a
    将第2至4行的文本复制到寄存器a中。
:'<,'>d A
    将选中的行删除并将其内容附加到寄存器a中。
:pu! a
    将寄存器a的内容粘贴到当前行之前。 

寄存器也是一种变量可以在表达式中使用，因而也经常配合:exec构造复杂的命令。在替换命令:s的替换式样部分可以使用表达式寄存器（:h sub-replace-expression）。一般模式命令q（:help q）可以用来录制宏，而所录的击键序列就保存在寄存器中。此外:redir命令也可以与寄存器一起使用。具体见Vim文档（:help :redir）。



4 寄存器的特殊性质

我们已经知道数字寄存器可以保留复制和删除的内容供用户使用。但这个功能实际用途已大不如前，因为Vim支持无限的undo操作。而且由于引入了Vim脚本后可以使用变量来代替寄存器的作用。但寄存器并非毫无存在价值。



4.1 是临时的存储空间

这正是寄存器出现的目的。有时候我们需要一些临时存储空间我们就可以使用寄存器而不需要新建一个临时文件。比如写作时你也许会发现有一整段的文字也许应该删除或放到其他位置。这时你可以把它放到寄存器中。然后在需要时再把它贴出来——没错就象Windows的剪贴板。但更好用，因为你有26个字母寄存器可以使用；可以使用大写字母将文本附加到已有内容后。如果在你关闭文件之前还没想到这将这些内容贴在哪里也没关系用`:wviminfo my_viminfo‘命令。下一次编辑时输入`:rviminfo! my_viminfo‘或者在命令行用这个命令运行`gvim -i my_viminfo myfile‘，:reg看寄存器的内容是不是都还在呢1？



4.2 寄存器也是变量

在上一篇“脚本”中我们说过了是个变量——特殊的变量，只要在前面加上一个@号就可以用变量的方式访问寄存器。
所以，变量的操作也同样适用于寄存器。

" 给寄存器赋值
let @e="开始<CR>"
let @E="结束"
echo @e
开始
结束

" 将寄存器作为表达式的一部分
let my_var=@a . @c
" 和
echo @e+4

" 清空寄存器。
" 注意：不能用unlet清除寄存器。
:let @e=""



4.3 在编辑窗口与命令窗口间交换内容

编辑窗口的文本可以放进寄存器。搜索式样和上一条Ex命令被放进了只读寄存器"/和":。
已知寄存器的内容可以在贴到编辑窗口。可以在命令窗口作为变量使用。那有没有办法在命令窗口插入寄存器的内容呢？有没有办法在搜索式样中插入寄存器的内容呢？

比如，假设在寄存器e中保存着一个文件名：“这是一个保存在寄存器中的很长的文件名.txt”。而我想使用:w命令保存一个当前编辑文件的副本——使用寄存器e中的那个文件名。如果使用`:w @e‘的话，文件名将是“@e”而不是“这是一个保存在寄存器中的很长的文件名.txt”。这时该怎么办呢？考虑到寄存器也是变量，我们可以使用寄存器的传统办法。

" 方法一。使用:execute命令
" 写入以"e为名的寄存器中
:exe "w " . @e

那搜索呢？如果我们要在搜索式样中使用寄存器的内容呢？对于s命令的搜索式样上面的:exe大法仍然适用，但如果只是普通的搜索操作（在一般模式中按/）呢？我们要用到组合键Ctrl-R，用Vim的写法就是<C-R>。

" 方法二。使用Ctrl-R转义。
" 搜索寄存器e的内容。<Ctrl-R>表示用户在这里按了组合键Ctrl-R——不要直接输入<Ctrl-R>这8个字符。
/<Ctrl-R>e/

使用<C-R>的方式可适用于各种输入的环境中：在插入模式输入时、在命令窗口输入时、在搜索时。在插入模式时要输入寄存器内容并不需要退回到一般模式再使用p指令，可以直接按`<Ctrl-R>e‘当然e可以改成相应的寄存器名。在命令窗口与搜索时也是一样：按Ctrl-R输入寄存器名。

提示：除了一些不接受变量作为参数，不能使用寄存器名称的情况外，还有一些情况也要求插入寄存器的内容。有时我们插入寄存器的内容而不使用寄存器变量是因为我们可能还需要手工对寄存器的内容进行一些编辑。

无名寄存器总是保存着最近一次复制或删除的内容。不带寄存器名地使用p就可以添加该寄存器的内容到当前位置了。但是既然“无名”该怎么在命令窗口使用这个存器呢？又怎么插入无名寄存器的内容呢？答案是使用@"，插入也是一样按Ctrl-R再按输入"就可以了。

现在总结一下：":保存了上一条Ex命令。"/保存了上一条搜索式样。字母寄存器及数字寄存器中可以保存编辑的文本。并且我们也可以在不同的环境中插入寄存器的内容。通过寄存器我们可以方便地在命令窗口编辑窗口以及搜索中交换内容。相对而言一般的变量就没这么方便，你只能在命令行中使用变量也只能是命令行中给变量赋值。



4.4 在buffer之间及程序之间交换内容

寄存器是全局的变量。在Vim中打开的所有文件2，共享这些寄存器。你可以在不同的文件之间交换内容。

通过寄存器"*和"+，Vim可以与其他程序交换信息。在Windows中这两个寄存器是一样的。在Linux中这两个寄存器则有所不同。

:help gui-selections
:help x11-selection



4.5 寄存器可以做为宏

跟一般的变量相比寄存器还有一个最大的特点就是寄存器本身可以做为宏使用。如果你有用过一般模式命令q的话就会发现q录制的击键序列就是存在寄存器中的，并且可以直接使用寄存器执行命令。现在做做实验，新建一文档随便输入几行文字。输入：

qeggddq

上面这条命令录制了一个宏并保存到寄存器e中。这个宏的作用是回到第一行并删除该行。现在看一下寄存器的内容：

:reg e

就是你刚才的键盘命令ggdd。要运行刚录制的键盘操作在一般模式输入@e就可以运行了，输入3@e会将前三行删除。

当然你不一定要用q来录制宏——因为寄存器也是变量。

:let @e="/删除本行/^Mdd:w^M"
@e

上面的^M表示的是回车键。可不是输入^再输入M，而是输入Ctrl-V（Windows是Ctrl-Q）再按回车键这时就会出现^M表示这是一个回车键。常见的还有^[表示的是<ESC>键。输入的方法也是一样按Ctrl-V再按Esc键。这样输入控制字符的方式是传统的Vi方法。在Vim中也支持用按键名表示这些控制字符。比如<CR>表示回车键3所以上面的命令也可表示为：

:let @e="/删除本行/<CR>dd:w<CR>"

这里一定要用双引号，我们在“脚本”一篇中已经讲到了，在单引号中的字串会被当成普通字串。后面这种表示控制字符的方式与'cpoptions'的设置有关，虽然在默认情况下都是可行的但是建议使用第一种方式。不过为了更好的可读性在教程中我们还是可能使用后面这种方式表示控制字符。

正因为寄存器可以直接执行所以":可以用来执行上一条在命令窗口使用的命令：

:@:

记得最后要按回车执行。当然现在由于命令行的历史功能这种用法没有什么实用价值。

关于宏的更多用法我们将另外解说。



4.6 在重定向命令中使用

重定向命令（:redir）是一个较常用的技巧。所有的字母寄存器、@*、无名寄存器（@"）都可以在重定向命令中使用。还是用个例子说明好了：

假设你的小说家朋友寄了一本小说的初稿给你，但显然他没有整理文本的习惯——好消息是他这次竟然没用Word写。在你往下看之前你决定先将文档做适当的整理。使用Vim作这种事当然是小菜一碟，只用了10分钟你就将他的小说整理成一份格式整齐的文档了。

第六章 为山九仞
===============
	
  小明是从不在午时之前离开被褥的，今天却是个例外。他一夜没睡不
  过他却觉得精神比任何时候都好……
	
  < 省略800行 >
  ……
	
第七章 功亏一篑
===============
	
  小明已经很久没像今天这样开心了。从那时到现在已有二十年又一天
  了。对他来讲二十年并不长，能在二十年又三天之内报仇已经是出乎
  自己意料了。何况对方是可是威峦镖局的大当家。想到这里他的眼睛
  眯得更小了……再过两天……只要两天！
	

但你发现这份初稿没目录，而你看小说的习惯是从目录看起。于是你决定整理一份目录。于是你用了寄存器：

:let @a=""
:g/^第.{1,3}章 /y A

这两条命令将所有章的标题放到寄存器A中。你可以在需要目录的地方"ap。不过你还想在每章标题后加上该章对应的行号，你知道这时可以用:redir：

:redir @a
:echo "目录："
:g/^第.{1,3}章 /echo getline(".") . "ttt" . line(".")
:redir END

现在你的寄存器a中有了一个带行号的目录了。只用了几行命令你就漂亮地完成任务了，想到这这里你的眼睛眯得更小了……

注：这里用到的函数是我们在讲折叠时说过的getline(".")，表示返回当前行。line(".")则返回当前的行号。这两个函数的详细用法见文档。通过对这个脚本进行扩充我们甚至可以让它抓取含小节的目录。

上面的例子演示了通过:redir用户能对寄存器的内容进行进一步的加工而不只是简单的摘录，它增加了寄存器的使用范围。这正是与redir之所以成为寄存器重要性质之一的重要原因。在Vim7.0之前的版本中不支持重定向内容到变量，所以寄存器成了唯一选择。考虑到:redir是比较重要的命令，寄存器吃香也就不足为奇了。但在Vim7开始支持重定向内容到变量后，寄存器就没那么重要了——当然如果你希望方便地将重定向的内容插入到文件中的话寄存器仍是理想之选。关于:redir的更多内容，将会另外解说。



4.7 表达式寄存器

虽说是寄存器但从各种角度来看这都是个冒牌的寄存器。它的主要作用是实时计算表达式的值。适用的场合：在编辑输入时、在命令窗口输入时、在搜索时。使用的方式是按Ctrl-R再按等号（<C-R>=），接着输入表达式，原来输入的位置就会插入表达式的值。只要是合法的表达式都可以使用。我们知道字串可以做为合法的表达式，所以在插入模式下按Ctrl-R =然后输入"abc"（注意包括"）当前位置就插入了abc。当然我们不会为了输入字串而使用这个寄存器。现在寄存器a中保存着一个数字，你想在当前文档中搜索该数字4倍的另一个数，你当然不想自己计算。这时使用表达式寄存器：/<Ctrl-R>=@a*4<Enter>/& lt;Enter> 。其中<Ctrl-R>不是让你输入这8个字符而是按组合键Ctrl-R，同理<Enter>表示这里按了回车。任何时候当你需要插入一个表达示的值时都可以使用这个寄存器。

如果在输入=号后直接按回车没有输入表达式的话默认使用上一次使用的表达式。

在上一个例子中，如果你把刚才的目录贴在文件的开头（当然是开头），会发现行号不准了因为所有的内容都被往下移了——第一行现在变成在目录后面了。假设增加的目录有25行（不知道有几行？:se nu），现在文章的第一行（是空行）成了第26行。当然这样问题难不倒你，让表达式寄存器重新计算一下行号就行了——将原来的行号加上25。

注：下面几个控制字符的输入方式：^I, ^R, ^M, 分别表示的是Tab键，Ctrl-R，回车。它们的输入方式是按Ctrl-V（或Ctrl-Q）再输入各自所表示的键。

:1,25norm $T^I"ty$:s/[0-9]+$/^R=@t+25^M/^M

:1,25norm                                                 在1到25行之间（目录区）执行一般模式命令
          $T^I                                             移到行末，将光标定位到最后一个制表符后（也就是第一个数字的位置）
              "ty$                                         将数字复制到寄存器t中
                  :s/[0-9]+$/                             将行末的数字（每一章的行号）
                              ^R=                          插入表达式
                                  @t+25                    将寄存器t中的数字加上25
                                     ^M                    插入回车结束表达式
                                         /^M               结束s命令并在插入回车键
                                            <Enter>        在全部输入完成后别忘了按回车执行命令

还有一个特殊的地方可以用上表达式寄存器（Vim文档没说这是一个表达式寄存器，但它的使用方式与表达式寄存器完全一样），就是:s命令。:s命令的命令格式为：:s/lhs/rhs/，表示搜索lhs并替换为rhs。一个特殊用法就是当rhs的开头为`=‘时，这rhs将被视为表达式。lhs将被替换为表达式的值。

:" 例：将当前行中的算术式'42x31'替换为算术式的结果。
:s/42x31/=42*31/

再回到刚才的例子，中现在我们可以用一种相对优雅的方式计算更新该目录的行号：

:1,25s/[0-9]+$/=submatch(0)+25/

注：submatch()只在:s命令rhs的表达式中使用。submatch(0)与原来的&在rhs的作用是一样的。submatch(1)就相当于原来rhs中的1，依此类推。



5 小结

当我们在进行交互编辑时，寄存器可以提高效率。不过正因为它的这样交互特性，它并不经常在脚本中使用。因为我们完全可以在脚本中使用变量来替代寄存器。它的优点是能方便地与buffer的内容互动。当我们想把buffer的内容赋予某个变量时比较麻烦因为没有直接的一般模式命令可以做到这时寄存器则更方便点。


Footnotes

[1] 通常寄存器的内容会保留到下一次打开Vim，但不一定会保留到下一次打开同一文档所以需要人为的保存
[2] 准确地说是buffer，这与文件的概念并不完全一样
[3] :help key-notation

http://blah.blogsome.com/2006/04/27/vim_tut_register/

22 10, 2010
脚本::Vim进阶索引[3]
作者 helloxchen 12:40 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
脚本::Vim进阶索引[3]
Table of Contents

    * Vim进阶索引[3]::脚本
    * 1 什么是脚本？脚本的作用是什么？
    * 2 两种类型的脚本
          o 2.1 Ex脚本
          o 2.2 一般模式脚本。 
    * 3 运行脚本
          o 3.1 Vim环境
          o 3.2 命令行 
    * 4 脚本进阶
          o 4.1 变量
          o 4.2 表达式
          o 4.3 流程控制
          o 4.4 函数
          o 4.5 零散内容 
    * 5 小结 

Vim进阶索引[3]::脚本

    在这一系列的进阶教程中我们会不时地遇到Vim脚本的内容，也许是配置文件也许是在“宏”中使用的自定义函数。虽然我假设Vim用户会随着这系列的教程，慢慢地掌握脚本的知识。但实际上很多人在学习Vim的过程中“本能地”避开Vim脚本语言的内容；习惯性地认为脚本语言是洪水猛兽。但是却没意识到他们在学习的Vim命令就是脚本语言的主要部分，并且这一部分已经足以让他们写出功能完整的脚本了。本文的目的不在于让用户看完后就掌握了Vim脚本语言，而在于引导读者对Vim脚本语言有个认识：知道怎么使用已有的知识来写脚本；知道怎么运行脚本文件；知道Vim脚本语言中还有哪些主要的概念。最理想的情况下读者从今天开始能随着这系列教程的深入自然而然地掌握Vim的脚本语言。本中提供了相关的帮助索引，用户可以用这些帮助命令找到更完整的信息。

    对了这一系列教程使用的Vim版本是6.3。 

实际上本文假定读者有一定的Vim基础，当然也包括掌握了一部分的命令行命令。为了能更好地掌握Vim的进阶技巧我们这篇中将涉及Vim的脚本。

:help usr_41.txt
:help eval.txt




1 什么是脚本？脚本的作用是什么？

狭义的脚本指含一条或多条编辑命令的独立（脚本文件）文件。通过在编辑器中调用脚本执行在脚本中定义的一条或多条编辑命令。如无明确说明，本文的脚本指的是可在脚本中运行的一条或多条命令而不是指文件本身。当我说“写脚本”时，我指的是写出以某一特定编辑任务为目的而组织起来的一条或多条命令1。

既然你掌握了一些命令你当然会写脚本。我们一起来写一个脚本吧。将下面的命令放入一文件中，假设文件名为myscript.vim2。

" 在文件的最后一行加入签名
:$a
月下独酌
========================
暂伴月将影，行乐须及春。
我歌月徘徊，我舞影零乱。
醒时同交欢，醉后各分散。
永结无情游，相期邈云汉。
========================
.

这个脚本的作用是在文件的最后一行加入签名档。现在用Vim随便打开一文件，输入

:so myscript.vim。

完成。

可以看到上面的“脚本”实际上只是一行注释和一条命令行命令，注释在这里并不是必需的3，所以只要你会命令就可以写脚本。在脚本中以`"‘开始的行都是注释。当然脚本很少会只有一条命令，我们看一下脚本还能为我们做什么？现在我们还想为我们的脚本加入日期怎么办？在脚本的最后一行加入`:$r !date‘4。

通常我们使用脚本是为了减少重复的劳动，如果前面例子中的签名你只用一次，你当然不会想为此写脚本文件。但这并不是绝对的。事实上，很难具体地说明脚本有什么作用，因为每个人都有自己独特的需要，脚本对每个人有不同的作用。总的来说：脚本赋予了一些人满足自己需要的能力。




2 两种类型的脚本

Vim中脚本有两种基本的类型即Ex脚本和一般模式（normal mode）脚本。




2.1 Ex脚本

在Ex脚本中所有的命令都被默认为Ex命令，而命令前面的:是可有可无的。我们开头的例子，就是一Ex脚本。如果在Ex脚本中使用一般模式命令时，需要使用:normal命令。这是Vi的传统脚本格式。




2.2 一般模式脚本。

与Ex脚本相反一般模式脚本。Vim在一般模式中运行这种脚本，所以脚本中的命令就如同你在一般模式中输入指令一样。Ex命令需要在前面加上:。下面是一个例子：

3G02f,lct,家庭地址^[:w

这条命令/脚本将文件中第三行的第二及第三个,之间的内容更改为“家庭地址”。分解一下就是：

3G                      跳到第三行
  0                     跳到本行开始处
   2f,                  找到第二个,
      l                 右移一位
       ct,              修改第二个,和第三个,之间的内容
          家庭地址       改为“家庭地址”
                  ^[    按<ESC>回到一般模式。这个符号是通过输入
                        指令序列<Ctrl-V><ESC>产生的，
                        Windows是<Ctrl-Q><ESC>。表示这里按了<ESC>键。
                    :w  保存修改

这种脚本紧凑但不易读，也不适合写复杂的脚本，一般只在宏5中使用。



3 运行脚本

所以在继续之前我们先学会如何使用脚本。之所以在本篇的开始处就写如何运行脚本是因为：

    * 你会一些命令所以你已经具备写脚本的能力了
    * 运行脚本大多数情况下要比写脚本容易
    * 这样你才能边根据你对Vim脚本语言掌握的程序使用脚本，而不用学完全部脚本知识后才知道怎么运行脚本。 

记住，你并不需要一次掌握所有的脚本知识，而是需要多少学多少，学会多少用多少。

实际上我们一开始的时候就运行过开始的示例脚本了。这里总结一下在Vim中运行脚本的几种方式。



3.1 Vim环境

先看一下下面四个命令：

:source
    这是最传统的运行方式。读入Ex脚本文件并运行。我们一开始的例子就是一Ex脚本文件。一次只能运行一个文件。
:source!
    读入Vim的一般模式命令。注意这个!号并不表示强制运行脚本，而是读入不同的脚本。
:runtime
    从'runtimepath'设置的路径中读取脚本文件。可使用通配符或多个文件名参数，但只有第一个符合的文件被运行。
:runtime!
    跟上一命令一样但运行所有的符合文件。慎用！ 

一些例子：

:so! c:/normal_mode_script.vim
    [Windows环境]Vim中路径可以使用/或。运行一般模式脚本。
:so ../vscript/samp1.vim
    [windows或Unix环境]运行Ex模式脚本。
:ru samp[0-9].vim
    [Unix环境]在runtimepath中搜索以形如samp0.vim、samp1.vim、……、samp9.vim的脚本并运行找到的第一个脚本文件。 



3.2 命令行

Vim的脚本也可以在命令行中使用，用户不需要经过运行Vim、打开文件、运行脚本这三个步骤，相反的同户同要在命令行上给出合适的参数Vim就可以自动处理。在命令行运行Vim的脚本可通过以下几种方式：

参数 	作用 	示例
-s 	读入一般模式脚本 	vim -s 脚本文件名 文件
-e -s
-E -s 	使用vim的ex命令 	vim -e -s <脚本文件名 文件
vim -es <脚本文件名 文件
vim -E -s <脚本文件名 文件

现在我们可以在命令行运行本文开头的脚本了，但在如果你现在运行的话可能会发现什么也没发生。这是因为脚本中没有保存的命令，我们前还需要对脚本进行一些修改——加入命令`wq!‘6。这是修改后的脚本文件（前面的:号是多余的已经去掉了）：

" 在文件的最后一行加入签名
$a
月下独酌
========================
暂伴月将影，行乐须及春。
我歌月徘徊，我舞影零乱。
醒时同交欢，醉后各分散。
永结无情游，相期邈云汉。
========================
.
$r !date
wq!

这个简单的脚本完成的任务就是在文件的末尾加入签名和日期。现在在命令行运行试试：

$ vim -es <myscript.vim 文件.txt

通过在命令行运行脚本我们还可以批量修改文件：

for a in `ls *.txt`
do
    vim -es <myscript.vim $a
done

如果脚本文件使用MS-Dos的'fileformat'可能会出现不理想的结果，最好将'fileformat'设为Unix。当使用`-e -s‘和`-E -s‘在Windows会失去响应7，不过`-s‘不会。

一般模式脚本除了自已写以外，Vim提供了两个命令行参数来“录制”命令8：

参数 	作用 	示例
-w 	将操作录制起来，如果脚本文件已存在则覆盖 	vim -w script.vim 文件
-W 	同上但是如果脚本文件已存在则添加到末尾 	vim -W script.vim 文件

现在跟我做以下实验，先找一文本文档如 f1.txt 复制为f2.txt。使用以下命令运行Vim：
gvim -w mysc.vim f1.txt
然后，进行几个简单的编辑操作并保存退出。现在f1.txt是编辑过的而f2.txt是未经编辑的。用以下命令运行vim：
gvim -s mysc.vim f2.txt
再打开f2.txt看看是不是与f1.txt进行了一样的操作了呢。现在再打mysc.vim看看，可以看到刚才的所以键盘操作都被“录”下来了。你也可以对脚本文件mysc.vim进行进一步的修改以适应实际需要。

好了到目前为止你已经完全可以使用脚本了：你已经掌握了一些命令，你也知道如何运行脚本了。当你掌握的编辑命令越来越多时，你写出来的脚本也就越强大。如果你还想学更多脚本的技巧时那就往下看吧。



4 脚本进阶

    学习一门编程脚本语言最有效的方法就是动手进行实验。下面的内容中有相当多简单的例子，建议读者跟着例子做。当然你不用保存为脚本文件再运行，一般直接在 Vim中输入命令就行了。如果有多条命令可以进入Ex模式运行，方法是按在一般模式中按Q——如果接Q不行的话那就按gQ，输入visual退出Ex模式。 

Vim5.0以前的版本与Vi（ex）的脚本是一到多条编辑命令的集合，脚本的功能就是依序执行脚本中的各种编辑命令。那时的脚本没有变量也没流程控制等程序语言所具有的要素。

对于重复或者复杂的编辑工作Vi通常使用脚本、宏和外部工具来完成。而且一般也认为通过使用宏及外部工具对于大部分的编辑任务而言就以足够了，然而无论是宏还是脚本都只是一系列的编辑指令组成，它们无法与Vi交互并且缺乏足够的灵活性。

从Vim5开始，Vim引入了内建的“脚本语言”，其实就是加入了变量、表达式及流程控制的命令。同时Vim提供了许多的内置函数和内置变量，这些函数和变量我们在后面的教程中会慢慢接触到。通过这些编程特性用户可以写出更灵活更强大的脚本9。现在来看一下都有哪些内容。



4.1 变量

:h variables
:h internal-variables

Vim的变量有两种类型，一是字串类型，一是数字类型。这没什么好解释的了，需要注意的是在我们为变量赋字串类型值时用单引号和双引号表示的字串值是不一样。在双引号字串中是可以使用转义字符的，而单引号字串中不进行任何的转义。下面是两条命令及他们的运行结果：

:echo "|t|"
|    |
:echo '|t|'
|t|

变量名。Vim中合法的变量名由下划线_、大小字母和数字构成，但变量名不能由数字开头。

赋值语句。

:help 41.2
:help :let
:help :unlet

Vim中为变量赋值需要使用:let命令，要释放变量则使用:unlet命令。这是一些例子：

let a=1
let b=3+1
let c='你好'
let d="blahblah"
unlet c

变量前缀：
在Vim在可使用不同的变量前缀10，来区别不同变量的作用范围。

g:全局变量
s:脚本文件内部的变量
l:只在函数内部使用的变量
a:变数变量
v:预定义变量

完整列表见`:help internal-variables‘。
预定义变量是Vim为用户提供的变量，这些变量包括了各种有用的信息，如语言设置、Vim版本、当前行号……等等。这里有祥细列表`:help v:var‘

可访问的特殊变量：

&设置项
@寄存器
$环境变量

看一下一下下面的例子：

:let a="abc"
    定义一个全局变量a
:let g:a="abc"
    同上
:let l:a=a:marg
    自定义函数的局部变量。将参数marg的值传给变量a。因为只在自定义函数内部使用所以l:可以省略。
:echo v:lang
    显示预定义变量lang的值。预定义变量是只读的。
:echo &tabstop
    显示设置项'tabstop'（制表符宽度）的值。
:echo $home
    显示环境变量$home。
:echo @3
    显示数字寄存器3的值
:let &l:tabstop=4
    将'tabstop'设为本地变量，并赋值4。见`:help let-star‘与`:help :setlocal‘ 



4.2 表达式

:help expression-syntax
:help eval

表达式是比较抽象的概念，在Vim中所有可以表示字串/数值或返回字串/数值的变量名11、函数、算术运算式、逻辑运算式都是表达式——当然还有字串/数字本身也是。而它们所表达的字串/数字就是表达式的值。下面这些都是表达式：

表达式 	类型 	值
"123木头人" 	字串 	"123木头人"
123 	数值 	123
mode() 	函数 	表示当前模式的字串
abc 	变量 	变量的值。如果变量未赋值则表达式错误。
"123"==123 	逻辑表达式 	1。这里发生了类型转换，见:help expr6
"123"=="321" 	逻辑表达式 	0
"123木头人"+3 	算术表达式 	126。这里发生了类型转换
32 / 2 	算术表达式 	16
name . '你好' 	字串 	假设name的值为'小明'，则值为'小明你好'

怎样判断一个表达式是不是合法的呢？一个技巧是使用:echo命令。:echo后接表达式会显示表达式的值当表达式不合法是则显示错误信息。
Vim支持的算术运算及逻辑运算与C语言相似。要注意的是Vim不支持浮点运算，算术运算结果的小数点将被省略。所以像7/2的结果会是3而不是3.5。Vim多了一些字串比较的运算符。其中最重要的是正则匹配的运算符：

=~
!~

另外在这些运算符后加上#表示区分大小写，而?表示不区分大小写。如：

==?    大小写不敏感
==#    大小写敏感

在没有#或?时则，根据'ignorecase'设置项决定是否区分大小写。

详细说明请参阅Vim文档
:h expr4



4.3 流程控制

Vim中的控制语句有两种形式分别是选择语句和循环语句。它们相应的命令是:if与:while，结束命令分别是:endif与:endwhile。
它们都根据条件表达式的值来决定是否执行选择体或循环体中的命令，条件表达式的值是数值——0表示条件不成立，非0数值表示条件成立12。其中条件表达式可以是任意合法的表达式，因为条件表达式的值是数值，所以如果表达式的值是字串时会进行自动类型转换，见:help expr6。

选择语句。这是选择语句的形式：

:if 条件表达式
  "Ex命令
:endif

例：

" 如果变量user_name的值为"小明"则显示“小明你好”否则不做动作。
:if user_name=='小明' | echo '小明你好' | endif

选择语句与循环语句都支持嵌套使用。除了嵌套外选择语句还有一种形式可以进行多分支的选择。下面是多分支选择语句的一种形式，表示的是当表达式为真时执行第一组命令否则转到第二组表达式，当第二组表达式为真时执行第二组命令，……当前面的表达式全为假时执行其他命令：

:if 条件表达式
  " 第一组命令
:elseif 第二组条件表达式
  " 第二组命令
:elseif 第三组条件表达式
  " 第三组命令
" ......
:else
  " 其他命令
:endif

上面的:elseif及:else命令都是可选的，可视情况添加。下面再看个例子：

:if user_name=='小明'
: echo '小明你好'
:elseif user_name=~'^李'
: echo '李先生/女士你好'
:else
: echo '你好'
:endif

循环语句：
循环语句在形式上与选择语句相似，所不同的是当条件表达式的值为真时选择语句中的命令会被执行一次然后退出而循环语句会命令命令并回到循环的开始处重新计算表达式如果为真就再次执行……如此重复。

:while 条件表达式
 " 命令
:endwhile

假设有变量user_1、user_2、… 、user_10分别存了10个不同的用户名，我们可以用这种方式将10个用户名列出来13。

:let num=1
:while num<=10
"   使用了{}模拟数组下标。:help curly-braces-names
:   echo user_{num}
:   let num=num+1
:endwhile

这是两个与:while相关的命令`:help :continue‘、`:help :break‘



4.4 函数

Vim中的函数可以分为两种一种是Vim提供的内置函数。一种是自定义函数。
内置函数可以认为是有特殊用法的命令。不同的是命令不能做为表达式而函数可以。Vim提供了相当多的内置函数，具体列表见:help function-list。内置函数一般提供了返回值可以在表达式的环境中使用如：

" 例一、函数line(".")的作用是返回当前行的行号。函数的结果（行号）将保存在变量line_num中。
:let line_num=line(".")
" 例二、echo接受的参数是字串表达式。而toupper()返回的正是大写字串。
:echo toupper("abc")
ABC

自定义函数是用户根据自己需要写的函数。形式如下：
:function! 函数名()
" 脚本
:return
" 脚本
:endfunction
函数名的命令规则与变量名一样，但只有大写字母开头的函数名可以从脚本外部访问。:function命令后的!号表示如果也存在同名函数则覆盖原函数——! 号是可选的。:return语句不是必须的，如果没有:return语句则函数的返回值总为0。没有:return语句的函数一般不在表达式中使用，要调用这些函数的可以使用:call命令。

" 例，定义两个函数
:function! Sayhello( words )
:  return a:words
:endfunction
:function! Sayhello2( words )
: echo a:words
:endfunction

然后分别运行以下命令，观察结果看有什么不同。

:call Sayhello("abc")
:call Sayhello2("abc")
:echo Sayhello("abc")
:echo Sayhello2("abc")




4.5 零散内容

.操作符。字符串可以用.操作符连接。

	
" 例1，将'你    好'值给变量hello
let hello = '你' . "t" . '好'
" 例2
:echo 'ab' . (3+4)
ab7
	
" 例3，不支持浮点运算＋自动类型转换
:echo 123.4
1234
:echo 9/4.4
24
" 例4
:let name="小明"
:let addr="龙门客栈"
:echo "姓名:t".name."r地址:t".addr
姓名:    小明
地址:    龙门客栈

[]操作符。虽然Vim不直接支持数组，但允许通过[]析取字串中的某个字母（Vim7已经加入了数组的支持）。这跟C语言也是一样的，例：

:echo 'ab'[ 0 ]
a
:echo 'ab'[1]
b
:echo 1234[2]
3
:let a="abcd" | echo a[0] . a[2]
ac
" 一个中文有两个字节因而
:echo '中文'[0].'中文'[1]
中

`|‘
连接多条命令这样就可以在同一行中执行多条命令——实际上我们前面已经多次用过这种技巧了。注意有些命令以|为参数因而不能使用|来分隔，祥细列表见`:help :bar‘

`:exec‘
以表达式的结果为命令运行。这条命令经常做为一些复杂技巧的一部分，建议用户详细了解这条命令。

let cmd='echo' | exec cmd . ' "abc"'
abc

至此Vim脚本的主要内容已经讲完了。这些内容目前还比较零散，我们会在以后的教程中将今天学的这些知识一点一点拼起来。



5 小结

对没有编程基础的人来讲学习一门编程语言尤其是通用编程语言最难的有两点其一是使用流程控制语句和各种表达式。二是他们学到的东西不能在日常生活中运用，这让他们很容易就将辛苦学来的知识忘得一干二净。好在在Vim中你很容易就可以将所学的脚本语言知识用上——只要你会用命令就能用脚本。


Footnotes

[1] 事实上命令与脚本是一体两面，当你在编辑器作使用命令它就是命令，当你把命令以某种方式保存起来以便再次使用时它就成了脚本。
[2] 文件名也可以是中文，但也许用英文文件名会更符合一般人的阅读习惯。另外Vim脚本文件一般是以Vim为后缀名，但实际上可以使用任意后缀名
[3] 但写注释是个好习惯，至少可以练习打字。
[4] Windows的用户需要在date后面加入选项`/t‘。另外用Vim内置的strftime()也可以达到同样的目的，但!date显然是更好也更简便的方法——除非你需要跨平台运行
[5] Vi中的宏一般是指以map命令定义的指令
[6] `q‘对Vim来说不是必需的，不过多打一个字母也不费什么事
[7] Cygwin中可以正常运行
[8] 你可能已经想到了，这跟q命令的作用相近。不同的是使用这两个参数录制的命令将写入到文件中而不是寄存器中
[9] 一个副作用是用户可能会倾向于以Vim来完成所有任务，而不考虑是否有更好的或现在的方式。
[10] 就是命名空间，不过我想抽象的词还是少用点
[11] 必须是已经赋过值的变量名
[12] 其实就是逻辑值，0为假，非0为真。但Vim中逻辑值不是独立的数据类型
[13] Vim7之前不能使用数组，但是可以用模拟的方式。这就是一个模拟数组的方式。

http://blah.blogsome.com/2006/04/22/vim_tut_script/

22 10, 2010
折叠::Vim进阶索引[2]
作者 helloxchen 12:38 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
折叠::Vim进阶索引[2]
Table of Contents

    * Vim进阶索引[2]::折叠
    * 1 折叠有什么用途？
    * 2 折叠的生成
          o 2.1 折叠层级
          o 2.2 手工规则（manual）
          o 2.3 缩进规则（indent）
          o 2.4 标记规则（marker） 
    * 3 expr规则
    * 4 实例演示
          o 4.1 唐诗
          o 4.2 笔记
          o 4.3 邮件 
    * 5 使用提示
    * 6 小结
    * Appendix A 

Vim进阶索引[2]::折叠

    折叠对我来说原本不是什么必不可少的功能。但现在却越来越感觉到这实在是个体贴/方便的功能，我经常要保存一些资料但我不喜欢零散的一堆文本文件所以同样的某些特定类型的资料我将它们放在同一个文件中，通过折叠用我可以在同一个文件中管理管理多个文档而不至于混乱。与Vim的其他功能相比折叠是很容易掌握的（至少manual、indent和marker规则是这样的），如果你还没用上这项功能的话赶快往下看吧…… 

这一篇我们将要讲的是折叠。什么是折叠呢？复制一段文本到一新建文件中，在Vim中输入`:set foldmethod=manual‘。输入`:3,8fo‘，看第三行到第八行是不是折叠起来了呢？这就是Vim的折叠功能，很容易理解吧。先记住相关的帮助命令：

:help folding
:help foldmethod
:help fold-methods

在Vim中输入`:help folding‘，可以看到Vim中折叠的相关文档。往下翻页你可以看到这里面的内容非常多，尤其是以z开头的那一部分指令。好消息是要用好折叠并不要求全部掌握这些命令。当然至少要掌握这几个命令：zM zR zo zc zf。折叠的用法的精髓在该页的第一部分`fold methods'。它决定Vim进行折叠所依据的规则。本文的目的是使用户对创建折叠有一个了解。并学会按自己想法来制定折叠规则。



1 折叠有什么用途？

如果你用过字处理软件Word的话那你可能会知道Word有一个大纲视图将“标题一”“标题二”作为大纲显示出来而相应的正文则呈现折叠状态。双击一个标题会展开对应的正文。通过这个视图用户可以对文档的结构有一个全局的了解，更可以有效地组织文本。折叠作用与大纲视图相近，同样让你可以有效的管理文档结构；方便地在文档的不同部分移动；让文档更清爽。此外折叠可以隐藏信息将不需要修改或不想看内容折叠起来。另外结合modeline、filetype或autocmd我们可以在更多的场合使用折叠。

Note：请注意我们可以折叠任意行，所以折叠不等同于显示大纲。另外与Word大纲依靠手工套用样式生成不同，折叠可以用手工生成也可以是用户指定的规则生成。通过指定合适的规则我们使折叠成了一种脑力劳动。

折叠让自己的文档看上去更整洁。同时可以方便地选取感兴趣的内容或屏蔽（如果不能删除的话）不想要的内容。如果你的文档有10行的话你可以不想这做，但如果是成百上千行呢？

使用折叠通常要求用户对文档进行某种方式的格式化，这使用户的文档既使在其他文本编辑器上也有较好的可读性。

当然，没有人规定折叠该怎么用，所以发挥你的创意吧。



2 折叠的生成

首先要了解foldmethod设置项，它指定了折叠产生的方式。详细的文档请参考这两个命令：

:help 'foldmethod'
:help fold-methods

其中的manual、indent、expr、syntax、diff、marker规则分别表示根据手工设置、缩进、表达式、语法、diff、标记的方式生成折叠。在了解Vim如何生成折叠之前我们要先了解一个概念：折叠层级




2.1 折叠层级

折叠层级是用数字表示的折叠标志，Vim根据折叠层级来决定是否折叠及怎样折叠某一行或某几行。当我们下折叠命令时（zM）Vim对每一行计算折叠层级，然后将折叠层级大于或等于`1‘（默认情况下）的行折叠起来。如果低折叠层级的几行中有高折叠层级的行时就形成折叠的嵌套。

那这个折叠层级是如何计算出来的呢？折叠层级的计算方式取决于我们设定的`foldmethod‘。下面是不同折叠规则对应的计算方式：

`manual‘
    手工规则下，折叠层级由折叠区域的嵌套关系计算。当我们手工指定一个折叠的区域后，Vim对这个区域的开始行和结束行做记号，多个区域的开始行和结束行形成了嵌套关系。如果一个折叠区域不包含在其他区域之中，则其折叠层级为1；当这个区域直接包含于另一个区域时则其为折叠层级为另一个区域的层级加1；依些类推。
`indent‘
    行的缩进宽度除以`shiftwidth‘，并向下取整得到每一行的折叠层级。同一折叠层级及更高折叠层级的连续行形成折叠。而其中的更高折叠层级的行——如果有的话，形成嵌套的折叠。
`marker‘
    当使用标记规则折叠时，层级的计算跟手工规则相似。除了它是根据文件中的标记来划分一个折叠区域而不是手工指定。然后根据这些区域间的嵌套关系计算折叠层级。具体使用的标记通过`foldmarker‘设置。默认是使用'{{{,}}}'。
`syntax‘
    跟`marker‘差不多，只是所用的标记是在语法文件中定义的，而不是通过`foldmarker‘设置。
`diff‘
    除了差异行及其前后三行1外，其余行折叠（层级为1）。
`expr‘
    由用户指定折叠层级的计算方式。方法是对`foldexpr‘进行设置。具体用法稍后说明。 



2.2 手工规则（manual）

首先设置设置foldmethod为manual或者marker（没错marker也行）。然后高亮选择可折叠的行，输入指令`zf‘。就这么简单你已经折叠了文本。还可以在命令行用:fold用法跟其他Vim指令一样，如`:1,.fo‘表示将第一行到当前行都折叠起来。需要注意的是如果使用marker折叠规则的话新建折叠时Vim会为指定范围的开始和结束行添加标记（marker）。

注意：如果只折叠一行的话，你可能不会立即看到效果。



2.3 缩进规则（indent）

首先，设置规则`:set foldmethod=indent‘。然后在编辑过程中依需要进行缩进2。

缩进挺容易理解的，将下面的例子复制到文件中保存关闭再用Vim打开看看：

开始
    第一行         折叠层级为1，无嵌套
    第二行
        第三行     折叠层级为2，第1层嵌套
        第四行
            第五行 折叠层级为3，第2层嵌套
            第六行
        第七行     折叠层级为2，第1层嵌套
    第八行         折叠层级为1，无嵌套
            第九行 折叠层级为3，无嵌套
            第五行
结束
vim: shiftwidth=4:foldmethod=indent

注意：正如前面提到的折叠的层级并不仅仅取决于你按了几个空格或制表符还与`shiftwidth‘有关。改变上面例子中的`shiftwidth‘看有什么不一样。



2.4 标记规则（marker）

见手工规则。



3 expr规则

expr要比前面的几种方式复杂点所以我们在这里单独讨论。使用expr时，我们需要对一设置项进行设置——`foldexpr‘。它是用来保存我们设定的表达式，也就是我们指定的计算折叠层级的公式。我们将设置项设为特定的表达式 -> 然后Vim通过`foldexpr‘这个项得到我们所指定的表达式 -> Vim逐行处理，并对每一行使用这个表达式计算出一个数值。这个数值就是该行的折叠层级 -> 根据层级进行折叠。举个例子：假设我们在Vim中使用了如下命令：

:set foldmethod=expr
:set foldexpr=1

所有的行都会被折叠（如果没有的话再输入指令`zM‘）。 Vim在每一行用foldexpr指定的表达式计算结果。这个例子中我们的表达式是1，所以每行得到的折叠层级都是1，于是所有行折叠成一行。同理如果你将它赋于2的话则所有行的折叠层级为2，所有行被折叠成一行。当我们的表达式最后返回一个数值时这个数值就是折叠层级。为了让这表达式更灵活，更能满足我们的需要我们需要补足一些Vim脚本知识3，这里是三个在折叠的表达式比较常用几点：

`v:lnum‘
    内置变量，表示是“当前行的行号”。:help v:var查看更多内置变量。
`getline()‘
    函数用以返回指定行的内容。
`?:‘
    三元条件语句。见:help expr1 

另外如果需要构造复杂的表达式，我们可以在自定义的函数中定义。但这又是另一篇教程了。
看一下现在我们能构造出怎么样的表达式：

:set foldexpr=v:lnum

指定每行的行号为折叠层级，这样所有行会折叠成一行。试试看用指令`zo‘逐层打开折叠，打开20层之后就没有折叠了——而不是我们想的“嵌套数＝行数”。这是因为Vim对折叠的嵌套数是有限制的，默认最深可以20层。但我们可以用foldnestmax这个项来进行自定义设置，如`set foldnestmax=10‘。
注意：Vim最多支持20层的嵌套，所以设置超过20的值会被当成20。

将第8至第20行折叠。也就是让expr在第8至20行时返回数值1（也可以是2、3、4……），其他时候为0。我们知道Vim是逐行处理的，所以如果我们知道Vim正在处理的行的行号我们就可以进行比较了。当然你已经知道了，我们需要的就是`v:lnum‘：

v:lnum>=8&&v:lnum<=20?1:0
v:lnum>=8 && v:lnum<=20 ? 1:0

下面是用expr规则模拟indent规则的例子。基本上没有任何实用价值，但至少能让我们又expr的强大有个认识：

" source this.vim
set foldmethod=expr
set foldexpr=Myindent(v:lnum)
" 用expr模拟indent规则
func! Myindent(lnum)
" 用indent()函数得到当前缩进
let s:idt=indent(a:lnum)
" 用&操作符得到一个设置项shiftwidth的值
let s:sw=&shiftwidth
" 如果有缩进宽度超过阈值(shiftwidth)
if s:idt>=s:sw
   " 则计算折叠层级
   return (s:idt-s:idt%s:sw)/s:sw
else
   return 0
endf

除了可以向foldexpr返回数值外还可以返回一些特殊的值，分别是=, a, s, <, >（详细说明见`:help fold-expr‘，这里不现重复）。Vim的文档不推荐使用=, a, s。
这里再给两个简单的例子：

" 如果一行以@samp{#}开始，折叠。
:set foldexpr=getline(v:lnum)=~/^#/?1:0

" 以每5行为一组折叠
set v:lnum%5-1?1:'>1'



4 实例演示

折叠在写程序时是比较常用的比如python、C语言之类可以将规则设置为`indent‘进行折叠。但我说过了折叠可以有很多不同的用法。下面简单的举几个例子演示一下折叠还能怎么用。由于这里面有些内容需要用到Vim脚本的知识，我不会在这里详细解说，有不明白的地方可以发邮件给我。




4.1 唐诗

这里我借唐诗的例子演示一下expr规则和`foldtext‘设置项的用法。下面是一个文件的内容，这是一个有80首诗的文件每首诗之间有一空行。我的阅读的习惯是看一下目录然后挑自己感兴趣的部分。所以我决定用折叠来模拟目录的效果。

《感遇其一》
作者：张九龄
兰叶春葳蕤，桂华秋皎洁。
欣欣此生意，自尔为佳节。
谁知林栖者，闻风坐相悦。
草木有本心，何求美人折？
	
《感遇其二》
作者：张九龄
江南有丹桔，经冬犹绿林。
岂伊地气暖，自有岁寒心。
可以荐佳客，奈何阻重深。
运命唯所遇，循环不可寻。
徒言树桃李，此木岂无阴。
	
《下终南山过斛斯山人宿置酒》
作者：李白
暮从碧山下，山月随人归。
却顾所来径，苍苍横翠微。
相携及田家，童稚开荆扉。
绿竹入幽径，青萝拂行衣。
欢言得所憩，美酒聊共挥。
长歌吟松风，曲尽河星稀。
我醉君复乐，陶然共忘机。

首先，确定使用的折叠规则。大概的看一下前面的几种规则，看来我们只能用`expr‘规则了。因为我们要将空行以外的所有部分折叠起来。所以我们可以构造这样的表达式：

" 用getline(v:lnum)得到当前行
" 用正则表达式@samp{.}判断当前行是否含有文字。
set foldexpr=getline(v:lnum)=~'.'?1:0

将上面的唐诗复制到一文件中，用Vim打开，设置折叠。是不是看到所有的诗折叠了。不过还有一个问题，在折叠文本（`foldtext‘）中没有注明诗的作者这样的话这个目录似乎有点美中不足。不过我们可以定义折叠文本（:help 'foldtext'）的：

" 想显示诗人？
set foldtext=foldtext().v:folddashes.getline(v:foldstart+1)

通过设置`foldcolumn‘，我们还可以使用鼠标来打开或折叠一首诗。最后我们可以在该文件的最后加入一模式行这样我们每次打开都有折叠的效果了：

vim: ro: fdm=expr: fde=getline(v:lnum)=~'.'?1:0: foldtext=foldtext().v:folddashes.getline(v:foldstart+1): foldcolumn=2

上面的折叠表达式中不同的折叠（诗）之间有一空行，如果希望显示效果更紧凑一点的话试一下这个表达式：
set foldexpr=getline(v:lnum)=~'S'&&getline(v:lnum-1)!~'S'?'>1':'='




4.2 笔记

在阅读文本文件或者多人共同创作说明文档时，经常需要作一些笔记。这些笔记可以是读书心得、体会，也可以是创作说明或者作为以后扩充内容的占位符。如果有很多的笔记的话会影响原文档的可读性，通过折叠笔记我们可以在保留这些笔记的前提下，保证文档的可读性。

   1. 使用模式行vim: se fdm=marker
   2. 选择合适的地方写下自已的想法或注释。
   3. 使用`zf‘或`:fo‘进行折叠。 

这样自己做笔记的地方总是高亮显示。
同时可以使用

:folddoclosed .w! >>笔记.txt

来导出笔记。
注意：:folddoclosed4只对当前关闭的折叠有效，所以如果要导出所有折叠可以先使用指令`zR‘。如果要删除所有的marker，`:g/{{{/norm zD‘



4.3 邮件

我习惯在本地保存一份邮件的副本但有时候在翻以前的邮件时很不方便。因为邮件头通常很长尤其是邮件列表（maillist）中的邮件，有时要看正文得先按好几次CTRL-F。当然在学了折叠后我们当然有更好的办法。

我们以下面这封精简过邮件头并作了适当的修改（防垃圾邮件:(）的邮件为例：

Received: from sino.cmm (unknown [202.108.xx.230])
Received: (qmail 25748 invoked by uid 99); 30 Dec 2004 04:42:47 -0000
Message-ID: <200412300xxx47.25xxx.qmail@sino.cmm>
From: chxxxx <chxxxx@sino.cmm>
To: hqxxe@123.cmm
Subject: RE: XX报告
MIME-Version: 1.0
Date: Thu, 30 Dec 2004 12:42:47 +0800
X-Priority: 3
	
hqxxe：
	
    你的报告已经收到,谢谢!
	
                                      陈
	
----- Original Message -----
> ………………
> blah blah
>> blah blah
>> blah blah

在'.vimrc'（windows中是'_vimrc'）中加入，下面的内容：

" 根据邮件的后缀名进行相关的设置。如果打开的文件后缀名是'.eml'，则当成邮件处理。
autocmd! BufReadPre *.eml se fdm=expr fde=v:lnum==1?1:getline(v:lnum)=~'^$'?0:'=' fdt=Mailfdt(v:foldstart,v:foldend) ft=mail | syn on
	
" 定义函数，用来返回折叠的标题。
" 以折叠的第一和最后一行的行号为参数
func! Mailfdt(fst,fen)
 let fst=a:fst
 " 保存邮件的标题和发信人
 let hfrom=''
 let hsub=''
 let tline=''
 while a:fen!=fst
    let tline=getline(fst)
    " 判断当前行是否是我们感兴趣的行
    " 如果是则保存
    if tline=~'^From: '
       let hfrom=tline
    elseif tline=~'^Subject: '
       let hsub=tline
    endif
    let fst=fst+1
 endwhile
" 返回相关信息
if strlen(hfrom) || strlen(hsub)
    return hsub . "ttt" . hfrom
else
    return getline(a:fst)
endif
endfunc

在加入上面的内容后，我们现在用Vim打开邮件（实际是以.eml作后缀名的文件）看看，是不是清爽多了！



5 使用提示

使用manual一般是临时性的折叠。如果每次编辑特定文件都需要做同样折叠时时建议结合modeline使用其他折叠规则。如果不得不使用manual方式时，你可以用:mksession保存包括折叠在内的一切当前编辑设置或者用:mkview保存当前窗口。具体说明见文档。

indent和marker的折叠规则可以用于程序文件或格式文本。一般可以配合modeline使用。

syntax通常用于程序或特定格式的文本。并且由于是在语法文件中定义的所以一般与autocommand一起使用。:help filetype :help command

diff用于比较文件内容后对照修改时使用。可用:mkview或:mksession保存设置。

expr在上面几种方式无法满足需要时我们要使用expr方式。expr可以在模式行中保存设置，也可以保存在Vim的脚本中。相关命令:mkvimrc :mksession



6 小结

这一篇中我们简单的介绍了Vim中进行折叠的原理，及几种相关的折叠规则及其使用方法。expr规则实际是一种自定义规则，在学习了Vim脚本后我们还能构造出更复杂的规则。但就现在而言用户掌握了manual、indent和marker就行了（虽然在前面我们举了许多expr的例子，但在实际运用中 expr用得比较少，因为通常用户不会绞尽脑汁只为了将文本折叠起来——包括我自己。当然你想要成为进阶用户这是一定要掌握的！）syntax和diff 方式会另外讲解，敬请期待。

下一篇我们将开始讨论与编辑相关的一些内容。下次见。
Appendix A

这是比较不常用但又可能比较有用的内容。使用:help查看相关信息。

v:foldstart 	内置变量 	只读变量记录只前所在折叠的起始行号
v:foldend 	内置变量 	结束行号，其余同上
foldlevel() 	函数 	返回指定行的折叠层级
'foldlevel' 	设置项 	只有高于这个值的折叠层级才会进行折叠
'foldnestmax' 	设置项 	指定最深的嵌套数
'foldignore' 	设置项 	在indent规则中以这个值开始的行的将根据前后行的值来设定折叠层级
:folddoclose 	命令 	对当前闭合的行运行命令
:folddoopen 	命令 	对未折叠的行或定义了折叠但未闭合的行运行命令


Footnotes

[1] 具体行数可通过`diffopt‘选项变更

[2] 可以试试自动缩进的功能`:se ai‘——如果你还没用上的话

[3] 更多内容参考`:help vim-script‘

[4] :help :folddoopen :help :folddoclosed

转自http://blah.blogsome.com/2006/04/13/vim_tut_folding/

22 10, 2010
模式行::Vim进阶索引[1]
作者 helloxchen 12:35 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
Table of Contents

    * Vim进阶索引[1]::模式行
    * 1 什么是模式行？
    * 2 模式行的格式
    * 3 模式行中的附加文本
    * 4 模式行的另一种形式
    * 5 模式行应用
    * 6 下一篇
    * Appendix A 为什么我添加了模式行却没作用？ 



Vim进阶索引[1]::模式行

这是Vim进阶索引的第一篇，本文假设用户已经掌握了Vim的基本用法（正因为这个假设所以你里的一些内容你可能已经掌握了）。作为第一篇我们要讲的是modeline。

相关帮助：

:help modeline
:help 'modeline'
:help 'modelines'



1 什么是模式行？

模式行（modeline）大家应该已经见过了。在Vim文档底部通常会有这么一行`vim:tw=78:ts=8:ft=help:norl:‘，这一行就叫模式行。模式行用来在文档中保存设置，Vim在读入文档后根据模式行的指示对文档对行设置。这样通过在文档中写入模式行我们可以对文档进行个性化设置，定制文本的编辑环境。此外，模式行作为文档的附加信息有助于我们和别人了解一个文档——推荐的文本宽度、使用的语法格式、缩进的方式等等。我们先看一下模式行的用法，再讨论我们可以做什么样的设置。




Next: 模式行中的附加文本,
Previous: 什么是模式行,
Up: Top

2 模式行的格式

几乎所有用set命令可以使用的设置项都可以在模式行中使用（有少数设置项是不能在模式行中使用的，如formatprg）。但在进行设置之前必须在设置项前加上`vim:‘（也可以是`vi:‘或`ex:‘，注意一定要小写。），这是Vim判别一模式行的关键。比如有一个文件我们希望每次打开后自动设置为只读，可以在文件中加入模式行`vim:readonly‘。如果有多个设置项的话每个项之间用冒号或空格隔开。现在我们再看一下刚看到的Vim底部的模式行：`vim:tw=78:ts=8:ft=help:norl:‘，现在我们知道在我们打开Vim帮助后它自动进行了如下设置：设置文本宽度为78；设置制表符宽度为8；文件类型为帮助文件；阅读顺序为左到右。



3 模式行中的附加文本

如果我们在自己的日记中或者写作的过程中我们当然可以随意的在文件前几行或后几行添加模式行。但是在一些情况下我们不能直接地在文件开头或最后一行添加模式行——比如程序的源代码，模式行最好是以注释的形式出现。要让模式行以注释的形式出现，只要在前面加入表示注释的命令或符号就行了。例如要在C++源文件末尾加入模式行：

// vim:ft=cpp:

很简单对吧，事实上模式行的`vim:‘之前允许有任意的文字串。唯一的要求是文字串与`vim:‘之间必须至少有一个空格。所以，像这样的模式行是允许的：

*****今天是X月X日星期X***** @#$%$^%^&*()   |   vim:encoding=utf8  tw=80

不过下面的模式行则会出错：
/* vim:ro */
原因是后面的`*/‘被当成一个设置项了，而事实上这个设置项不存在。为了能在模式行后面添加文字串（或者说为了使用c风格的注释），我们要用到模式行的另一种形式。



4 模式行的另一种形式

实际上模式行有两种形式，第一种就是前面说的设置项之间用冒号或空格分隔，缺点是不能后设置项后面添加其他文本。第二种要求使用set命令。不能使用多条set命令。但一条命令可以设置多个选项。选项之间用空格分隔。举例而言，像前面提到的Vim文档的模式行以第二种形式写出来就是：

vim:set tw=78 ts=8 ft=help norl:

这种形式的好处就是或以是模式行末随意添加文本。下面的模式行都是允许的：

/* vim:set ro */
<!-- vim:set ft=html: 模式行示例-->

需要注意的是第一种形式中最后一设置项后的冒号或空格是可有可无的。而第二种形式中最后一设置项后一定要有冒号——不管冒号后有没有文字。在设置项中如果要使用空格、制表符或冒号可以在前面加上转义符－`‘。其他需要转义符的情况见`:help option-backslash‘。



5 模式行应用

由于几乎所有的Vim设置项都可以在模式行中使用所以模式行的使用完全视个人的需要而定。因为自己常用的设置可以放在.vimrc文件中所以实际使用中放在模式行中的设置通常是针对某一文档的专有设置。需要在不同的电脑上编辑/查看同一份文档时为了使用同样的设置也会使用模式行（如Vim的文档）。

vim: tabstop=4
    正确显示制表符，使文档在不同的机子上有一样的制表符宽度
vim: tw=48 fo=tqamn ts=4 expandtab
    写文章。使用48个半角字符文本宽度（24个汉字）；序号缩进及汉字支持的格式选项；用4个空格代替制表符；
vim: enc=latin1 guifont=terminal:oem:h10:w8
    查看ANSI编码的图形字符（Windows环境）时所用的设置。用来写/看nfo文件。
vim: nowrap tw=0 wm=0 backup
    我在行对行翻译时经常使用的设置
vim: fdm=marker
    设置折叠规则。关于折叠（folding）我们在以后会讲到。
vim: ft=xxx
    设定filetype。关于filetype在以后会讲到。 



6 下一篇

模式行的使用方式是比较容易掌握的，但它的价值也比较容易被忽视。希望通过这一篇教程能让大家对模式行有所了解。下一篇我们要讲的是折叠（:help Folding），下次见。




Previous: Top

Appendix A 为什么我添加了模式行却没作用？

    * 首先检查一下`vim:‘与前面的文本之间有没有一个（半角）空格。
    * 其次模式行要求在文件开头的前N行或后N行中，如果没在这个范围内模式行就不起作用。modelines用来设置N的具体数目。比如`:set modelines=8‘这个命令将模式行的有效范围设在了前8行和后8行。
    * 最后看有没有设置`'modeline'‘选项。modeline选项在Vim中默认是开的但也有可能因为一些原因被关上了，比如设置了nomodeline或是没有设置nocompatible。 

[ -结束- ]

转自http://blah.blogsome.com/2006/04/05/vim_tut_modeline/

22 10, 2010
Vim进阶教程
作者 helloxchen 12:34 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM

Vim是什么？如果你还不知道的话，那恭喜你，你刚邂逅了史上最强的文本编辑器。Vim已经是现在最主流的Vi类编辑器了，除了超强的功能外对中文的完美支持使之成了中文用户使用Vi的唯一选择。这里下载Vim6.4（Windows）。

很难相像Vi——这个*nix界最有名的文本编辑器在早几年对很多中国人还是一个全新的名词。直到近几年，随着Linux在中国的发展这种情况才改观了一点（只是一点点）。Vi用户数目并不因Linux用户的增加而快速增长，这主要是因为大家对Vi的了解（包括现在要讲的Vim）还不够。很多人对Vim的了解相当有限——有些甚至是错的：

Vim只能在命令行使用
    试试`vim -g‘或gVim 
Vim不能用鼠标
    同上 
Vim只有Linux上有
    几乎所有平台都找得到Vim 
Vim不如Emacs；
    Emacs能下象棋能收邮件，但是你要的是文本编辑器吧？ 
进入Vim后没法输入文字也没法退出……
    对了与其他编辑器不同的是，在初次使用Vim之前最好先知道一个键盘命令`:q!‘。 
Word功能比Vim强大
    首先：Vim不是字处理软件。其次：在文本编辑来讲Vim要强得多。再者：没有人用Word来写程序程序代码。最后：用Word要钱的。

Vim是程序员用的
    程序员用Vim有很好的优势他们更容易接受Vim的设计理念，更容易掌握Vim脚本。写程序可以用到很多Vim的高级功能……从这些点来说Vim对程序员来说很好用。但不等于是程序员专用。如果你每个礼拜在电脑上写的东西超过100个字，那你就应该用Vim。 
那么多指令根本学不完？
    你不需要学那么多指令，掌握几个基本的其他就视自已需要与否慢慢发掘吧。 
学Vim要很久
    的确是的。看一下David Rayner（best of vim tips的作者）是怎么说的：

        David Rayner (zzapper) 15 Years of Vi + 4 years of Vim and still learning 

    他学了十几年还在学:-)。如果仅是从入门的话，Vim自带的教程跟着做几遍大概一两个钟头。然后每天再用Vim半小时的话，基本的移动指令和编辑指令只要三四天就够了。而且只会这些命令时编辑的效率就已经有很大的提高了。 

虽然使用Vim所带来的效率和“快感”不是一般的编辑器所能比拟的。不过客观地讲Vim的确不好学，这里说的不好学并不是技术上有多难而是缺乏好的字习资源：

    * 中文文档太少，仅有的中文文档中会罗列成百上千的指令，把一些可怜的初学者吓呆了。
    * 文档缺乏系统性，较杂乱。
    * 中文用户少，缺乏一个可以交流的团体。
    * 文档中优点不突出。很多人学了很多指令却对宏/Vim脚本一无所知，而他们找到的文档中通常要么不涉及这些议题要么这些议题被淹没在无尽的指令中。 

其实Vim自带的文档是比较好的系统、详细、完整。除了是必备的参考资料外也是很好的教材。但缺点是Vim的文档中内容太多。其中包括了大量的键盘命令和其他内容这使得一些Vim的一些重要内容很容易淹没在大量的信息中。

为此我计划写一系列的教程。这系列的教程将会涉及一些Vim的高级议题。同时尽量避免大量的键盘指令——有时候Vim为一个问题提供了100个指令，但用户只需要掌握一种就足以解决问题了。虽说是高级议题但不并不以用户掌握大量基础知识为前提。事实上每个用户都可以看，包括相了解Vim编辑器但还没选择 Vim的人。我的目的是写一份关于高级议题的进阶索引，让用户对一些Vim的高级功能有所了解。每篇教程会围绕一个主题展开用最短的篇幅让用户了解相关知识。我希望这系列教程能将一些高级的议题串连起来，让一些想深入学习Vim的用户能少走弯路成为快速进阶。

22 10, 2010
Vi/Ex编辑器教程[4]
作者 helloxchen 12:30 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
第四章 替换命令
目录

    * Vi/Ex编辑器
    * 第四章 替换命令
          o 对当前行进行替换
          o 更多的字元
          o 在替换式样中使用的字元
          o 替换命令的其他用法
          o 脚本入门
          o 看好你的文件
          o 读者来信
          o 下一篇 
    * Appendix A 答案 

除了在这篇教程的上一篇中讲过的全局命令（:global）外在行模式命令中就数“:substitute”命令也就是替换命令最为精细和复杂了。在讲完复杂的部分后我们就会开始接触那些用以构建强力行模式命令串的技巧和窍门。



对当前行进行替换

你们中的大多数人应该已经知道替换命令的最简略的写法是“:s”并且已经以这种形式：

     s/previous/former/
     %s/Smith/Lee and Smith/

分别用来为当前所在行做替换和对文件中的所有行作替换。你如果已经在使用这两种形式的替换了，那你的学习进度已经超前了。有太多的课堂讲师和教课书的编撰者都告诉你要在所有行中替换某个短语要使用类似下面的命令：

     global/Smith/s//Lee and Smith/

这只是在浪费时间。两种的形式干的是一样的活，但第二种形式要用掉更多的输入时间和电脑解释命令的时间。在两个版本的命令中不管文件中是否每行都有要替换的“Smith”亦或整篇文档中只有一个“Smith”，替换命令都能很正常并且安静地完成工作。

但两种形式的命令都不保证对文件中所有的“Smith”进行替换。替换命令在默认情况下只对行中出现的第一个目标字串进行替换，因此像下面的这一行：

     inure to Smith's benefit only if Smith shall

在运行完两个版本中任一版本的替换命令后成了：

     inure to Lee and Smith's benefit only if Smith shall

这个问题有一个行模式内建的办法：要对一行中所有的目标字串进行替换可以在替换命令后加上小写字母“g”，就加在最后一个“/”后。因此使用如下命令：

     % substitute /Smith/Lee and Smith/g

原来的行会被替换成：

     inure to Lee and Smith's benefit only if Lee and Smith shall

上面的命令稍加变化就更应用在其他场合上。假如正在处理一些表格，并想每行中的最后一个“k37”改为“q53”。可以用这条命令：

     % substitute /(..*)k37/1q53

这样就行了吗？如果你觉得讶异的话，那就请记住：在搜索中使用通配符时，编辑器总是让通配符所匹配的字串尽可能长。这个例子中被匹配的字串从行开头的第一个字符开始一直到最后一个“k37”。

现在你应该试着举一反三。使用什么命令才能仅替换每行中的倒数第二个“k37”呢？这有点小难，所以我提供了一个参考答案可以和你自己的答案做个比较（见附录）。



更多的字元

替换命令用搜索式样（即替换命令的left-hand-side pattern，简记为lhs）来指示要被替换的文本。而，也许你已经知道了，你并不是每次都要输入同一个搜索式样。如果你想要重用上一次使用的搜索式样可以使用空的搜索式样来表示上一个搜索式样――不一定要在替换命令中，在其他情况也一样。因此下面的两条命令是一样的。

     /Murphy/ substitute /Murphy/Thatcher/
     /Murphy/ substitute //Thatcher/

两条命令都会到包含“Murphy”的行，并将第一个“Murphy”改为“Thatcher”。

用来表示地址的搜索式样中使用的字元，同样可以在替换命令中的搜索式样中使用。此外还有两个字元是替换命令独有的：字元“(”和“)”。 这两个字元本身并不匹配任何字符，因此：

     substitute /^The cat and small dog show/
     substitute /^The (cat) and (small dog) show/

从给出的部分来看他们是一样的命令。但替换命令除了查找匹配式样的字串外还能记住字元对“(”和“)”中的搜索式样所匹配的字串，以便在替换文本中使用。当替换式样中包含“1”时，编辑器会将该字元（1）替换成在字元“(”和字元“)”之间的式样所匹配的字符或字串。而替换式样中的“2”则会被第二个“(”和“)”字元对中间的式样所匹配的字符或字串所替代。依此类推――在一个替换命令中最多可使用9对这样的字元。在被替换文本中的字元对甚至能嵌套：左起出现的第一个括号对用“2”，依此类推。所以如果将上面的命令补充完整：

     substitute /^The (cat) and (small dog) show/My 2-1 fair

在被替换后的行的开头部分就像这样：

     My small dog-cat fair

又或者你输入了：

     substitute :up (and )(over )(the sky):212123

会对下面的第一行替换，替换结果如第二行所示：

     up and over the sky
     over and over and over the sky

（我在上面的例子中用了冒号“:”来做为分隔符来分隔替换命令的不同部分。之所以没有用“/”则完全是为了方便读者阅读――因为读者很容易将“/”、“”或“l”和“1”弄混。）

如前一个例子所示，对于简单的文本搜索式样而言“(”和“)”的用处不大。它们真正的价值只有在搜索一些容易输错的文本时才体现出来，可以避免因手工输入而在被替换式样中输错的可能。

有时你会用一些文本或式样来帮助搜索定位，这部分的内容将在替换时被放回原来的位置。这时这两个元字符就能派上用场了。（为了准确地圈定被替换文本我们通常需要在式样中包含该段文本周围的文本以帮助定位，这些帮助定位的文本在替换后会被放到原来的位置上。）这里有三个这种替换方式的例子：

     % substitute :([Ss]ection) ([0-9][0-9]*):1 No. 2:g
     /([Ss]ection) ([0-9][0-9]*)/ substitute ::1 No. 2
     % substitute ,[Aa]nswer: ([TtFf] ),ANSWER: 1,g

第一个例子中，仅仅是将“No.”插入到文档中的“Section”与号码之间。“(”和“)”的作用就只是将原来的section和其后的号码保留起来，这样在替换后它的第一个字母S的大小写就不会改变。

第二条命令的作用与第一条命令差不多，但第二条命令只对跟当前行最近的一个匹配项进行替换（不对当前行的匹配项进行替换）。这里的特殊之处在于我在地址式样中使用了“(”和“)”。当然，行地址本身并不使用这两个字元，但这也不会影响它找到正确地地址。行地址在寻找自己所匹配的行时会将这两个字元忽略，但在接下来的替换命令重用了上一个搜索式样时，这两个字元也会做为搜索式样的一部分一起传给替换命令。第二条命令就是这样情形。

第三例子对整理习题答案很有用。它查找每一个“Ture”或“False”判断题的答案，并将词“answer”转成大写。这条命令的创新之处在于：它在单词 “answer”后面查找“T”、“t”、“F”和“f”（即上面提到的帮助定位的文本），这样当后面的答案是数字而非“true”或“false” 时，“answer”的大小写就不会发生变化。另外用来表示“true”与“false”的字母（“t”“f”），在替换后并不会发生改变。但是这个例子的教育意义大于实际意义――因为稍后我们会看到有些字元可以轻易地完成这个例子所完成的任务。



在替换式样中使用的字元

当你想通过替换命令来添加一些字时，你可以使用一些仅在替换式样（替换式样即替换命令的right hand side，简记为rhs）中使用的字元。它们与搜索式样所使用的字元完全不同。

&
    在替换式样中，“&”表示替换命令中的被替换部分的文本。当你纯粹想加入而不是替换一些文本时就使用这个字元。例如：要将“kit”改为“kit and kaboodle”（忽略kit首字母的大小写）时，可使用如下命令：

              % substitute /[Kk]it/& and kaboodle/g
         

    如果你关掉了“magic”选项，就必须在“&”前加上反斜杠以使用它的元值。而在打开magic选项后，在“&”前面加上反斜杠可以让它成为一个普通的字符。

~
    “~”用来表示在上一个替换命令中的替换式样。使用这个字元的一个范例是用来改正某一个字词的各种拼写错误：

              % substitute /[Ff]anstock clip/Fahnestock clip/g
              % substitute /[Ff]ahnstock clip/~/g
              % substitute /[Ff]ahnstocke clip/~/g
              % substitute /[Ff]annstock clip/~/g
              % substitute /[Ff]anestock clip/~/g
              % substitute /[Ff]aenstock clip/~/g
         

    如果你关掉了“magic”选项，就必须在“~”前加上反斜杠以使用它的元值。而在打开magic选项后，在“~”前面加上反斜杠可以让它成为一个普通的字符。

U
    “U”字元使其后一直到替换式样结束的所有字母转成大写，除非中间遇到了可将大写功能关闭的其他字元。下面是将某段文本全部转成大写的命令：

              1 , substitute /.*/U&
         

L
    “L”字元与“U”的作用正好相反：其后的所有字母将被转换成为小写。可用如下命令将文本替换为小写形式：

    % substitute /FORTRAN and COBOL/L&/g

E
    “E”字元用来限制“U”或“L”的作用范围。在“E”之后的字母将保持原来的大小写形式。下面的命令将当前行用大括弧括起来，并将第一个单词转为大写形式：

              substitute :([^ ]*)(.*):{U1E2}
         

    如果你想要将“U”换为“L”你不需要在它们之间加一个“E”，反之亦然。当“U”或“L”的某一个出现时，另一个字元的作用停止了。假设你有一份书名的清单――每行一个书名并且只有每个单词的首字母大写，你现在想将书名中出现在冒号（“:”）之前一部分大写，而其余部分小写，只要输入：

              % substitute ,(.*):(.*),U1:L2
         

u
    这个字元将紧随其后的那一个字母转为大写形式。如果在该字元后的不是一个字母，则“u”没有作用。

l
    与“u”一样，不同之处在于“l”将紧随其后的那个字母变为小写。 

在替换命令中重用式样还有一点需要注意。当含被替换文本的式样（lhs）被部分或全部用于替换命令中的替换式样（rhs）时，该重用命令引用的是前者所匹配的结果，即替换命令引用前面的式样时，并不引用式样中的字元，而是直接引用前面式样中字元匹配的结果。反之亦然。这样做的原因是，替换命令两边所使用的是不同的字元，字元在两种类型的式样中的含义不同，字元在原来的环境中有意义在新的环境中则未必，因而，只能是引用结果而不是字元。

不过当一个被替换式样被重用于另一个被替换式样中时，或者当一个替换式样被重新用于另一个替换式样中时，重用命令只是简单地将原来的全部字元带到新在式样中，这些字元将在新的位置中重新对文本进行匹配。因此在这种情况下，重用命令的匹配的结果，并不一定与原来匹配的文本一样，因为它引用的只是字元而不是结果（译注：同样字元在新的位置可能会匹配新的值，如'/^./'匹配的是每行的第一个字，但不同行的第一个字可能是不一样的。而上一段所述情形中因为引用的是结果，假设'/^./'在上一次使用时匹配的是“在”，那重用时引用的是就是“在”。）。

现在我们再来做一个练习。有一个文件，我们想将其第237至289行中的每个单词的首字母大写，其余的字母小写。但我们事先不知文件中的大小写情况，有些行可能整行都是大写，或者都是小写，甚至是大小写交杂。我们假设词与词之间用空格隔开。有没有办法简单地用一条行模式替换命令来达到我们的目的呢？做这个练习需要的一些东西，我在文中并未直接提及。所以如果我的答案比你的要简单得多也不要觉得沮丧。



替换命令的其他用法

虽然“:substitute”是名称是替换命令，但它并非一定要从行里取出取出一些东西，然后再放一别些东西到原来的位置上。下面这个例子中，替换命令将一些文本放到指定范围内的所有行开头――它只是加入了一些内容，并未替换掉什么。

     537 , 542 substitute /^/WARNING:  /

下面在命令执行前的文本：

     The primary output line carries very high voltage,
     which does not immediately dissipate when power to
     the system is turned off.  Therefore, after turning
     off the system and disconnecting the power cord,
     discharge the primary output line to ground before
     servicing the output section.

现在变成了这样：

     WARNING:  The primary output line carries very high voltage,
     WARNING:  which does not immediately dissipate when power to
     WARNING:  the system is turned off.  Therefore, after turning
     WARNING:  off the system and disconnecting the power cord,
     WARNING:  discharge the primary output line to ground before
     WARNING:  servicing the output section.

使用替换命令来移除一部分的文本也是比较实用的技巧。下面的两个命令就是这方面的例子：

     % substitute / uh,//g
     . , $ substitute / *$

后一个命令将行末多余的空格删除。最后的两个斜杠可以省略，原因我们并不在原来空格的位置上置入新的内容。

上面提到的两种用法你可能会经常用到，那你一定没这样用过替换命令――既不增加文本也不删除文本。听起来这样做没多大意义对吧？这里就有一个这种用法的例子，在我写这一系列的教程的过程中我有时会使用这个命令。

     % substitute /^$

这里我帮你准备了一个不一样的练习：我已经给过你一条命令了――就是上面那一条命令。很明显的那条命令并未对文件进行任何的修改，那我为什么要使用这样的一条命令呢？要回答这个问题你需要有一些想像力，所以如果你需要“参考”答案的话也不要觉得不好意思。



脚本入门

现在你对这个编辑器已经有了不少的认识了，是时候尝试一些复杂点的编辑任务了。下面是一个简短的介绍，通过介绍你可以一窥写编辑脚本的这门艺术。

自下而上的编程方法。通常这是构建复杂编辑命令或命令脚本的最好方法。这里使用的是一个编程的术语，意思是先独立地处理每个细节的问题再将它们放到一个统一的架构中。而不是由一个整体的架构开始，再去强迫细节来适应这样一个架构。

例如：来自加洲旧金山的读者R.T.问道“如何能让vi编辑器自动地在每一段文本前后加入HTML的段落标签？”也就是说要在每一段第一行之前加上段落的开始标签“<p>”，而最后一行后加上“</p>”标签。在这些文本中，段落与段落之间将由一完全空白的行（行里不能有空格，甚至不能有不可打印字符）分隔。

这看起来相当容易。我们只需要找到先空行，先后在每个空行处向上移动一次来插入结束标签，再移到空行下以插入开始标签。但下面这个相当直白的命令还是有些瑕疵：

     global /^$/ - substitute :$:</P>: | ++ substitute /^/<P>/

第一个问题是：许多文件开头处会留一空行，而当编辑器找到这一行时它会试图上移一行，但因为没有上一行所以它无法完成第一个替换操作并且还停留在原来的位置上。这时当它下移两行时，它变成在段落开头的第二行而不是第一行――很显然我们并不希望将开结标签放在这里。不过我们有一些办法来解决这个问题：

让编辑器标识（:mark）空行，再去进行第一个替换，然后回到已标识的行，下移一行并进行第二个替换操作。

将第二个替换操作的地址由“++”改为“/./”，使之移至下一非空白行再进行操作。这样不管当前行是在一空行上或在在空行上面一行，“/./”都能将替换命令带到下一个段落的第一行。

将上面的命令分成两条。仍使用:global来查找空行，但每条命令只执行一种操作（加入开始标签或结束标签）。

第二个问题是：在两个段落之间也许有不只一行空行，这些空行并不会影响HTML页面的显示。如果编辑器依前面的命令中找到了空行，而这一空行是在连续两行甚至多行空行中的第一行时，我们在开头给出的命令中的第二个替换命令会应用在第二行空行上。然后:global回到第一行空行，然后移到下一“空行”――而这一行正是刚进行完替换的那一行（当然，此时这一行因为刚增加了一个开始标签已经不是空行了。但是记得吗，在执行后面的替换命令之前:global已经先对所有的行进行标识了），并对其运行第一个替换命令。也就是说一段像下面这样的文本：

     at this meeting, so be sure to be there!
	
     At next month's meeting we'll hear from the new

在修改完后应该像这样子：

     at this meeting, so be sure to be there!</P>
	
     <P>At next month's meeting we'll hear from the new

但实际上修改后的结果却是：

     at this meeting, so be sure to be there!</P>
     </P>
     <P>
     <P>At next month's meeting we'll hear from the new

当然这个“灾难”似乎可以通过将上面针对第一个问题的第二个解决办法做点修改来避免。也就是前两个替换命令前面的地址改为搜索式样形式的地址，分别向上和向下找寻第一行非空行再执行替换操作。当对连续的空行中的第一行命令时，这的确能行。但从第二行开始，替换命令会对已经添加标签的行重复添加标签。于是示例文本现在看起来像这样子：

     at this meeting, so be sure to be there!</P></P>
	
     <P><P>At next month's meeting we'll hear from the new

多重执行条件。其实，这里需要的是双重的执行条件。即替换命令执行前要先同时满足两个条件：

    * 被替换行紧邻当前所在的空行
    * 被替换行本身不是空行 

编辑器能应付这种情况。当限定替换命令中的地址只能上移或下移一行时，命令中的 :global 部分就能满足第一个条件的要求。（在前述第一个问题的第一个和第三个解决办法中都能很好地满足第一个条件。）要满足第二个条件可以让替换命令从现有行中移除一个字符，然后再将它放回去（即替换文本与被替换文本是一样的）。这可以确定一个行是否空行，空行的话则替换操作失败。

第一和第三个解决办法经简单修改都能满足第二个条件。下面的示例命令中我用了第三种解法，因为它所使用的技巧比第一个更好理解一点：

     global /^$/ + substitute /^./<P>&/
     global /^$/ - substitute :.$:&</P>:

再给个更进一步的例子，就能对自下而上的技巧有更深入的了解。读者R.T.可能将大标题和副标题放在一起了，并且可能已经在大标和副标的前后都加上相应的标签了。作为练习你可以思考一下如何修改之前的命令，使之在加入段落标签时能跳过前面或后面已经有HTML标签的行？提示――一个HTML标签总是以“<”开始，以“>”结束。只需要对之前的命令作少量的修改就能完成这个练习，所以你可能不需要看解答除非你想再确认一下答案。

小技巧。要充分地发挥命令的威力我们需要灵活地使用替换命令。有时是“非常规”地使用替换命令，但――有什么关系呢？管用就行。这种使用方式可能是当初这个编辑器的作者所未料想到的。下面是其中一些可能会对你有用的技巧。

你没法对跨行的内容进行替换――至少不能直接替换。如果你以为在替换式样和被替换式样两边多放一个换行符的方法可行的话，那你就错了。但如果你将全局命令与替换命令结合使用的话，你通常能够得到与跨行替换相似的结果。

假设这样一个情形：你需要对一份很长的文档进行修改。所有的“Acme Distributors”都要改成“Barrett and Sons”。一个简单的替换命令能够完成大部分的修改工作，只是会漏掉“Acme”出现在行末而“Distributors”出现在下一行开头的情形。再补充两条替换命令分别对行头的“Distributors”和行末的“Acme”进行替换的话可能会带来破坏性的结果――这篇文档中也有“Acme Supply Co.”的纪录，并且还有其他三间公司的名字是以“Distributors”结尾的。

但下面的两条命令能很好地解决我们所遇到的困难：

     global /Acme$/ + substitute /^Distributors/and Sons
     global /^and Sons/ - substitute /Acme$/Barrett

第一条命令找到所有以“Acme”结尾的行，然后下移一行，只有下一行以“Distributors”开头时才将 “Distributors”替换为“and Sons”。第二条命令是第一条命令的逆操作，确保只将符合条件的“Acme”替换为“Barrett”。（注意：第二条命令中全局命令查找的是“and Sons”而不是“Distributors”，因为在第一命令执行过后被换行符分隔的“Acme Distributors”已经被替换为“Acme and Sons”了。）

分步骤地对内容进行修改是一个好的编辑策略。通过对需要修改的部分逐步进行修改来获得想要的结果。想象一下，你现在是一位技术专栏的写手你刚为相当数量的相片写完标题――都是些类似“右边上方光源”或“左边边缘暗色调”的标题。随后你就得到了艺术总监将在排版时以水平翻转的方式使用相片的消息。突然间在“右边”的变成了在“左边”，而在左边的变到了右边。

现在你需要将标题中的“左边”和“右边”，互换。但除了在文档中逐个搜索替换外，还有更好的办法吗？下面的看似直截了当的两条替换命令可不怎么管用：

     % substitute /左边/右边/g
     % substitute /右边/左边/g

第二条命令并不能达到将原来的“右边”改为“左边”的目的。在进行完第一条命令后标题中只剩下“右边”，而第二条命令又将所有的“右边”换成了“左边”。我们需要使用一条过渡用的替换命令来达到我们的目的：

     % substitute /左边/QQQQ/g
     % substitute /右边/左边/g
     % substitute /QQQQ/右边/g

第一条命令将“左边”暂时地更换为“QQQQ”（当然也可以是任何未在文档中使用的字串），这样你就可以放心地使用第二条命令了。然后在运行第二条命令后，第三条命令再将“QQQQ”换成你将要的字串。

有时故意输入错误的文字，再使用替换命令将它们改回来并不全然是找罪受的举动。当我在写纯文本格式的文档时，我经常使用一些文本“线”段来分隔主要的段落。有些人简单地用一串的短杠（或其他单一字符）来做分隔线，但我喜欢使用有多字符组成简单图案的分隔符。下面是这种分隔符的几个例子：

     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	
     -+--+--+--+--+--+--+--+--+--+-
	
     *~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
	
     [][][][][][][][][][][][][][][]

其实我没那么大的耐心去输入一整行的不同字符――尤其是当我必须不停地按Shift键时。我只要按住任意一个键让它占满一行――不管这是哪个字符再后都将被改为我想要的图案。对于上面的四个图案，我只要先分别输入下面四行：

     ------------------------------
	
     ------------------------------
	
     ******************************
	
     [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[

然后我只要运行几条相似的替换命令就能得到我想要的分隔符了。这里是我对上面四行分别使用的替换命令：

     substitute /--/-=/g
     substitute /---/-+-/g
     substitute /**/*~/g
     substitute /[[/[]/g

半自动替换。在文本编辑中有一些替换操作相当依赖于人的判断和观察，无法完全使用自动的替换操作来达到我们的修改目的。但在有些情形下我们仍可以通过以下的两种手段让编辑器完成部分的修改工作。

第一种是使用替换命令的修饰符使用之在进行替换时提示――这时用户可以选择进行或不进行替换。你只需要把“c”放在替换命令后面就可以以这种方式进行替换。如果你同时还使用了“g”就可以对行中所有所有符合被替换条件的字串进行操作，请参考下面的例子：

     % substitute /^someth
     ing/something else/c
     % substitute /something/something else/gc

vi编辑器会在屏幕上逐一显示即将进行替换的行。在被替换文本的下面会有“^”的标志，像这样：

    something in the air. The consensus is that
    ^^^^^^^^^ 

如果在即将进行替换的行中有两处或两处以上符合条件的被替换文本，该行会被多次显示。并且每次“^”标志将指向准备操作的被替换文本，等待并接受用户输入直到用户输入了回车。如果你的输入以“y”开始不管你要输入什么，替换都会马上进行。如果输入的是其他的内容，则不对当前文本进行任何操作。

不过这种形式的替换操作对你来说可能还不够灵活。你可能需要通过观察更多行才能决定是否该进行替换；又或者在不同的位置你需要使用不同的文本来代替原来的文本。在这些情况下，我们可以借助:global命令的一个特性来解决问题。这是我们的程序员同志小何用过的技巧的一个简化版本（见本教程的第一篇）。

和以前一样，如果你在可视模式下的话你要先输入大写的“Q”进入行模式。在行模式下的冒号提示符后，输入下面的命令（假设你要进行与上一个例子一样的替换）：

     global /something/ visual

这条命令依序将你带到包含字串“something”的行, 并自动转入屏幕编辑模式。在你观察并做完替换后（如果需要的话），只要输入大写的“Q”就可以离开屏幕编辑模式回到行模式，这时global命令会继续执行并将你带到下一符合条件的行并重新进入屏幕编辑模式。

不过，在离开屏幕编辑模式的时候要当心一些意外的状况. 那可能使我们失去所有的修改，甚至是丢失整个文件。这听起来很糟，因而我们接下来将对如何保护劳动果实方面的议题进行探讨。



看好你的文件

vi/ex 编辑器在预防用户误操作进而引起灾难性后果的能力稍嫌不足。当然这也是当用户被赋于充分编辑自由的必然后果。不过如果我们编辑了老半天，修改的成果却没被保存下来；或者不小心丢失了原本的文档时，我们当然希望编辑器能够在我们灵巧的手犯错之前能给点提示。幸运的是用户还是有很多方法可以用来保护自己免受灾难“眷顾”的，我将在下面提供一些方法：

在紧急情况下。这个编辑器有一个基于保护目的的功能可能会偶然地造成灾难性的后果。你可能已经知道当你用vi编辑时你只是在编辑文档的一个幅本，而不是原本。在你使用写入命令（:write ， 缩写是:w）或以正常方式退出编辑器之前并不会影响原文档。这本是很好的保护机制用来防止这个威力过于强大的编辑器偶然地“损坏”你的文件――更糟的是你可能事先没有备份。

你正在编辑修改的文件幅本处在一个相当不确定的环境中：操作系统可能崩溃或断电，你会因此丢失文件副本――而你做的修改都在文件副本中。副本丢失后你之前所做的工作就打水漂了。阻止灾难侵袭的第一道防线就是经常地使用:write命令――每使用一次写入命令，你所做的最新的修改就会被保存到稳定的磁盘空间中。

那如果不想动到原来的文档呢？如果想把编辑的结果保存为新文件，不更动原来的文档呢？这样的话你需要对写入命令进行一些“加工”。输入：“:write nufile”。看你想要新文档起什么名字，将“nufile”改为你想要的名字。（如果你不希望保存到当前文件夹下的话，那你还要在文件名前加上路径。）这条命令会将修改后的文档保存到新的文件中――原文档则保存不变。

但上面那种保留原有文件的方法还是有风险的。因为只要有一次你在使用:write命令时，在输入文件名之前“不小心”按了回车，那你原来的文件就会被覆盖。所以上面提供的技巧还是在你既想改变原来的文档又想另存为新文件的时候使用吧。当你进行完一阶段的修改编辑工作后运行下面的两条命令：

     write nufile
     write

然后再继续对文档进行编辑。

避免误修改原文档的更稳妥的办法是用这条命令开始你的编辑工作：“:file nufile”――也可以写成这样：“:f nufile”。在运行该命令后编辑器就会把“nufile”当成是当前修改中的文件的名称，再使用写入命令时就会自动写入到“nufile”中。（如果你一时忘了是否已经改了一个新的名字或忘了新的名字是什么时，直接输入“:nufile”不用带文件名，编辑器就会显示当前的文件名――还有一些其他的信息。）

天有不测风去。不管怎样做，我们还是有时会不巧地??上一些突发事件。后果是我们没还来得及保存的劳动成果就附之流水了。为了预防这样情况出现，编辑器会试图在崩溃的过程中保存你的文档。在一些情况下，用户会有一些时间来运行保存命令，比如你因为超出文件空间配额无法写入。这时可以输入:preserve命令（或者它的缩写形式:pre）这样当前的文档就能得以保留了。但进行这一操作还是有一些地方需要留意的。

preserve命令将当前文档保存到一特定的目录，如果目录不存在或不具可写权限就会操作失败。（这个目录的路径因不同的编辑器版本而有所不同。在大多数现代的Unix系统中这一目录通常是“/var/preserve”。）为了测试是否可以写入指定目录，可以在内容较少的文档中运行:preserve命令作为一种测试方法。如果结果是类似下面的消息：

     Can't open /var/preserve
     Preserve failed!

那你就得和系统管理员沟通沟通了。（你可以附上不能打开的目录及其路径以期尽快得到管理员的回应。）如果是类似下面的消息：

     File preserved.

目前为止还算顺利。下一个问题是使用:preserve命令时编辑器是否已经完整地将文档保留（:preserve）下来了，还是只保留了一部分――有些版本的vi编辑器就会在这里出状况。为了检查编辑器是否完整地保留了文档，将刚保留的文件恢复看看。

抢救保留下来的文件。在经历崩溃等突发事件或者使用了:preserve过后要试着恢复文档可以使用下面的两种方法。通常情况下你是在命令行下通过运行带“-r”参数的“vi”来恢复：

     vi -r novel.sect3
     vi -r

第一条命令打开你那经过“抢救”的文件“novel.sect3”，并将之置于编辑环境中。第二条命令并不打球编辑界面，而是显示所有经“紧急保存”的文件列表（即可恢复的文件列表），然后返回命令行。如果系统崩溃时你正在编辑的文件尚未取名，这个列表就很有帮助了。（没错，你的确可以在赋予一文件文件名之前就进行编辑。此时编辑器会先打开一新的工作区并等你稍后为之命名。）在这种情况下，编辑器在保存你的文件的过程中会为它命令，而你必须知道到底哪一个才是它的名字以进行恢复。

就如前面说的第一条命令根据你给的文件名，打开该文件的最近一份经抢救成功副本。如果系统崩溃已经不是一次两次了，那因你或由于系统原因让编辑器自动保存当前文件也可能不是一次两次了。如果最新的副本并不是最好的版本，那你可以选择不从最新的保存记录中恢复。而是改用编辑器保存的次新的副本。这个操作可以直接在编辑器中进行，只要输入“:recover”命令（或用简写的形式“:rec”）。这样最近的一个副本将被换成次新的版本。（因为你也经在编辑器中了，所以输入命令时不需要再给出文件名。编辑器在缺省的情况下以当前文件名为参数，否则编辑器会试图恢复你给的文件名的经保存的副本。）如果这还不是你要的那个版本，那你可以继续使用“:recover”命令。

不管用什么方式恢复，在恢复完后先浏览一遍。如果你所用的vi版本的preservation功能有缺陷，那你可能只得到一些散乱的字符，或是一些像这样子的行：

     LOST
     LOST
     LOST
     LOST
     LOST

如果是这样的话，那你之前用:preserve命令抢救下来的文件已经丢失并且这很可能是无法挽回的结果了――你只能找系统管理员建议他将这个编辑器升级到更好的版本。话说回来如果你看到的正是你要的内容的话，那要赶紧将它保存起来――自动保留的副本是你使用了恢复命令（:rec）后就会被自动删除，所以别指望下次还能用恢复命令找到同一份文件副本。

还有一个需要当心的地方。你可能相信当你使用 “ZZ”“:x”“:wq”这三条命令的任何一条退出编辑器时，编辑器会先检查当前编辑的文档是否被修改过，如果已经修改则先保存修改再退出。实际上这三条命令中只有最后一条:wq总是将当前文档写入文件（不管当前文档有没有被改动。），所以你应该只使用这一条命令保存并退出vi以策万全。

前两条命令会做一些检查，但只是简单的检查。具体来说前两条命令和“:quit”命令仅仅通过内部的一个修改标志来判断当前文档是否经过修改。这个标志在当前文档被修改时被设置，而当修改被写入文件后这个标志被清空。当你在使用了“ZZ”或“:x”命令或者是不小心用了“:quit”命令时你可能需要吞咽自已带来的苦果了。

之所以这样说是因为对于编辑器来说你打开一个新文件或是恢复一份经紧急保存的文档到工作区（buffer）都是一样的―― 都是视作未修改的文件。如果你使用的vi版本中ZZ与:x命令的检查机制比较松散那它会认为文件打开后并没有进行过修改而不予保存。这样一来编辑器会自作聪明的选择直接退出而你恢复文件的努力在临近完工之际功败垂成。所以所以记得一定要使用“:wq”来退出vi。当然你也可以选择分两步完成，先用 “:write”写入修改，再用“:quit”退出，结束编辑。

其他状况和应对方法。恶运还是可能随时降临。你可能会偶然地丢失自已所做的修改同时还破坏了当前编辑文件的原本。

想象一下如果你可能因误用全局命令而将当前工作区的文件弄乱，但碰巧全局命令修改的部分没在屏幕所显示的区域中。这时你如果使用了写入命令……惨！除了一些较小的文件以外，我们根本不可能在每次使用:write命令前先仔细检查一下当前编辑文件的内容。

也许你的确在写入之前及时发现了这个问题。并且意识到要撤消操作不太实际（因为你不知道是什么时候哪个操作造成的），这时你可以用“:edit”命令来放弃上一次写入操作（或打开文件）后的所有修改。也可以使用“:quit!”来放弃所有修改并退出编辑器。这两条命令都命令末尾使用了“!”以表示忽略还没写入的所有更改。

不过因为你并不是在写编辑器脚本所以你可能输入上面两条命令的简写形式:e!和:q!来代替完整的命令。但是你要小心别打字打错了――在标准的键盘上，“w”键被放在了“e”和“q”之间因而存在着打错字的“危险”。一旦你不小心打字打成了:w!，那就自求多福了――这条命令让编辑器强制将有问题的文件版本写入文件正本――不管有没有写保护。

如果你一直都在屏幕模式下进行编辑的话，那你还有最后一根救命??草。不管何时你都可以输入短短的命令系列来将文件退回到文件刚打开的状态（不管中间有没有使用写入命令保存修改，都能恢复到刚打开文件进行这一次编辑时的状态）。这时只要再用写入命令就可以将当前工作区的文件保存起来替换刚保存的有问题的文件。

输入“Q”离开屏幕模式回到行模式下。在行模式中有一条“undo”命令作用与屏幕模式下的“u”命令相仿。这条命令撤消在上一个在行模式中对当前文档所做的更改。因此，行模式下使用“visual”后对文档所做的“所有”修改也被视为是行模式下的“一次”修改。然后，当你在命令提示符中使用“vi novel.sect3”命令运行vi并打开相应文件后，命令解释器（shell）实际上运行的是ex（vi只是ex的一个别名），而编辑器一运行就给自己下了一条“visual”命令使文档在打开后自动处于屏幕模式下。

所以从头至尾，编辑器都有文件原本的一份完整的拷贝。这是它的职责，因为用户可能随时回到行模式下撤消初始的“visual”命令。（这也是编辑器使用的暂存空间比一般的交换空间要多的原因。）如果你想看看撤回到文件的初始状态并重新回到可视模式下所用的命令系列的话，这里是使用简写形式的版本：

     Qu
     w
     vi

最后一点提醒。对一些有经验的Unix用户而言下面的这样情况出现有些搞笑，但许多刚从单用户系统迁移过来的用户的确会碰到这种情况：除非你在少数有文件锁定功能的Unix版本中工作，不然你的的确确没办法预防其他系统用户在同一时间与你打开同一份文件进行编辑。

你们将在各自的工作区中进行编辑，你们完全没法获悉些时有人在编辑同一份文件。每次当你将修改写入文件时，另一位用户先前写入的修改将会丢失，反之亦然。在这场互不知情的较量中，获得最终“胜利”的将是进行最后一次写入操作的人。而另一位用户在一个多小时后再打开文件时会发现里面完全没有自己留下的编辑痕迹。

没有什么技术上的措施可以真正预防这种情况发生。你只能通过与其他可能需要对该文件进行编辑的用户沟通的办法来解决这一个问题。



读者来信

我们的一位读者对这一技巧提出了自己的问题。由于这个问题的重要性，我觉得有必要将回复放到这篇文章中。

    Walter，您好…

    你在教程中提到可以用下面这条命令

              global/XXX/visual
         

    搜索式样“XXX”，然后对其进行其他编辑操作（记得吗，小何用这条命令来编辑他的意式面条代码……）这就产生了一个疑问：如果文章中有100个“XXX”，而我只需要对前10个进行编辑，因此不需要再找其余的90个“XXX”了。上面的命令只要我一输入“Q” 就会继续找到下一个“XXX”。但我处理完前10个“XXX”处的代码了，我现在想要查看/编辑代码中有“illegal”字样的地方。所以我输入“Q” 然后使用命令global/illegal/visual。

    问题就出在这里：输入Q并不会出现提示符等待用户输入命令而是直接找到第11个“XXX”出现的行。我想知道的是有没有方法可以在我输入Q时vi不再继续执行global命令呢？

    致礼！

    Chris… 

如同Chris所意识到的，如果我们不想再搜索后面的90个“XXX”我们可以简单地忽略它们（只要我们不再进入行模式）。每次命令执行时会将用户带到可视模式下，但用户没有被限制一次只能对一个地方进行修改。你可以像平时一样随意地上下页翻动，对需要的地方进行修改――只要你愿意你可以一直待在可视模式下。而当你在可视模式下进行完所有编辑工作后，你完全可以像平时一样保存文件然后再退出编辑器。而那条在后台静静地等待你再回到行模式下（以执行下一步操作）的global命令，在你退出编辑器后也跟着结束了。不过如果我们想用同样的方法找到第二个字串时――正如Chris想做的那样，我们就需要用些迂回的方法。

走出困境的最好方式是先保存修改（使用写入命令）。然后，输入:edit命令――先别急着用Q。这个命令会重新从磁盘上重新加载当前文件到工作区中。因为你才刚进行写入操作所以重新加载的版本与你原来在修改的版本的内容是其实是一样的。同时因为你还没有离开编辑器，各种设置如有名工作区，键盘映射及缩略设置还有一些设置项还保留着。只有少数项目发生了变化如未命名工作区（缓存区）被清空了――而global命令也因此中断运行。现在你可以用Q键进入行模式下并运行第二条global命令了。



下一篇

这系列教程进行到现在，你肯定会对这个编辑器的某些方面不太适应。好消息是这其中有些东西是可以依用户意愿更改的――并不需要用修改源代码之类的方式来更改。在这系列教程的第5篇中，我会详细说明用以建立属于自已的编辑环境的一些vi/ex的内建功能及许多可以通过这些功能进行修改的元素。


Appendix A 答案

begin 644 viex4_ans
M5FDO17BQX+RMQO<*"K7:R35PL&WS["RSK^M/"PN`H*"@JAL&LS-Z&QSLK,
MX@H*)2!S=6)S=&ET=71E("]<*"XJ7"EK,S=<*"XJ:S,W7"DO7#%Q-3-<,@H*
MT/)S/FU>+,]</P>Z^S=#0P<NAH[6QR]'+]J]T?FCJ+&[S.:[NJ]T?FC
MJ=;0T]#!O;CVN_+2U,G/M<3-J,7DM_O*L:.LL>"K<;WN^'4VM?<S.7*O='Y
MQ-S&I<7DM<3'L,SAS*CK,JYM=K2N[CVS:C%Y+?[QJ7%Y+ZAOG$W+.DM<2S
MI+;(H:,*"@H*"@JAL+3ST*'0M*&QSLK,X@H*,C,W("P@,C@Y('-U8G-T:71U
M=&4@.EM>(%TJ.EQ,7'4F.F<*"M+RSJJAL%QUH;&ZS:&P7&RAL=?6U*JUQ-.P
MS^RUQ+>VSJ?3T,_>HZS+_,/'UKNVU,;DNO.UQ-*[N/;7UL2XT]#3L,_LH:/+
M^=+4LKN[X=;5UKFAL%Q,H;&L*&P7%6AL;7$U_?3PZ&C"@K7]]7?S.'*OJ.Z
MU-K0M,WJU>*X]K3PL+BY_;KSHZS.TK+%MZ+/UM3:T.VVX+7$=FFPYK&^UM#5
MXM;6M[VWJ-#0LKO-J*&CTO*TR[2T];4]KS3P<O/PL/FU>+6UKWBMZBAHOD
MR+N[X<_@MM2XM-33M:O4VK*[S:BPYK&^M<1V:<G/MKS$W,JYT.AHPH*,C,W
M("P@,C@Y('-U8G-T:71U=&4@.EPH6T$M6F$M>EU<*5PH6T$M6F$M>BU=*EPI
M.EQU7#%<3%PR.F<*"KRTRKG4VK7:TKO6UK#LMZC$W-#0M</-J+7$=FFPYK&^
MUM"CK+7:MO[6UKWBMZC2LM/0TKO0J;K#M*:CNK6QTKNX]K6EM,K6KL>PO?3!
MVM?%L>JUX[?[NL7*L:.LM=K2N];6L.RWJ,.[MZB]J[7:TKNX]M?6Q+C7JLZJ
MM//0M*.LMOBUVK;^UM;$W*&CQ.._R=+4U]2NK[VMJC*Q[?QO:O3R<&LU]:W
M^Z.H+:.IP:R]T[7$N+2ZS[3*HZC(YZ.Z1G)A;FMU<G0M86TM36%I;J.IRM/7
M]]*[N/:UI;3*N_+*Q[;@N/:UI;3*H:/(Y[G[Q.//Z[VKUJ[*TZJMN"X]K6E
MM,JRHKVKQN3/X-.FM<3*U]?6Q+BT]"TM<2[L*.LUKO2JKVKM=JV_M;6O>*W
MJ-;0SN6X]L&LU]:W^[7$U^ZZ]*[N/;(I;7TOLW0T,'+H:,*"@H*"@JAL+*[
MMJ_7]Z&QM<3,YKN[P_S![@H*UKO+T<OWRKW1^<3<LFYIK78QJ7%Y+*BQ]+#
MN]/0L_;/UK3MSO.UQ->TO_:CK+'@O*W&][[-N^'(SZJS.:[N[+9U_>SR;FF
MH:JAJKRTRKG+_-:[RL>]J[_5U]:TKJ.HLKO*Q[_5N/&CJ<SFN[O.JK_5U]:T
MKJ&CM;&QX+RMQO?-ZK/)LMG7][*BN/BS]J&PS.:[NZ&QM,[*_<JQHZS+_+CX
MM<3*M;S*R<^^S<K'SL2_M;0O]70T+7$ROW$OZ&CMOC-J+G]O]70T+7$ROW$
MO[2OLV_R=+4UJJUP,[$U<+6T-/0MN#)V;CVML["Y*.HP:RQZLSBO+#!T+'M
MS^ZCJ:&CSM*[N<3<S:BY_;VKT-#*_;/]TM2_U=#0ROW`M,70ML_*Q[?QMLZ[
MX<RKLZ2AHPH*"@H*"DA434RQZL>ISLK,X@H*SM+#Q]2MP+2UQ+>]MZC2JM3:
MTKNX]K;.PN36KL>PO-/)S['JQZFRR=/#M<2WO;>HRL>]J[7:TKNX]M?6Q+C2
MQK/]U-FPT=#"S.VT[7$L>K'J<&LS:RXU=+&L_VUQ+7:TKNX]M?6Q+BWQ;6]
MML["Y+^JS;>TIJ&CS];4VL[2P>[N<K'U>+1^=?VL_W!R[6QTKO0T-+4H;`
MH;'*L:&CSM+#Q[_)TM30WKC$P_S![LJYM<.UL;7:TKNX]M?6M_O*QZ&P/*&Q
MRK&CK+&[S.:[NJ]T?G&I<7DRJ>PW*.LU>+1^<SFN[O#_,'NOLVRN[OAUK30
MT*&CTJK7]K6]U>*UX]:[TJJ]JSFN[O*O='YUM"UQ+7CHZ@NHZG7UM2JN,3.
MJM*[N/;7UK?[H;`H;&UQ+*YO*^CJ*&P6UX7:&QHZG0SLJ]HZS5XM'YOLW$
MW,:EQ>3(SKK.M>_U=#0M<2_JLVWHZRS_;?'N,/0T-+42%1-3+'JQZF_JLVW
MH:,*"LVLP.VCK+_)TM2]JSFN[O*O='YUM"Q[<J^T-#$J;7$U]:W^[7$M>/7
MUM2JN,3.JK'MRKY(5$U,O>'*^+7$H;`^H;'7UK?[M<2RN;ROT,[*O:&CS+#
MYLK'T-ZXQ+KSM<3#_,'NH[H*"F=L;V)A;"`O7B0O("L@<W5B<W1I='5T92`O
M7EM>/%TO/%`^)B*9VQO8F%L("]>)"@+2!S=6)S=&ET=71E(#I;7CY=)#HF
'/"]0/CH*"@``
`
end
转自http://blah.blogsome.com/2006/06/18/vi_tut_4/


22 10, 2010
Vi/Ex编辑器教程[3]
作者 helloxchen 12:26 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
第三章 功能强大的全局命令
目录

    * Vi/Ex编辑器教程
    * 第三章 功能强大的全局命令
          o 全局命令的操作细节
          o 全局命令的例子
          o 现在换你了
          o 下一篇 
    * Appendix A 答案和提示 

你可能会因为我在上一篇的教程中没提到“:global”而觉得奇怪，不过“:global”其实不是一个地址。这事实上是一个行模式命令――全局命令，并且它的作用比大多数用户想像的要大得多。

就算是有经验的用户在想到全局命令时也会与下面的这些话联系在一起：“如果你输入了:global接着输入搜索式样，然后是行模式命令，把它们放在同一行。那么编辑器会对逐一对文件中包含匹配式样的行运行行模式命令”。也就是，在输入：

     global /^Chapter [1-9]/ delete

后，用户想到的是编辑器会查找并删除文件中所有以“Chapter ”1到9开头的行。没错上面的例子干的正是这事，这个命令的这种用法随处可见。但还是不时地出现误用，以下命令：

     global /^Chapter [1-9]/ write >> t.of.contents

就算是有一定经验的用户也可能会以为上面命令的作用是将匹配式样的行添加到名为“t.of.contents”文件中去，这当然是错的。（上面的命令更像是用来消耗磁盘空间的）



全局命令的操作细节

更重要的是，对全局命令的不了解让用户只能发掘到该命令一小部分的潜力，无法发挥它真正的作用。庆幸地是你再也不用受这种不了解的束缚了――在本文里我们会完整地呈现这个命令的方方面面。

在指定的位置搜索：

    与其他的行模式命令一样，全局命令之前也可以放一至两个地址。它的默认搜索范围是整篇文档，但如果你使用命令“257 , 382 global ….”时搜索会从257行开始一直搜索到382行（包括382行）。全局命令前可以放置所有类型的行模式地址，因此以“?^Exercises? +++ , $ global”开始一个命令时编辑器会回搜到的第一个以“Exercises”开头的行并以该行之下的第3行为全局命令作用范围的开端，这个范围一直到文件的最后一行结束。 

标识匹配或不匹配的行：

    输入全局命令“global”或“g”会使之对搜索范围内的每一行包含要搜索的式样的行进行标识。但输入“global!”、“g!”或“v”的作用则相反：现在它只标识未包含搜索式样的行了。如果你正编辑一个记录错误信息的日志文件，你需要的只是以“Error 3b:”开始行，那可以用以下命令将其他行删除： 

     global! /^Error 3b:/ delete

选择你自己的搜索式样分隔符：

    因为这个命令总是由上至下对整篇文档（或是你选择的范围）进行搜索，几乎所有的标点符号都能用来表示搜索式样的开始与结束。也不需要用“?”或“/”来选择搜索方向。如果你想要删除所有包含三个斜杠的行，这些命令：

              global +///+ delete
              global ;///; delete
              global ]///] delete
         

    都比使用斜杠作为分隔符然后为欲搜索的三个斜杠前分别加上反斜杠要来得简单。（但是使用“!”作为分隔符要当心，因为全局命令“:global”会把命令后的“!”当成指示全局命令搜索不含指定式样的行的一个开关符号。）

    当然这只对紧跟在全局命令后的搜索式样有效，这个搜索式样用来指定要标识的行。如果是在全局命令前的用来指定全局命令的作用范围的搜索式样，那么还得像往常一样使用“?”和“/”作为分隔符。 

看似无用的一些全局命令：

    有些时候，虽然只在文件中找一行，使用“:global”或“:global !”也是明智之选。当选择性的对行执行行模式命令时这是一种基本的技能。举个简单的例子，当你想要删除最后一行当且仅当最后一行是空白行时。你可以选择每次都自己移动到文件末尾然后看一下有没有附加的空行，但让编辑器去检查并删除（如果需要删除的话）会轻松一点，这时你可以输入：

              $ global /^$/ delete
         

    让全局命令标识你自己限定的范围内的所有行也是有实用价值的技巧！我们说过的程序员――小何（Hal，在这系列教程的第一章中出场过的）在倒置文件中的所有行时就使用过这一技巧。他所用的命令以完整的形式写出来就是：

              global /^/ move 0
         

    标识所有有“开端”的行，其实就是标识所有行（包括空行）。接下来该命令从第一行开始并将第一行移到虚构的行 ――零行之下。然后它再到第二行并同样把第二行移到零行之下，原来的第一行这时成了第二行。它对第三行做同样的动作，然后第四行，第五……。就这样它逐渐地将行的次序颠倒了。 

一个全局命令后能使用多个命令：

    可以在“:global”命令后使用多个命令和命令所用的搜索式样。在标识了特定行后，全局命令接着逐个对标识行依次（依照你输入它们的次序）运行所有命令。这些命令通过竖线（“|”）分隔。如果你输入了：

              global /^CHAPTER/ substitute /APTER/apter/ | copy $
         

    编辑器会对以章名（CHAPTER）开头的每一行执行替换，将“CHAPTER”换成“Chapter”，然后复制该行（现在是以“Chapter”而非“CHAPTER”开头了）到文件末尾。这两条命令（替换substitute和复制copy）的次序很重要，替换的命令必须在前，不然复制到文件末尾的就成了原来的全部大写的“CHAPTER”了。

    并没有限制说只能在全局命令后使用两条命令。对命令数目的上限并没有规定。对整条命令序列（与全局命令一起使用的多个行模式命令组成的序列）的长度的限制则依Vi版本的不同而有所不同。话说回来我从没遇到过这一长度上限小于256个字符的。但对于命令序列的使用方式有些规定：

        * 关键字“global”和后面命令序列必须在同一行中。（指的是“物理行”，中间没有回车符分隔的行，如果该行长度超过了显示设备的宽度的话，可以折行显示――当然这没关系。）
        * 命令序列不能包括“undo”（撤消）命令和另一个“:global”命令
        * 如果序列中包括一条在shell（命令解释器）运行的命令，那它必须是序列中的最后一个命令（在同一命令序列中使用两个或以上的sell命令是无意义的）。这样该命令才能在它的shell命令行中使用管道操作（“|”，与命令序列的分隔符是一样的），而不至于让编辑器分不清那是一个全局命令的分隔符还是一个命令行下的管道操作符。 

命令并非一定要在所有全局命令标识的行上运行：

    使用全局命令就如同用手工移至标识行上再运行命令一般。正如同有时你运行命令并不是对输入命令时所在行进行操作一般，全局命令中的命令序列也不一定要对所有标识过的行进行操作。这里有三点要强调的：

       1. 在全局命令后的任何命令都可以有自己的地址，与那些命令在单独使用时一样。因此这一命令串：

                         global /^XX/ - copy $ | /ZZ$/ , +5 delete
                    

          是完全合法的。它逐个地找到以两个大写X开头的行，上移一行，复制该行到文件末尾，然后向下搜索以“ZZ”结尾的行，并将该行及其下的五行删除。
       2. 在全局命令的命令串中即使你没有给出命令的地址，这些命令命令还是可能不会对全局命令标识的行进行操作因为它有默认的地址。这就是在本章的介绍部分中说的所说的全局命令的错误用法。因为写入（write）命令的默认地址范围是整篇文档，所以那条命令的作用是当每遇到一条全局命令标识的行就将整篇文档写进（添加到）另一个文件的末尾一次。要将全局命令标识的行写进另一个文档的正确做法是：

                         global /^Chapter [1-9]/ . write >> t.of.contents
                    

          在写入命令前面的“点”（半角句号）告诉写入命令只对它所在的行进行操作。
       3. 但全局命令后的命令序列中使用有默认地址的命令时，如果该命令不是序列中的第一个命令（即跟在“:global之后的命令”）的地址即使它有默认的地址，在没有给它自己的地址的情况下它也可能并不是用全局命令标识的行作为它的地址。原因：在全局命令的命令序列中每一条命令都以上一条命令结束时的所在行为当前行。 

    在我的之前的一个例子中，讲了如何将以“CHAPTER”开头的行改为“Chapter”并复制到文件末尾。那个任务本身很简单因为被复制的行都是已经被更改了大小写的行。那么如果希望文件中间的“CHAPTER”改为“Chapter”，而复制到文件末尾的仍是全部大写字母的形式时要怎么做呢？这看上去似乎只要对调一下命令序列中的两个命令的位置就行了，这样就可以先执行复制命令然后再执行用来更改大小写的替换命令，就像这样：

              global /^CHAPTER/ copy $ | substitute /APTER/apter/
         

    出乎很多人意料的是，这命令运行的结果与预想正好相反。这条命令会将复制到文件末尾的行的大小写更改而文件中的那些行的却仍然是全部大写的。究其原因，复制操作将行复制到文件末尾并在那里――而不是原来由全局命令标识的行结束复制操作。而替换命令以上一命令结束时所在的行（最后一行）为当前行。在没有明确给出地址的情况下替换命令的默认地址便是当前行，因而它会对文件末尾的行（复制的行）而不是原来的行（全局命令标识的行）进行大小写更改的操作。

    但有一件事是无论在命令序列中的“当前行”怎样地变化也不能改变的。当全局命令从一标识行开始运行命令时，不管命令序列最后在哪一行结束运行（这一行成了新的当前行），全局命令总是到下一标识行（而不是当前行）重新开始运行命令序列。要阻止全局命令从下一标识行开始运行，只能让命令序列中的命令删除下一标识行――但那样的话，全局命令就会移到下一未被删除的行开始命令。

    假设你想要对文件进行一些删减――每隔一行就删除一行。你可以用下面的命令：

              global /^/ + delete
         

    全局命令首先对每一行进行标识。当它来到行1时，它就执行命令删除行2。然后移到下一未删除行――行3，并删除行4，依此类推。或者如果你想要删除每三行中的后两行，输入：

              global /^/ + , ++ delete
         




全局命令的例子

上面的那些例子除了用来说明全局命令的工作原理外，还展现了它较鲜为人知的一些技巧。但上面的例子无法涵盖它所有的重要技巧。这而补充一些有价值的技巧。

计数。有时全局命令后面的命令序列与全局命令标识的行根本毫无关连，这些命令并不对全局命令标识的行进行操作。这种情况通常出现在我们需要重复运行一个行模式命令一定的次数时。

我经常受邀到一些展会上测试系统，就在展台上测试。我不能总带着一份有着10000行的测试文件，因为我事先不知那个系统对存储介质、格式有什么样的要求。我的做法当场新建一个文件并在其中输入10行，然后让编辑器复制全部并贴到文件末尾，如此反复十次。（每次复制都使文件的大小翻倍，所以最后文件中就有 10240行了。）

但那要求精确计算操作次数。如果我输入命令的次数出现的错误（就算是在前后一次的误差范围内）那我要么要得到一个只有我预想的一半大小的文件，要么有两倍大――这将毁了整个测试结果。但我不打算自己数操作次数，我让编辑器来替我数。在输完开始的十行后，我给编辑器一条命令：

     global /^/ % copy $

这条命令让编辑器通搜整篇文档，标识所有有“开端”的行（也就是所有行），然后对标识的十行逐一运行通篇拷贝的命令。这确保了命令会精确地运行十次。

注意这个技巧仅限于文件中的行数与要命令重复运行的次数一致时使用。如果我在文件中输入了20行，要将之通篇拷贝10次可以这样使用全局命令：

     1 , 10 global /^/ % copy $

自动移动。你可能不时地会需要应付文件中一系列的编辑问题，在没使用全局命令时你得一个一个地解决这些问题。但在这进行操作的点之间移动是件烦琐的事。如果有一个式样来找到这些需要编辑的点，或者你能写出一个脚本来将式样插入到这些地方的话――就你第一章中小何做的那样，那全局命令能自动带你到这些点。

你可能还记得小何用了一个脚本来对源代码进行标识，他将每行lint警告放在源文件中相应的行后，中间用“XXX”分隔以利于定位这些行。假如这个“无恶不做”的信息系统副主管又回过头来要小何仔细看一下这些行，看是否能通过重写这些行来消除“警告”作为补救的一种手段。

小何应该怎么做呢？要快速的翻阅这些代码，然后逐个找出那些用来识别问题行的“XXX”式样吗？小何知道他所面对是意大利面条式的代码，实际出现问题的地方与lint所指示的那些行可能会有的出入。在查找问题点的过程中他可能已经跳过了几个“XXX”式样，因而在文件中查找下一个“XXX”可能会将他带回他已经处理过的点，或者是漏掉了那些他在查找实际的问题点时跳过的几个“XXX”式样。此外，他在修复一个问题时频繁地使用式样搜索，这使得他无法在可视模式中使用“n”命令来快速地定位下一个“XXX”式样――他必须每次都重新输入式样。

但是小何知道怎么应付这些问题――回到行模式（在可视模式下输入大写的“Q”）然后使用一条简单的全局命令：

     global /XXX/ visual | write

这条命令让小何先回到“XXX”在文件中第一次出现时的所在的行，然后切换到可视模式等待小何编辑。在小何做完修改后，只要再输入大写的“Q”编辑器就会带他到第二个包含“XXX”的行，并回到可视模式。不论在前一次编辑中小何怎样地移动或进行何种操作，编辑器都能将他带到第二个包含“XXX的行”。然后小何只要在每次进行完修改后按“Q”就能到下一个包含“XXX”的行中。在每完成一次编辑后write命令会自动地将修改过的文件保存到磁盘上。



现在换你了

在你将全局命令的进阶技巧在实际工作中运用前，这儿有一些练习来让你练练手。我已经为每个练习提供了至少一种参考答案（见附录），还有一个提示是针对最后一个问题（也是最难的一个）的。

复制后改为小写。回想一下那个想把文中所有以“CHAPTER”开头的行复制到文件末尾的用户。除了复制外他还想把文中原来的那些行中的“CHAPTER”改为“Chapter”――但复制到文件末尾的那些行仍保留大写的状态。

现在我们已经知道下面的两条命令都不能完成这项任务了：

     global /^CHAPTER/ substitute /APTER/apter/ | copy $
     global /^CHAPTER/ copy $ | substitute /APTER/apter/

怎样才能用全局命令（:global）完成这项任务呢？有许多种办法，要找到一条不算太难。

准确的字串长度。一位老友在用troff1时做一些特殊的工作时需要在一行中插入连续的64个反斜杠。反斜杠的数目必须准确的为64个，不然troff不能正常地完成工作。在不费力数数的前提下，他怎样才能准确地输入64个反斜杠呢？

假设他要在第217行的字串“n(PDu”前面插入16个反斜杠。使用什么命令才能完成这一任务而免于手工数数的尴尬呢？如果知道要用哪些命令的话那答案就呼之欲出了。

为段落编号。一位文档的作者将每个章节又分成了多个段落。他是一个troff的用户所以他用将宏“.pp”单独置于一行作为段落的标记。所以段落间的是以这种方式分隔的：

     which is the only way that argon gas can be dissolved
     in this liquid.
	
     .pp
     The problem of energizing the
      argon to fluorescence while
     it is dissolved was first approached by applying a strong

这个技术作家要怎样用vi编辑器来为章节中的每一个段落编号呢？（你可能觉得这个问题有些“扯”，但就曾有一个Unix专家在电话中问我这个问题。）为了简化问题我们假设每个章节中的段落数不超过35，并且编号用罗马数字来表示。

这个问题还是有一定难度的，所以我要提供两个提示。第一个当然是使用全局命令了。在你已经准备放弃或要看答案时，可以先看一下第二个提示。



下一篇

在这篇教程的下一部分中，我会讲一些其他用来处理文本和文件的行模式命令，并会涉及到这些命令较不为人知的一面。如果你被本文中的全局命令的内容压得透不过气来的话，那告诉你一个好消息：替换命令要简单得多，事实上其他的命令都要比全局命令来得简单得多。

而在讲完了那些个命令后，这篇教程的后面的部分将会集中在可视模式上――比行模式要简单也更有趣。


Appendix A 答案和提示

答案用uuencode编码过。

begin 644 viex3_ans
M5FDO17BQX+RMQO<*"K7:R/W5PL&WS["RSK^M/"PN`K7]]7?H[I786QT97(@
M06QA;B!::6YT>@K2Z]7?H[IH<3`P92`*"@JAL+BTUL:Z[C$SJK0H="TH;'.
MRLSB"@J]SZJUK&PU[7$L.RWJ,K'H[H*"F=L;V)A;"`O7D-(05!415(O(&UA
M<FL@82!(&-O<'D@)"!("=A('-U8G-T:71U=&4@+T%05$52+V%P=&5R+PH*
MSBVU-2MRKRUQ-#0O?C0T-?WO,>ZQ:.HT-M87)KP_S![J.IHZS(N[KSO:O6
MKKBTUL:UO<[$O/[$J<ZRHZS7[KKSN/F^W=?VM<2QZKS'U=*UO=2MP+2UQ-#0
MLJ*]^-#0S.:[N[+9U_>]J[3ST+37UL2XN,3.JM"AT+37UL2XH:,*"KNYT]#2
MN];6LKO$Q.TUK&]V,'+M;&UJVLT?G3T-"GM<2WO;>HOLW*Q_(O:NAL$-(
M05!415*AL<BKLK_,YKN[SJK0H="THZS(N[KSN+36QM"AT+2AL+#FL;ZAL;7$
MU>+0J=#0M;W.Q+S^Q*G.LJ.LU^ZZ]/#S.:[N/P>Z]J[VKM;''L-#0M<2A
ML$-H87!T97*AL=39M,[,YKN[SJJT]"TM<2AL$-(05!415*AL:&C"@H*"G1R
M;V9FSLK,X@H*P_S![M#0H[H*"C$@+"`Q-B!G;&]B86P@+UXO(#(Q-R!S=6)S
M=&ET=71E("]N*%!$=2]<7&XH4$1U+PH*S:BY_=3+T-`Q-K3.M<3,YKN[P_S!
M[L"TS>JSR;C#R,[.:&CP[_2N[3.S.:[N[:U-JAL&XH4$1UH;''L++ER.O2
MN[CVM[30L;C<H:.CJ,SFN[O*O='YUM#6KLOYTM32JL&]N/:WM-"QN-S*Q]+R
MSJJWM-"QN-RQOLGMU-K,YKN[RKW1^=;0TK+*Q]*[N/;,V,KBU]:W^Z&CHZD*
M"@H*"J&PML["Y+'@NL6AL<[*S.*UQ,SARKX*"L[2M<2P[+>HT.C2JM*[N/;6
MT+SDLKW6Z*&JH:K4VL._N/:ZZK7$NO/#YLSMO-.T]"TU];$N*&P2:&QH:.V
M^-3:P[^X]KKJNO/7UL2XH;!)H;&UQ+CVROV^S<K'Q,>X]K;.PN2UQ+'@NL6A
MH]*ROLW*Q]3:RK7*J<'+U>*X]M;0O.2RO=;HNO.VSL+DO[3)SBEOLW/=7B
MT?FCN@H*+G!P24E)24D*"@H*L>"ZQ<[*S.*UQ++.O[RT+"X"@J_R=+4T/!
MO<SUR*N^UL/P>[`M,WJLG5XM*[LMG7]Z&CM=K2NSUH[H*"F=L;V)A;"`O
M7EPN<'`O("X@+"`D('-U8G-T:71U=&4@+RN<'!)+PH*MM32U+KJH;`N<'"A
ML;^JRKRUQ,._TKO0T*.LU,O0T,SFN[O#_,'NO:NT]"TU];$N*&P2:&QUL/3
MVKKJNO.AHSFN[O#_,'NM-.UVM*[N/:QZLJVT-"_JLJU-K+^=/0M<2ZZKKS
MO-/)SZ&P2:&QH[O4VK7:MOZX]K'JRK;0T-;0MM2S_;7:TKNX]K'JRK;0T,WB
MM<3+^=/0NNJZ[S3R<^AL$FAL:.[R+NZ]3:M=K(_;CVL>K*MM#0HZRVU+/]
MM=K2NZ&BMOZX]K'JRK;0T,WBM<3+^=/0H;`N<'"AL;KJNO.TG/H;!)H;&C
MK-+`M,O`X,W&H:/5XM'YU-K(J[[6P_S![M3+T-#-ZKKSHZS#O[CVNNJZ[:
MT]#7UL2XH;!)H;'7Z;/)M<37UK2NP<NAH]?6M*ZUQ+.DMLC3Z[;.PN2UQ+'@
MNL7*Q]*[T?FUQ*&CTK*^S<K'U-K#_,'NU,O0T,WJNO.CK-3:M=K(_;CVH;`N
M<'"AL;KJNO/3T-?6M*ZAL$E)2:&QH:/4VK7:SN6X]K;.PN33T-?6M*ZAL$E)
M24E)H;&CK+7(M<BAH[3+RK'$X]+1OJW3P+>PNVCJ+ORR[72N];6NMRAL-2M
MRKRAL;7$HZG*_=?6SJJVSL+DL>"ZQ<'+H:,*"K7:MO[,]<BKOM;#_,'NO:O"
MWL+MROW7UM>JN[O.JKCSJJYYK>VM<30SLJ]H[H*"F=L;V)A;"`O7EPN<'`O
M('-U8G-T:71U=&4@+TE)24E)+U8O(&<@7`I('-U8G-T:71U=&4@+U96+U@O
M(&<@?"!S=6)S=&ET=71E("])24E)+TE6+PH*HZC4VL_"TKO5PM;0Q..[X=&G
MM;W4VLSFN[O#_,'NNO.TG/M<30H="TU];$N*&P9Z&QHZS*Q]/#P+36N,J^
ML>"K<;WMM3#O]*[T-"]^-#0OJ&_R<3<MN"TSK7$S.:[NZ&CMOC)S/FP_S!
M[K7$M=K2N[*_M];0T,2IM<30L;C<L>W*OL_"TKO0T+7$P_S![LK'O=/0^-3:
MU>+2N]#0NO.AHZ.I"@K2JM:JM<"UVK;^S/7(J[[6P_S![LK'U/71^;FDU_>U
MQ*.LOF_M-*[S*AL+7:,3FVSJ&QM<3'Z;_VH://PL/FM<3+Q-#0L>W*OK7$
MM]:Q,K'NNK4VLSFN[O#_,'NU,O0T,>PHZRZS;W3S+`M+7$R/VX]LSFN[O#
M_,'NUO"X]M:TT-"Z[7$L>2[K?IO_:CN@H*+G!P24E)24E)2

转自http://blah.blogsome.com/2006/06/18/vi_tut_3/


22 10, 2010
Vi/Ex编辑器教程[2]
作者 helloxchen 12:23 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
Vi/Ex编辑器教程

    作者：Walter Alan Zintz
    译者：hq00e （at） 126.com
    原文：The Vi/Ex Editor 

目录

    * Vi/Ex编辑器教程
    * 第二章：行模式地址
          o 行模式寻址
          o 定位一段文本
          o 亲身实践
          o 下一篇 
    * Appendix A 答案 

第二章：行模式地址

无论何时当你使用编辑器命令对当前文本的文本进行操作如删除一些文本；将小写字母改为大写字母；写入文件（部分保存）等等，的时候你得让编辑器知道你要对哪一部份文本进行操作。少数的命令有内建的地址，大多数的行模式命令在用户未指定地址时会使用默认的地址。但仍有许多情形下你必须知道如何给编辑器地址和给它什么样的地址。

许多行模式命令与可视模式下的相应命令是一样的，它们是完成同样工作的不同方式。重复的命令集的好处源于行模式与可视模式所提供的两种截然不同的寻址风格。截然不同的两种寻址方式意味着对于一种方式难于完成的编辑任务对于另一种方式可能只是小菜一碟。

我这样一直提“行模式”，你可能会好奇是否真有一种单独用于行编辑的模式。答案是：当然有。这种模式下你的屏幕不会为当前编辑文件的文本所占据，这个模式给你一个行模式的命令提示符――半角冒号（:），并只在屏幕上显示文件中的一特定行。这种模式给人的感觉就像是在shell提示符下使用UNIX命令一样。现在已经很少人在行模式下编辑了，主要是因为在可视模式下你还能调用大多数的行模式命令，但在行模式下却没法使用可视模式命令。也可能因为可以在屏幕上看到文件内容，并能即时查看修改的文本的这种WYSIWYG（所见即所得）的感觉，更易于为大众所接受。

但在有些情况下你仍需要暂时地使用行模式。要以行模式运行这个编辑器时可在Shell下输入“ex”而不是“vi”来启动这个编辑器。如果你已经在这个编辑器的可视模式中时可输入“Q”来进入行模式。要回到可视模式，输入“vi”然后按回车。

“vi” 显然是个行模式命令那你知道为什么在输入“vi”回到可视模式时我没有在前面加上半角冒号吗？原因是在行模式下输入命令时并不需要那个冒号。输入冒号甚至有害无益，行模式下如果在命令前输入冒号，那么在冒号和命令（不管是使用完整的命令或使用缩写的命令）之间不能有地址也不能有空格――什么也不能有。

基于以上的原因，在下面的行模式命令中将不带冒号，你知道的――只有在可视模式下使用行模式命令才需要在命令前加上半角冒号。同时每个命令后我不再用 “(ret)”来提醒你该命令要以回车键来结束，因为你应该已经注意到了――不管是行模式还是可视模式下使用行模式命令都要以回车键来结束。

有些人可能会问为什么我要使用完整的命令形式，并使用了许多空格来分隔命令；为什么不使用简略的缩写命令的形式。看看下面的例子，有两行命令：

     global /^/ move 0
     g/^/m0

有一样的作用，但第二个输入起来肯定要快些，那为什么在本教程中使用第一种形式呢？因为更长的版本更容易理解特别是当我在演示一些新概念时，并且这里面的内容至少对某些人来讲是新的。你很快会开始学写编辑器脚本，如果以简洁的风格写就脚本的话，对未来维护脚本的程序员而言这些脚本会跟APL语言一样难懂。所以你最好能了解一下这些命令的完整形式。在我介绍这些个行模式命令时我会告诉你该命令的完整名称和一至二个的缩写名称。



行模式寻址

单个地址。通常一个行模式命令只需要一个地址。一个地址就是指某一特定行，用以指示某些命令如删除命令（delete）或替换命令（substitute）只对指定行进行操作。对于像插入命令（insert）或读入命令（read）这种在当前行前或行后置入文本的命令而言使用多个地址则没什么意义。

搜索式样都是合法的行模式地址（在第一章中我们已经讨论过搜索式样）。地址要放在命令的开头，要置于命令名之前（如果在可视模式下使用行模式命令时地址则要放在开头的半角冒号之后），所以：

     ?the [cC]at? delete

会将上一个包含字串“the cat”或“the Cat”的行删除，而：

     /^GLOSSARY$/ read gloss.book

在当前编辑的文件中从当前行开始往下找一行只包括一个单词“GLOSSARY”的行，并将“gloss.book”文件的内容置该行之后。

要重用与上次同样的搜索式样作为地址有两种简写形式。输入“??”或“//”告诉编辑器使用上一次使用过的搜索式样，而“??”与“//”分别表示不同的搜索方向用以代替上次使用的搜索方向。也即，如果你输入了：

     ?the cat? yank
     // delete
     ?? print

第二条命令会向下搜索包含“the cat”的行并删除，即使你最早使用搜索式样时的搜索方向是向上。第三条命令会向上（往回）搜索找到包含“the cat”的行并打印，这（凑巧）与最初搜索的方向相同。

但这个通过简写形式（??或//）重用的搜索式样也许不是你用过的用来搜索和定位行的式样。如果你在某个式样搜索结束后运行一个替换（substitute）命令，那么此时重用式样使用的是替换命令用来指代替换文本的式样而不是上一个用来定位行的搜索式样。如果你的替换命令用一个搜索式样开始作为进行替换操作的地址，然后在命令中指定要进行替换的式样结果也是一样的重用搜索式样时用的还是后一个式样。因此如果你输入了：

     /the cat/ substitute /in the hat/on the mat
     ?? delete

这时第二个命令会删除上一个包含“in the hat”的行。要确保重用的式样是上一个用来定位行的式样（而不是上一个用来替换的式样）可以使用“?”和“/”这两种简写形式来向上和向下搜索。在其它的情况下这个两种简写形式与输入“??”“//”的用处是一样的。

行号也是有效的行模式地址。编辑器会自动地为文件中的每一行进行连续地编号，这种编号是动态进行的，也就是当你增加或删除行时编辑器会对插入和删除点后的所有行重新编号。所以如果你对第46行的一些文本进行了修改并删除了第11和12行时，你所修改的那一行现在变成了第44行。如果你又在第17行后增加了10行新行后，你修改过文本的那一行现在又自动变成了第54行。

所有的行号都是连续的不会有漏掉的或重复的行号，因此文件中第n行的行号总是“n”，就是第七行的行号总是7，依此类推。（有许多方式可以用来显示行号，这些内容我会在后面的教程中详细的说明。）输入以下命令就能删除文件中的第153行了：

     153 delete

在行号的周围不需要使用任何的分隔符，除了搜索式样外在任何的地址周围都不用使用分隔符。

还有两个用符号表示的行号和一个虚构的行号也可用于行模式中的寻址。只要在“缓冲”（译者：可简单理解为当前编辑文件）中有任何一行文字（也就是你没有编辑一个尚未存在且未输入任何文本的文件时），编辑器就假设你就在这两个符号所表示其中一个地址中，通常最后一行会受最近一个命令所影响。一个半角句号或说是一点（.）是代表当前行的地址符号。而文件中最后一行的地址符号是美元符号（$）。因此如果你输入了：

     . write >> goodlines
     $ delete

第一个命令会将当前行导出并添加到名为“goodlines”的文件末尾，而第二个命令会将编辑中文件的最后一行删除。

有几个命令会在你给的行地址后置入文本：append （附加命令）命令就是其一。为了将文本置于文件的开头（如果你想把文本置于文件的开头的话），这几个命令还能接受一个虚构的行号零（0）作为它们的地址。如果你想在文件中所有文本之前输入一些文本的话，以下的任一命令都可以做到：

     1 insert
     0 append

（注意：insert和append命令是不能在可视模式下通过前置一个冒号运行的少数行模式命令之一，因为加上要插入或附加的文本这两个命令要占用不止一行的空间。）

自己设定的行址。你可以为行分配小写字母来作为行址，并且可以随时改变这种分配。你甚至可以通过一个特殊的地址来返回上一次跳转的行――这个地址是自动分配的。

用小写字母标识特定行有许多方法，这些方法依行模式和可视模式的不同而有所区别。在后面的教程中我会逐一说明这些方法。一行一旦被做了标识则指代该行的行模式地址为半角单引号紧跟着用于标识行的小写字母。输入：

     'b print

会在屏幕上显示你先前用字母“b”标识的行，不管该行与当前行的相对位置为何都能显示该行。一个字母只能用来标识一行，所以不用告诉编辑器向上或向下搜索编辑器总能找到那行。

编辑器自己也会做一些行标识。任何时候当你使用非相对地址从一行跳到另一行时，编辑器会将你原先的行址标识起来。（“非相对地址”指不是用当前行与原来行之间的间隔行数来表示的地址）

     $
     /the cat/
     358
     ?glossary? +7
     'b

都是非相对行址，如果你使用这些地址在行之间移动，编辑器会标识你在移动之前的所在行以便将来使用。如果你要回到那一行只需输入两个连续的半角单引号：

     ''

理论上，这个地址可以做为一个行模式地址与行模式命令一起使用。但当你由于误操作而移动到文件中的其他位置时，很难肯定你上一次使用非相对地址移动后保留的行标识是否未受影响――除非你对这个编辑器很熟悉。

对上面的各种方式表示的地址进行修改有两种方法。简单一点的方法是为地址加上偏移量，用加号（+）或减号（-）来为地址增加或减少一定数目的行数。规则是地址后的每个加号都指示编辑器在当前文件的指定地址处下移一行，而减号则相反。依这一规则下面的三个地地址表示的是同一行。

     35
     37 --
     30 +++++

你可能不想用数数的方式来修改行号表示的地址，除非你的数学确实很糟希望编辑器能代你来进行加减运算。但这种数数方式表示的偏移量能与所有的行模式地址一起使用，但最经常的是在搜索式样中使用。幸好，这些加号和减号也有简写形式。一个加号或减号紧跟着一个数“n”（一位数或多位数）与“n”个加号或减号表示的是一样的偏移，因此以下的两个地址是一样的：

     /^register long/ ++++
     /^register long/ +4

注意第二个例子中的“4”表示的并不是“行号4”，它只有单独出现时才作为一个地址。在加减号后的数表示的是从前面指定的地址处（上面的例子中这个地址是“/^register long/”）向下或向上移动的数目（如果前面没有指定的地址则从当前行开始算）。

还要注意这是行模式命令中少数不能插入空格的情况之一。加减号与数字间不能有空格，不然编辑器会在无提示的情况下对行――肯定不是你要的那几行，进行操作。

第二种风格的地址修改方法可在进行一些复杂的搜索时使用。假设你想向下定位某以“WARNING!”开头的行并删除该行，但有从当前行以下有多行是以“WARNING!”开头，你要找的第二个符合条件的行。可以使用下面的任一命令：

     /^WARNING!/ ; /^WARNING!/ delete
     /^WARNING!/ ; // delete

两个搜索式样中的分号（;）告诉编辑器先用一般的方式找到第一个搜索式样的位置，然后从那个位置开始搜索第二个式样。在上面的情况中，第一个搜索式样先找到当前行以下以“WARNING!”开头的第一行，然后第二个搜索式样指示编辑器继续找下一个（也就是第二个）符合条件的行。

分号两边的式样都可以独立作为一个有效的地址。很重要的一点是上面的命令虽然将两个搜索式样结合使用，却并不是让编辑器删除两行。分号在这里的作用是让第一个式样成为一个停靠站，编辑器从匹配第一个式样的行开始搜索匹配第二个式样的行，并只删除第二个式样所匹配的行。简言之，这个看上去像表示两个行的两个地址实际上是一个地址用以指代某一行。（这并不是这个编辑器的官方文档的说法，但在这一点上官方文档显然是错的。）

但好戏才刚要上场呢。没有人限制说你只能使用两个地址。我曾经一次用完十个地址来定位某一行，当然这些地址都要用分号隔开。看这个例子：

     ?^Chapter 3$? ; /^Bibliography$/ ; /^Spinoza/ ; /Monads/

将会找到“Spinoza”（斯宾诺莎）的作品中第一部标题中包含“Monads”的著作。编辑器先找到“Chapter 3”（第三章）的“Bibliography”（参考书目）然后找“Spinoza”所在行，并从该行开始向下找包含“Monads”的行。

同样在分号分隔的地址串中也没人限制说只能使用搜索式样形式的地址。如果你想找到第462行后的第一个包含词“union”的行，输入：

     462 ; /<union>/

就能把你带到那行了。并且其中的任何地址都能使用数字偏移，所以：

     462 +137 ; /register int/ ---

也是有效的地址串。

但是不幸的是使用分号分隔的地址串仍有两个限制。较次要的一个问题是只有地址串后面的命令能接受第0行作为其地址时，才能在地址串中使用“行号零”。即，除非命令能在第0行使用，不然就算你的地址串由0行开始后又通过附加的地址指示对其他的行进行操作也不行。

     0 ; /Spinoza/ +++ ; /Kant/ delete

这个用以确保搜索能找到文件中的第一个“Spinoza”的地址串看上去挺好，但实际运行下去会出现非法地址的“错误信息”。

较主要的问题是：在地址串中用分号隔开的每个地址所表示的在文件中的位置都必须比前一个地址更靠后。（“地址表示的在文件中的位置”指在加上偏移量后地址所指代的行的位置。）地址表示的文件中的位置不能相对分号分隔的上个地址更靠前（即更接近文件顶部）。

但这不意味着你不能在地址串中使用往回的搜索式样（即使用“?”做为式样的分隔符）。地址串中的第一个地址使用往回搜索当然是没问题的。而接下来的地址，只有当你确定使用回搜式样后实际找到的行要比前一地址更靠后时才能使用回搜的式样（做为地址）。比如在你知道某个特定的回搜必须在绕回到文件底部继续搜索才能找到匹配的行时就可以使用回搜式样。一般是这种情形：

     1 ; ?Spinoza? ; /Hegel/ yank

在第1行回搜意味着搜索将绕回到文件底部继续，这就保证了所复制（译者：“yank”命令的作用就是复制行）的包含“Hegel”的行必定是在文件中的最后一个包含“Spinoza”的行之后。

还有一种可在地址串中使用回搜的情况就是在回搜式样后加上偏移量。不过只有在你确定加上偏移量后指代的行在文件中的位置要比上一个地址表示的行更靠后时才能使用回搜。因此如果我想要确定第八章（“Chapter 8”）中第一次出现“Hegel”的位置距第七章（“Chapter 7”）中最后一次提到“Hegel”的行至少有120行的距离时，我可以输入：

     /^Chapter 8$/ ; ?Hegel? +119 ; //

如果一个使用上面这个地址的命令出现了非法地址的“错误信息”时，我就可以确定第七章最后一次提到Hegel的行距该章结尾还有120行以上的距离，这样我就可以知道第八章第一次出现他名字的位置正是我要找的。在这个例子中：

     /^Chapter 8$/ ; /Hegel/

就是我的命令所需要的地址。

使用往前搜索或者说向下搜索的情形与上面说的那些内容都差不多。向下搜索时可以使用负偏移只要使用负偏移后位置不会移到前一个地址表示的位置之上就行。但即使没有使用偏移或使用正偏移，回绕搜索也可能找到一比前面的地址更靠前的位置从而使向下搜索失败。



定位一段文本

两个地址也能用来表示一段文本。当两个地址用逗号隔开时与分号分隔的地址有着完全不同的意义。

人们经常需要对一些连续的行使用行模式命令。比如你可能需要将一段文字从一个地方移到另一个地方。这时你可以给出该段文本第一行的地址，接着给出该段文本最后一行的地址，两个地址用逗号隔开。以下命令：

14 , 17 delete

会将第14、15、16、17行删除。使用多于两个的用逗号分隔的地址是无意义的。如果你忽略了这点并使用了三个或三个以上的逗号分隔的地址则：编辑器使用前两个地址并忽略其余的。

任何行模式地址都能与逗号一起使用。下面例子中的地址用法都是正确的：

     'd , /^struct/
     257 , .
     ?^Chapter 9$? , $

当命令与第一个例子中的地址段一起使用时，编辑器会找到你已用字母“d”标识过的行做为地址段中的第一行，并从该行开始逐行向下施加命令直到找到第一个以“struct”开头的行（包括这行）为止。第二个地址段的范围是从257行到当前行。第三个地址段先回搜到上一个只包含“Chapter 9”的行，从该行到文件中的最后一行就是这个地址段表示的范围。

这个技巧同样有限制。主要的限制是逗号后的（加上偏移量后的）地址必须比前一个地址的位置更靠文件末尾。有效的行范围中第二个地址必须是在第一个地址表示的行之后。

     57 , 188 delete

是有效的命令，而类似的命令：

     188 , 57 delete

只会制造出错信息。（如果两个地址正好指代的是同一行时命令也能正常执行。命令“默默地”对指定的那行进行操作。）

当使用的行模式地址越来越复杂时，你可能会碰到第二个地址先于第一个地址的出错信息――而你事先没料想到地址可能会有任何问题。这不是什么丢脸的事，解决的办法也很简单。在你仔细检查过地址并确定那些地址就是你要的地址时，只要交换一下两个地址的次序就行了。即，如果：

     642 , /in Table 23/ delete

出错了，错误信息提示行的次序错误时：

     /in Table 23/ , 642 delete

就能解决那个问题了。

最后一个限制是当你在逗号两边使用搜索式样时，第二个搜索与第一个搜索一样是从当前行开始而不是从第一个搜索找到的行开始搜索。这个限制有个迂回的解决办法，这个办法需要将一个或多个分号与逗号结合使用。

行模式下分号分隔的地址串的用法与单个地址一样，任何的单个地址都可以用地址串来代替。一个非常实用的技巧是在逗号的两边使用地址串，用以精确的定位行范围。我们说过分号分隔的地址串实际上表示的只是一行的地址，因此地址串也可以用作文本段的开始行或结束行。比如，在下面的命令中：

     /^INDEX$/ ; /^Xerxes/ , $ write tailfile
     ?^PREFACE$? ; /^My 7th point/ , ?^PREFACE$? ; /^In summary/ -- delete

第一条命令将索引（index）的后半部分写入到一个新的文件中。第二条命令用来将绪论（PREFACE)中的某一节删除。

这个技巧为上面说的限制――即第二个搜索的起点问题，提供了解决方案。如果你想要逗号右边的搜索从前面搜索到的行开始，那就在你原来的第二个搜索式样（即逗号右边的搜索式样）前面加上第一个搜索式样并用分号分隔，例如：

     ?Stradivarius? , ?Stradivarius? ; /Guarnerius/
     ?Stradivarius? , ?? ; /Guarnerius/

考虑到行模式下的地址串不能向上移动，我最好解释一下当分号与逗号一起使用（就像上面的例子）这些限制的工作机制。除了第一个地址外分号隔开的一系列的地址相对前一个地址都必须更靠近文件底部（不能向上移动或回搜）。但第二个分号分隔的地址串的开始地址在文件中的位置却可以先于第一个地址串（逗号前的地址串）中的任一地址。也就是这个“单向计数器”在遇到逗号后就重置了。在逗号两边使用分号分隔的地址串只要求第二个地址串的最终“着陆点”（即地址串最后确定的行，我们说过地址串中虽有多个地址但实际上表示的只是一行的地址）比第一个地址串的“着陆点”更靠近文件底部就行了，中间的各个地址的相对位置并不影响逗号的使用。为了讲清楚点，我们看两个奇怪的例子，这两个例子没什么实用价值但很能说明问题。

     125 ; 176 ; 221 , 32 ; 67 ; 240

上面的地址似乎是无效的因为出现了地址回移（向上移动）的情况――从行221到行32，事实上这却是个完全合法的地址。因为回移是出现在逗号后，这是规则允许的。但：

     125 ; 176 ; 221 , 32 ; 67 ; 218

却会出现“错误信息”，因为第一个地址串的“着陆点”（行221），在第二个地址串的“着陆点”（行218），之后。

关于默认地址。我已经说过大多数能使用单个地址的行模式命令有一个“默认”的内建地址，当你没为命令提供地址时编辑器就使用默认的地址。不同的命令有不同的默认地址，可能是当前行，可能是当前行和下一行，可能是最后一行或者是整个文件。

逗号分隔符也有自己的默认地址。无论逗号与什么命令一起使用，这个默认地址都是一样的，并且这个默认地址会覆盖命令自身的默认地址。如果你在命令前使用了逗号但没提供逗号左边的地址，默认的左边地址是当前行。同样的如果你没提供逗号右边的地址，默认的右边的地址也是当前行。你还可以将逗号两边的地址都留空，这时两边的默认地址都是当前行：表示默认行范围是“从当前行到当前行”，其实也就是让命令对当前行进行操作。因此下面的每条命令：

     .     write >> goodlines
     . , . write >> goodlines
       , . write >> goodlines
     . ,   write >> goodlines
       ,   write >> goodlines

做的事儿都是一样的：在当前编辑文件中导出当前行并添加到名为“goodlines”的文件末尾。

最后，还有一个用来表示某个逗号分隔地址段的特殊符号――百分号（%）。这个符号与“1,$”的表示的范围是一样的，都用来指代整个文件。




下一个： next-installment,
上一个： text-section,
上层： line-mode-addresses

亲身实践

在你遇到需要复杂的行模式地址的编辑情况之前，这儿有些问题可让你先锻炼一下自己。这里的每个问题都提供了一个相应的“参考答案”。
怎样让编辑器找到文件中最后一次出现单词“EXPORT”的行，并删除该行？如果你知道从哪开始搜索的话，答案就相当明了了。

假设你想要找到并删除文件中“EXPORT”第一次出现时所在的行，这行有可能正好是第一行。你不能从第0行开始搜索因为删除命令不接受虚构的地址――第零行。当你使用地址串“$ ; /EXPORT/”来进行绕回的向下搜索时，出现了错误信息：搜索式样找到的行要先于做为第一个地址的“$”找到的行――就跟你设想的一样。怎样才能让编辑器找到并删掉这行呢？解决这个问题需要一点创造性。

在你使用地址“?abc? , /xyz/”时，它包括了匹配式样的两行（分别是匹配“abc”和“xyz”的行），及两行之间的所有行。怎样才能指定范围为两行之间的所有行，但不包括那两行自身（在这个例子中就是匹配“abc”和“xyz”的两行）呢？答案可能会比你想像的要来得简单。




下一篇

在下一篇我们会讲解“Global”命令，相对这一章讲的让人发困的各种地址类型而言下一篇的内容会精彩得多。并且让你有机会能使用刚讲过的这些不同的地址类型，我也会涉及到一些行模式命令尤其是那些有着你所未料想到的用法的命令。
Appendix A 答案

这里是上面习题的答案。用uudecode打开看答案是什么。

begin 644 viex2_ans
M5FDO17BQX+RMQO>CK+7:MO[5PJ.ZLLZ_O+3PL+@-"@T*#0JAL$584$]25*&Q
MSLK,XK+.O[RT+"X#0H-"LKDR.NCN@T*#0HQ(#L@/T584$]25#@9&5L971E
M#0H-"K[-T-#!RZ&CU-K.Q+S^UM"UQ+7:TKO0T,JYT.[V,O1HZS$W,BWL:/5
MTK6]M<2UVM*[N/:P_+JLH;!%6%!/4E2AL;7$T-"^S<K'SL2_M;0H;!%6%!/
M4E2AL=?NNO/2N[3.L_;/ULJQR_G4VK7$T-"CJ-+RSJK(QKO8R]'+]Z.IHZS(
MN[KSLL7*Q[6YROVUVK;^T-"CK+7:R/W0T-+`M,O`X,W&H:.UJK'L>"K<;W
MU-K5TK6]M=K2N[CVQJ7%Y,_NRK&^S<VCUKG+T<OWP<NCK,OYTM2RN[_)Q-S3
MT,'MTKNX]J&P15A03U)4H;&X_+^_O?S.Q+S^Q*G.LJ&C#0H-"@T*#0JAL+7:
MTKO0T,[*S.*AL;7$LLZ_O+3PL+@-"@T*T.C2JL&]S/7#_,'NH[H-"@T*)"!P
M<FEN=`T*+T584$]25"@9&5L971E#0H-"K7:TKO,]</P>[/U,J^U^ZZ]*[
MT-"CK-7BN/;#_,'NL;[)[=/KSM+#Q[7$SLK,XL[>N=BCK+6KRL?4VLOUK30
MT+KSU^ZZ]*[T-"SR<'+M;''L-#0H:/(N[KSHZS.TL/'U-G/L_"R]'+]Z.L
MTG3VKO8R,:CK,O1R_>^S=/)SL2_K7$M=K2N]#0OZK*O,'+H:,-"@T*#0JA
ML+*[L/S`J,J]T?G0T*&QSLK,XK+.O[RT+"X#0H-"M:[TJK4VK:ZNL7'L+7$
MM=C6M[KSS.W2N[CVH;"T[K%H;&CK-3:MKJZQ;KSM<2UV-:WNO/,[=*[N/:A
ML+SUNL6AL:.LOLW/=7BT?FCN@T*#0H_86)C/R`K("P@+WAY>B@+0T*#0K5
MXL&]N/;&J]+&P;_(P[$L;ZWMLZGS_+.Q+&^MLZUQ-;0O.2^V*CHZS(P[$
ML;ZVSK7$P;VVR[CWU]3/M;0O.32QK:OP<O2N]#0H:.RHL?2RKFUP:EQ>3*
MO='YM<30T,W1P.O#_,'NU_?3P[7$SL2QOK>VSJ>AHZ.HU-JQOL#]UM#!O;CV
MM=C6M[7$R]'+][>]S_*RNK'UMBUXZ.LUMC2JK7$RL?'L-*[N/:UV-:WNO/#
MYK'8T.O*Q]7]QJO2QJ.LMOBVNKK%NO.QV-#KRL>XNL:KTL:RQ<3<RKG#_,'N
DM[;.I[*[L/S`J+*[N/;+T<OWRKW1^;7$M=C6MZ.I#0H-"@T*
`
end


22 10, 2010
Vi/Ex编辑器教程[1]
作者 helloxchen 12:18 | Permalink 静态链接网址 | Comments 最新回复 (0) | Trackback 引用 (0) | VI/VIM
Vi/Ex编辑器教程

    作者：Walter Alan Zintz
    译者：hq00e （at） 126.com
    原文：The Vi/Ex Editor 

目录

    * Vi/Ex编辑器教程
    * 第一章 Vi基础
          o 为什么选择Vi
          o 关于这个编辑器的几个基本概念
          o 搜索式样
          o 下一篇 

第一章 Vi基础
为什么选择Vi

一个贴心的编辑器。小何是个程序员，在一公司里与他人做共同维护的工作。刚从别人那里接手了一个大的模块。这个模块的代码真是满目疮痍啊，到处是修补的痕迹。而且看上去这些 “意大利面条”式的代码补得不怎么牢靠；就在昨天这个模块彻底地崩溃了，使得这个部门几乎瘫痪。在一夜地奋战过后，小何终于在今早使这个模块又能运转了……在他打算出去买早餐时，该公司信息部门的副主管走过来了……
“小何，这次的修复干得很好，辛苦你了。不过现在我需要这次崩溃的技术数据，要整理过的，马上。信息委员会的董事会早上召开了一个紧急会议，目的是评估问题是否在可控制的范围。如他们把矛头指向我，那我就倒大霉了。我需要有一些可以在投影机上播放的技术资料，以便转移他们的注意力。

“他们很可能会让我讲一讲日志中导致这次崩溃的错误代码的相关记录……对了，这部分内容是记录在 /oltp/err/m7 中，日志是使用追加的方式因此最新的报告会记录在文件的底部。那些人对日志中旧的部分不感兴趣，他们认为那是历史了。另外除了市郊的火车时刻表外，他们不习惯看东西是从下往上的。所以你得重新整理一下顺序。

“看一下，这是日志文件：

     374a12  44872  130295/074457  nonabort
     5982d34  971  130295/221938  nonabort
     853f7  2184  140295/102309  abort
     ……

“恩……向他们解释第二栏的数据等于跟他们说我们早知道这些缺陷的存在，只等着模块崩溃了──那是找死。你在编辑时记得，记得将第二栏中除首尾的两个数字外的其他数字删除。

“对了，他们看那些看腻了后会想仔细地看一下Lint报告的。上个月我才跟他们说我们的代码无懈可击，现在我得说服他们相信这个模块现在还在不断输出的错误消息都是些无关紧要的小毛病引起的。你得对修补后的代码进行Lint检测然后把输出结果与源文件合并。方法是先在输出的结果中找这种的信息：

     Line 257: obsolete operator +=

然后把重要的部分放在源文件中相应行的末尾。中间用分隔符――如XXX分开，方便查找。没什么能比足量的源代码更能让会议提早结束了因为他们根本不知从何看起。

“快去做吧。会议在35分钟后就开始了。”

然后我们的副主管就走了。他是暗笑着走开的，因为他已经打好算盘了――他知道在这么短的时间里没人能做好他要求的那么多的编辑任务。这样等会他就不用费力的解释这次的崩溃了，他只需把责任推给他的下属。我就跟信息委员会的人说：“我已经跟程序员说过要在9:30之前做好报告了，而且讲很清楚了。但我刚问他时他说还没弄好而且不知何时会弄好。”然后：“这些程序员就是不能意识到时刻向管理层报告进度就跟程序中的每一个字节一样重要！”

不过小何在与上级的角力中并非完全落于下风，他还有秘密武器：vi

将文件中的行倒置对这个编辑器而言只是小菜一碟。以下的八个按键（在以下的文章中用(ret)表示按回车键）：

     :g/^/m0
     (ret)

就能完成这个工作了。将文件中所有行的第二栏首、尾以外的其他数字删除也只要一行命令：

     :%s/^([^ ]*  [0-9])[0-9]*([0-9]  )/12
     (ret)

那结合Lint报告与源代码呢？就算这种工作Vi也能自动做到自动化。这条命令：

     :%s/Line ([0-9][0-9]*): (.*)/1s;$; XXX 2
     (ret)

会把Lint的报告文件改为编辑器的脚本，只要在源文件中运行此编辑器脚本就能达到我们要的编辑目的了。

小何只用了几分钟，输入了几行就避免了当冤大头。他现在还剩一些时间可以考虑怎样才能防止副主管推诿责任――他可以先到街对面的咖啡厅，等在会议开始的那时再再出现在会议厅中，并用在场每个人都听得到的方式告诉副主管：“你要的那些文件就在‘斜杠 temp 斜杠 hal’文件夹中”。

这篇教程的写作计划。我想写给那些对 vi/ex 有初步认识的编辑器用户。即你已经对一些类似“Vi 入门”之类的书里教的那些普通的内容已经熟悉了。这种Vi的书籍在市场上泛滥却很少触及更深层次的东西。

在这系列的教程中我们会深入的探索一些较不为人知的 vi/ex 的用途。其中有不多的技巧是通过一些我们经常使用的编辑功能来实现的，但我们确很少注意到这些技巧――举例来说，用 global 命令来对处理的每一行做记号。同时我还会对关于Vi的许多常见的误区进行阐述。

要做到这些，我会很详细的解释里面的每个部分。我会在有必要的地方出些习题帮助理解。同时为了让你不至于被过多的模糊的信息所淹没，我会将这篇教程分成很多小块。然后用平稳合理的节奏将教程一篇篇地放到我们的网站上。
关于这个编辑器的几个基本概念

要真正理解这个编辑器的威力，你得对编辑器有一个基本的认识。它的许多功能便是筑在这些基础的概念上面。

这个编辑器被误用的一个原因是许多用户包括有经验的用户，没有分清什么是它的本职而哪些工作不适宜用它来完成。这里有一个这个编辑器本职功能的参考列表：

第一，编辑器严格地用来表示通用目的的编辑器。它不对文本进行格式处理；它不需要一个字处理器的支持；它不需要内建特殊的功能用来编辑十六进制、图形、表格、大纲或是支持任意一种编程语言──Lisp除外。

它是二合一的编辑器。在可视模式（Visual Mode）1下，它是个比大多数的编辑器好的全屏编辑器，并且比那些同样支持一堆屏幕编辑命令的对手要运行得更快。它的行模式2（Line Mode）使字处理器和简单的交互式编辑器的“全部查找和替换”功能相形见绌。它的仅有的对手是非交互式的编辑器，如Sed ，使用这种编辑器你得事先准确的知道自己要做哪些编辑。但在 vi/ex 中，这两种工作方式被很发好地结合起来了。我用过的编辑器还没有哪一个会比 vi/ex 好――当把它的两方面的优势结合起来时。

最后，这个编辑器只有抱着不怕苦不怕难的精神完整地学习过才能够用得得心应手。它的功能太多了，你根本没法在一或两个钟头里掌握。它又很特殊，用一个礼拜的时间都没法精通这个编辑器。但它的威力就在那儿，只有深入钻研的人才能掌握。这种威力很大一部分要靠对编辑器的个性化编程来实现：这不太容易，对熟练的用户而言它通过编程来扩展功能的能力要比任何的其他编辑器来得强或许（可能）只有 Emacs例外。
搜索式样

在这个编辑器有有许多的功能，能通过使用字串式样的搜索来指定功能在哪里执行，范围有多大。这些搜索式样很能说明这个编辑器带有明显的Unix风格，但在搜索式样的细节上仍与其他的Unix工具有所区别。

搜索式样功能在行模式下与可视编辑模式下大多数情况下有一样的使用方式，只有少数例外。但在输入搜索式样时怎样让编辑器根据不同的需要进行搜索呢？

从当前位置开始搜索。通常我们用搜索式样是为了移动到文件中的另一个地方，或者把编辑命令的范围从当前位置扩展到式样所指明的位置。（在编辑模式下你还可以用一个式样的位置到另一个匹配式样位置作为执行动作的范围，但两个式样都是从当前位置开始搜索。）

如果你想要从当前位置往下搜索（一直到文件尾），在搜索式样前面和后面加上一个斜杠（/）。因此如果你想要从当前位置开始查找文件中出现下一个字串“j++”的位置，输入：

     /j++/
     (ret)

就行了。也可以这样：

     /j++
     (ret)

注意，在式样与回车键（ret）之间没间隔，回车本身表示搜索式样的结束，所以第二个斜杠可省略。如果当前模式是可视模式，使用 ESC 键与回车键一样可以用来表示搜索式样输入完毕，所以在可视模式里如下命令

     /j++
     (esc)

与之前的命令的作用是一样的。

要向上搜索（回搜），在式样前后加上问号而不是斜杠。回搜与向下搜索使用同样的规则，因此

     ?j++?
     (ret)
	
     ?j++
     (ret)
	
     ?j++
     (esc)
	

都可用于回搜一样的字串。

无论哪种方式你都只用了一个键来提交并确认搜索的式样和搜索的方向。可别以为回搜时在文件中找到的匹配项都是在当前位置以上，当前位置以下的匹配项也会被搜索到，反之亦然。编辑器在往回搜索时先在当前位置逐渐向上搜索，但当它到达文件的顶部（第一行）或底部（最后一行）时如果还没发现匹配项，它就会从文件的另一端开始往同一方向继续搜索。也就是当你用问号进行回搜时，编辑器会从当前行不断地往上找。如果到第一行还没找到匹配项，那它就会从最行一行开始继续搜，然后是倒数第二行，倒数第三行……依此类推，一直搜到最初开始搜索的位置（如果一直没找到匹配项的话）并停止搜索。或者当你往下搜索时一直到最后一行也没找到匹配项，编辑器就会从第一行开始继续搜索，然后第二行，第三行……

如果你不想在搜索从文件的一端绕到另一端去继续，你需要一条行模式的命令：

     :set nowrapscan
     (ret)

这可以禁止当前会话3中的绕回搜索。要在编辑时恢复绕回搜索功能，输入

     :set wrapscan
     (ret)

就可以了，看你想开开关关几次都可以。

“查找全部”搜索。目前为止，我只讨论了查找搜索式样的一个匹配项的方法――往指定的搜索方向查找在文件中距当前位置最近的一个匹配项。但搜索还有一种其他形式。这种形式的搜索主要用于行模式命令，如 global 和 substitute 。这种搜索方式找到文件中（或在文件中的指定部分）包含式样的所有行并对它们进行操作。

在使用 global 和 substitute 时不要被它们搞晕了。在命令行中两种形式的搜索方式经常混合使用。但“查找一个匹配项”的式样一般置于命令名或命令缩写前而“查找全部”的式样则放在命令后。比如，在以下命令中：

     :?Chapter 10?,/The End/substitute/cat/dog/g
     (ret)

前两个式样分别用来匹配在当前行之前且距当前行最近的包含“Chapter 10”字串的行和在当前行之后的第一个包含“The End”字串的行。请注意每个地址（即包含式样的行的地址）只对应一行。以半角逗号隔开表示 substitute 命令作用于这两行和这两行之间的所有行。但紧跟着 substitute 命令的式样指示命令对命令作用范围内的所有字串“cat”替换成“dog”。

除了字面上意义的不同外，两种形式的搜索也使用不同的分隔符用以标识式样的开始和（有些时候需要）结束。对“查找全部”式样而言不需要指示往前或往后搜索。因此式样的分隔符不仅限于问号和斜杠，还可以用半角的标点符号――几乎所有的标点都可以，因为编辑器自动识别命令名后的第一个标点符号为该命令中的分隔符。因此这几个替换命令

     :?Chapter 10?,/The End/substitute;cat;dog;g
     (ret)
	
     :?Chapter 10?,/The End/substitute+cat+dog+g
     (ret)
	
     :?Chapter 10?,/The End/substitute{cat{dog{g
     (ret)
	

都是一样的。（最好不要使用在命令中有特殊意义的标点，如感叹号经常用作一个开关选项出现在命令名的后面。）

使用其他标点作分隔符在搜索式样本身包含“斜杠”时就显示出了其优点。例如，当我们要将文本中所有的连续的两个“斜杠”用“-”隔开，即将“//”替换为“/-/”。很明显这样做：

     :?Chapter 10?,/The End/substitute/////-//g
     (ret)

是不行的。这个命令会将前三个斜杠视为分隔符，而对后面的所有字符视而不见。这个问题可以用“反斜杠”来解决：

     :?Chapter 10?,/The End/substitute/////-//g
     (ret)

但这个比上一个错误的命令还难正确地输入。当用其他的标点作为分隔符时

     :?Chapter 10?,/The End/substitute;//;/-/;g
     (ret)

容易输入也更容易理解该命令的作用。

简单搜索式样。最简单的搜索式样是直接输入要编辑器查找的字符。就如：“the cat”。但这里有几条注意项：

   1. 这样方式搜索字符时并不只有以这些字符组成的单词会匹配式样。它会匹配“we fed the cat boiled chicken”也会匹配“we sailed a lithe catamaran down the coast”，就看它先碰到哪个。
   2. 至于会否匹配“The Cat”则要看你是否设置了一个叫 ignorecase 的编辑器变量。如果你未改变默认设置，带有大写字符的这个版本将不会被匹配。如果你希望在式样中不区分大小写，在行模式中输入以下命令

                :set ignorecase
                (ret)
           

      要区分大小写，输入

                :set noignorecase
                (ret)
           

   3. 上面的搜索式样肯定没法匹配“the”在一行行末而“cat”在下一行的开头的这种情况：

                and with Michael's careful help, we prodded the
                cat back into its cage.  Next afternoon several
           

      至于字与断行之间是否有空格并不重要。对于一个“面向行”的编辑器而言要用找出一个式样来匹配跨行的字串是不大可能的。
   4. 搜索由哪个位置开始取决于你使用的编辑模式。在“可视”模式的搜索由光标位置的下一个字符开始搜索。“命令行”模式下搜索由当前行的邻近行开始搜索。 

字元。Vi/Ex有所谓的“字元”或叫做“通配符（wild cards）”：在搜索中有特殊含义而不表示其字符本身。如字元“.”“*”，在

     /Then .ed paid me $50*!/
     (ret)

可用来匹配以下的任意一项：

     Then Ted paid me $5!
     Then Red paid me $5000!
     Then Ned paid me $50!

或无数的其他字串。正是字元赋予了搜索式样威力，但前提是必须对字元有所了解。

要了解这些，你得知道如何使用反斜杠（）字元来控制字元“通配”功能的开与关。

许多情况下，一个搜索式样中的字元如果没有前置一个反斜杠时使用的都是它的字元值――都是作为通配符出现的字元，而前置一个反斜杠则用来表示用作字元的字符本身。反斜杠字元本身就是一个例子，当它单独使用时它使用的是它的字元值（即作为有“通配”功能的字元），就算在紧帖它前面的是一个普通的字符也是一样。如果要在搜索式样中搜索反斜杠这个字符则要在它之前添加一个（使用字元值的）反斜杠用来使之表示反斜杠自身。就是说要搜索“ab”，输入

     /ab/
     (ret)

作为搜索式样。如果你输入

     /ab/
     (ret)

反斜杠会被当做一个字元也不会有什么做用（因为 b 不是一个字元）因而这个搜索式样找的字串实际上是“ab”

不经常使用的字元则与此相反。这些字元如未前置反斜杠则用做一般的字符。前置反斜杠方可使用这些字元的元值。如，在

     /<cat/

中左尖括号（<）是一个字元。在

     /<cat/

中它就表示一个尖括号字符。这些特殊的字元会在下面列出。

最后还有第三种类型的字元――最难搞掂的一种。一般情况下，在搜索式样中这些字元的元值是默认启用的，前置一个反斜杠可让它们做为一个普通的字符：就如同我们的第一个例子，反斜杠自身的例子。但如果你将一个名为 magic 的编辑器变量的默认值更改了，它们的工作方式恰恰相反――前置一个反斜杠来启用字元的元值：就像我们的第二个例子，左尖括号的例子。（没理由要将 magic 关掉。）这些最奇怪的字元也会在下面列出来。

还有不要忘了那些用来标识搜索式样开始或结束的标点符号，不管是斜杠问号还是其它的标点如果它也出现在搜索的式样中作为一个被搜索的字符之一，那你需要前置一个反斜杠来防止编辑器将之解读为式样的结束符号。

字元表

.
    在搜索式样中一个半角句号可匹配一个单一的字符，不管是字母还是数字或标点符号。事实上除了换行符（newline）外，“.”可用来匹配任意的ASCII 字符。因此要查找“default value”时考虑到它也可能被拼写为“defaultvalue”或“default/value”又或者是“default_value”等等，搜索式样可以用“/default.value/”。当编辑器变量“magic”关闭时，你必须加上反斜杠让句号使用它的元值。

*
    星号，结合星号之前的一个字符，可以用来匹配由星号前的那个字符组成的任意长度的字串（包括长度为0的字串）。因此搜索字串“/ab*c/”可以匹配 “ac”、“abc”、“abbc”或者“abbbc”，依次类推。（要查找至少包含一个b的字串，可以使用这个搜索字串“/abb*c/”。）如果星号字元紧跟在另一字元之后，则匹配任意长度的前一字元所匹配的字符。这意味着“/a.*b/”将会找到一个在“a”与“b”之间有任意长度（包括长度为0）的任意字符的字串。当编辑器变量“magic”关闭时，你必须加上反斜杠让星号使用它的元值。

^
    当脱字符作为搜索式样的第一个字符时表示匹配式样的字串必须是在一行的开头处。它不代表在一行开头处的任何字符（或者说它匹配一行开头空字符）。当它不是一行开头的第一个字符时，它表示的是一个普通的字符（未使用元值）。所以“/^cat/”会找到以“cat”开头的行而“/cat^/”找到包含 “cat^”字串的行。

$
    当美元符作为搜索式样中的最后一个字符时表示匹配的字串必须在一行的末尾。其余同上。

<
    当一个搜索式样以一个反斜杠接左尖括号开始时，表示从一个“简单”词的开始部分开始匹配。当在式样的其他位置出现时它并不是做为一个字元。（这个编辑器中，一个“简单”词可表示一个或多个数字、字母组成的字串，也可表示一个非数字或字母与任何的非空白字符组成的字串（译者：空白字符表示空格、制表符、换页符等等，所以“shouldn't”包括了三个“简单”词。）“/<cat/”匹配字串“the cat”或“tom-cat”中的后三个字符，但不会匹配“tomcat”。要移除左尖括号的元值让它成为一个普通的字符，只要去掉前面的反斜杠：“/<cat/”会匹配字串“<cat”，而不管字串前面有什么。

>
    在一个搜索式样的末尾一个反斜杠接右尖括号表示匹配只发生在一个“简单”词的末尾。其余同上。

~
    波浪线用来表示substitute命令中的后一个字串，这个命令可以在行模式下输入或在可视模式下通过前置一个半角冒号（“:”）再输入运行。举例而言如果你的上一个替换命令是“s/dog/cat/”那么“/the ~/”搜索式样将会匹配“the cat”。但substitute命令的输入字串自身也能用字元如果你在之前使用其中的一个字元那么搜索式样中使用波浪线会出现错误信息或匹配结果你要的不一致。当编辑器变量magic关闭后，你得加上一个反斜杠才能使用它的元值。 

字符集合。在搜索式样中还有一种字串元（多个字符组成的字元）。当多个字符使用半角方括号括起来时，可用来匹配括号中的这些字符中的任意一个。“/part [123]”将会匹配“part 1”、“part 2”或“part 3”。在关闭了编辑器变量 ignorecase （默认情形为关）后，这个功能经常用来查找可能含有大写的字串。输入“/[Cc]at/”会找到“Cat”和“cat”，而“/[Cc][Aa][Tt] /”则会匹配任意的大小写组合的“CAT”。（可用来匹配在输入“CAT”时不小心按到Shift键的情况，最后一个式样还能找到“CaT”、“CAt” 等字串。）

字串元的功能还能进一步扩展：可在其中使用字元。如果方括号中的第一个字符是脱字符，与字符集合正好是相反的意思（即补集）。现在该字串元匹配任意没出现在括号中的字符。式样“/^[^ ]/”匹配未以空格开始的行。在字符集合中如果脱字符不是方括号中的第一个字符时只表示一个普通的脱字符。

方括号中的短杠（连字符）也可做为一个字元。当它出现在两个字符中间，并且前一个字符的ASCII值要低于第二个时，它起的作用就如同你依ASCII次序由前一个字符逐个输入字符一直到第二个字符到方括号中一样。所以“/[0-9]%/”匹配一个数字紧接着一个“%”号的字串，它与“ /[0123456789]%/”是一样的。搜索式样“/[a-z]/”匹配任意的小写字母，而“/[a-zA-Z]/”匹配任意字母，不管是大写或小写的字母都能匹配。两个在方括号内使用的字元可以同时使用：“/[^A-Z]/”会匹配除大写字母以外的任意字符。当短杠出现在括号中的第一个或最后一个位置时它没有元值。当一个“字符-字符”的字串中的第一个字符的ASCII值比后一个字符高时，式样搜索时会忽略这两个字符及其中的短杠，所以 “/[ABz-a]/”与“/[AB]/”是一样的。

在字符集合中使用反斜杠的方法要复杂一点。如果有一个右方括号做为字符集合中的一部分出现在方括号中，必须在该右方括号前面加上反斜杠。不然编辑器会误认该括号为字符集合的结束标识。当然如果你要在字符集合中使用反斜杠你也必须在前面加上另一个反斜杠，而如果你希望括号开头的脱字符和字符中间的短杠作为字符集合的一部分不使用它们的元值――并且也不想将它们移到这个方括号的其他位置时，你也可以在它们之前加上反斜杠。在搜索样式的其他位置使用作为普通字符的左方括号时可在前面加上反斜杠，否则编辑器会以为那是一个字符集合开始的标识。最后，如果关闭了magic，你在你要开始一个字符集合时你得在左方括号前加上一个斜杠。


下一篇

在这个教程的第二部分，我会通过示范如何正确地将搜索式样与其他元素结合来指示命令的地址，来进一步讨论搜索式样的内容。


译注

[1] 注意这里的可视模式相当于Vim的一般模式和插入模式而不是Vim下的可视模式/圈选模式（也是Visual Mode）

[2] 行模式不是命令行模式的缩写。Ed/Ex类的编辑器中编辑是面向行的，用户使用命令对指定行进行编辑。这一类编辑器通常称为行编辑器。Vi的行模式即是使用Ex进行编辑的一种模式

[3] Vi可以同时打开多个文件，会话session就是当前编辑中的所有文件

转自http://blah.blogsome.com/2006/06/17/vi_tut_1/

搜索

最新发表

    * MPEG2-TS流文件的简介
    * 编写易于理解的代码
    * Linux管道
    * Linux系统基础开发技术1：构建Linux 库文件
    * C语言 itoa函数及atoi函数
    * 将整数转换成字符串
    * 字符串操作函数
    * DOS/Windows和Linux/Unix间文件格式转换
    * Analyzing Strings with sscanf
    * sscanf()详解

文章分类

    * Linux工具集 [1] (rss)
    * 算法与数据结构 [1] (rss)
    * ffmpeg [16] (rss)
    * Makefile [3] (rss)
    * linux [16] (rss)
    * 视频方案 [1] (rss)
    * 视频基础 [41] (rss)
    * VI/VIM [13] (rss)
    * Linux_C [29] (rss)
    * linux基础 [23] (rss)
    * shell [12] (rss)
    * 一般分类 [24] (rss)
    * cpp [0] (rss)
    * Linux内核 [0] (rss)

文章归档

    * 一月 2011 [3]
    * 十二月 2010 [11]
    * 十一月 2010 [109]
    * 十月 2010 [57]

网站链接

    * balabala
    * c
    * ffmpeg
          o ffmpeg
    * linux
          o freebsd
          o 流媒体开发论坛
          o 视频开发论坛
          o BSD rc.d脚本编程实战
          o Linux® 用户的 FreeBSD 快速入门向导
          o Tony Bai
          o UNIX Programming FAQ 中文版 v0.1.0
          o http://fanqiang.chinaunix.net/system/linux/index.shtml
          o http://man.chinaunix.net/develop/rfc/default.htm
    * video

新闻聚合

    * 关于
    * 资源中心
    * RSS 0.90
    * RSS 1.0
    * RSS 2.0
    * Atom 0.3

